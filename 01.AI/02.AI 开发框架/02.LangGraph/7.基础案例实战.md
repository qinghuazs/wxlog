---
title: LangGraphå®æˆ˜æ•™ç¨‹(ç¬¬7ç« ):åŸºç¡€æ¡ˆä¾‹å®æˆ˜
date: 2025-01-31
permalink: /ai/langgraph/7.åŸºç¡€æ¡ˆä¾‹å®æˆ˜.html
categories:
  - LangGraph
tags:
  - LangGraph
---

# åŸºç¡€æ¡ˆä¾‹å®æˆ˜

## ä¸€ã€æ¦‚è¿°

æœ¬ç« é€šè¿‡ä¸‰ä¸ªå¾ªåºæ¸è¿›çš„å®æˆ˜æ¡ˆä¾‹ï¼Œå¸®åŠ©ä½ æŒæ¡ LangGraph çš„åŸºç¡€åº”ç”¨å¼€å‘ã€‚

## äºŒã€æ¡ˆä¾‹ä¸€ï¼šæ™ºèƒ½å¾…åŠäº‹é¡¹ç®¡ç†å™¨

### 2.1 éœ€æ±‚è¯´æ˜

åˆ›å»ºä¸€ä¸ªæ™ºèƒ½å¾…åŠäº‹é¡¹ç®¡ç†å™¨ï¼Œæ”¯æŒæ·»åŠ ã€å®Œæˆã€ä¼˜å…ˆçº§æ’åºç­‰åŠŸèƒ½ã€‚

### 2.2 å®Œæ•´å®ç°

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Dict, Optional, Annotated
import operator
from datetime import datetime
from enum import Enum

# å®šä¹‰ä¼˜å…ˆçº§æšä¸¾
class Priority(Enum):
    HIGH = 1
    MEDIUM = 2
    LOW = 3

# å®šä¹‰ä»»åŠ¡ç»“æ„
class Task(TypedDict):
    id: int
    title: str
    description: str
    priority: Priority
    completed: bool
    created_at: str
    completed_at: Optional[str]

# å®šä¹‰çŠ¶æ€
class TodoState(TypedDict):
    tasks: List[Task]
    current_command: str
    command_params: Dict
    last_action: str
    message: Annotated[List[str], operator.add]

# èŠ‚ç‚¹å‡½æ•°
def parse_command(state: TodoState) -> TodoState:
    """è§£æç”¨æˆ·å‘½ä»¤"""
    command = state["current_command"].lower().strip()
    params = {}

    if command.startswith("add"):
        parts = command[3:].strip().split("|")
        params = {
            "action": "add",
            "title": parts[0] if len(parts) > 0 else "",
            "description": parts[1] if len(parts) > 1 else "",
            "priority": parts[2] if len(parts) > 2 else "medium"
        }
    elif command.startswith("complete"):
        task_id = command[8:].strip()
        params = {"action": "complete", "task_id": int(task_id) if task_id.isdigit() else 0}
    elif command == "list":
        params = {"action": "list"}
    elif command == "list high":
        params = {"action": "list", "filter": "high"}
    elif command.startswith("delete"):
        task_id = command[6:].strip()
        params = {"action": "delete", "task_id": int(task_id) if task_id.isdigit() else 0}
    else:
        params = {"action": "unknown"}

    return {
        "command_params": params,
        "message": [f"è§£æå‘½ä»¤: {params.get('action', 'unknown')}"]
    }

def add_task(state: TodoState) -> TodoState:
    """æ·»åŠ æ–°ä»»åŠ¡"""
    params = state["command_params"]

    # ç”Ÿæˆæ–°ID
    max_id = max([t["id"] for t in state["tasks"]], default=0)

    # è½¬æ¢ä¼˜å…ˆçº§
    priority_map = {
        "high": Priority.HIGH,
        "medium": Priority.MEDIUM,
        "low": Priority.LOW
    }

    new_task = Task(
        id=max_id + 1,
        title=params["title"],
        description=params["description"],
        priority=priority_map.get(params["priority"], Priority.MEDIUM),
        completed=False,
        created_at=datetime.now().isoformat(),
        completed_at=None
    )

    state["tasks"].append(new_task)
    return {
        "last_action": "add",
        "message": [f"âœ… æ·»åŠ ä»»åŠ¡: {new_task['title']} (ID: {new_task['id']})"]
    }

def complete_task(state: TodoState) -> TodoState:
    """å®Œæˆä»»åŠ¡"""
    task_id = state["command_params"]["task_id"]

    for task in state["tasks"]:
        if task["id"] == task_id:
            task["completed"] = True
            task["completed_at"] = datetime.now().isoformat()
            return {
                "last_action": "complete",
                "message": [f"âœ… å®Œæˆä»»åŠ¡: {task['title']}"]
            }

    return {
        "last_action": "complete",
        "message": [f"âŒ æœªæ‰¾åˆ°ä»»åŠ¡ ID: {task_id}"]
    }

def delete_task(state: TodoState) -> TodoState:
    """åˆ é™¤ä»»åŠ¡"""
    task_id = state["command_params"]["task_id"]

    for i, task in enumerate(state["tasks"]):
        if task["id"] == task_id:
            deleted = state["tasks"].pop(i)
            return {
                "last_action": "delete",
                "message": [f"ğŸ—‘ï¸ åˆ é™¤ä»»åŠ¡: {deleted['title']}"]
            }

    return {
        "last_action": "delete",
        "message": [f"âŒ æœªæ‰¾åˆ°ä»»åŠ¡ ID: {task_id}"]
    }

def list_tasks(state: TodoState) -> TodoState:
    """åˆ—å‡ºä»»åŠ¡"""
    filter_type = state["command_params"].get("filter")
    tasks = state["tasks"]

    # è¿‡æ»¤ä»»åŠ¡
    if filter_type == "high":
        tasks = [t for t in tasks if t["priority"] == Priority.HIGH]

    # æ’åºä»»åŠ¡ï¼ˆæŒ‰ä¼˜å…ˆçº§å’Œåˆ›å»ºæ—¶é—´ï¼‰
    tasks.sort(key=lambda x: (x["priority"].value, x["created_at"]))

    # æ ¼å¼åŒ–è¾“å‡º
    messages = ["ğŸ“‹ ä»»åŠ¡åˆ—è¡¨:"]
    if not tasks:
        messages.append("  æš‚æ— ä»»åŠ¡")
    else:
        for task in tasks:
            status = "âœ…" if task["completed"] else "â³"
            priority_emoji = {"HIGH": "ğŸ”´", "MEDIUM": "ğŸŸ¡", "LOW": "ğŸŸ¢"}
            p_emoji = priority_emoji.get(task["priority"].name, "")
            messages.append(
                f"  {status} [{task['id']}] {p_emoji} {task['title']}"
            )
            if task["description"]:
                messages.append(f"      {task['description']}")

    return {
        "last_action": "list",
        "message": messages
    }

def handle_unknown(state: TodoState) -> TodoState:
    """å¤„ç†æœªçŸ¥å‘½ä»¤"""
    return {
        "last_action": "unknown",
        "message": [
            "â“ æœªçŸ¥å‘½ä»¤ã€‚æ”¯æŒçš„å‘½ä»¤:",
            "  - add æ ‡é¢˜|æè¿°|ä¼˜å…ˆçº§",
            "  - complete ID",
            "  - delete ID",
            "  - list",
            "  - list high"
        ]
    }

# è·¯ç”±å‡½æ•°
def route_command(state: TodoState) -> str:
    action = state["command_params"].get("action")

    route_map = {
        "add": "add_task",
        "complete": "complete_task",
        "delete": "delete_task",
        "list": "list_tasks",
        "unknown": "handle_unknown"
    }

    return route_map.get(action, "handle_unknown")

# åˆ›å»ºå›¾
def create_todo_manager():
    graph = StateGraph(TodoState)

    # æ·»åŠ èŠ‚ç‚¹
    graph.add_node("parse", parse_command)
    graph.add_node("add_task", add_task)
    graph.add_node("complete_task", complete_task)
    graph.add_node("delete_task", delete_task)
    graph.add_node("list_tasks", list_tasks)
    graph.add_node("handle_unknown", handle_unknown)

    # æ·»åŠ è¾¹
    graph.add_conditional_edges(
        "parse",
        route_command,
        {
            "add_task": "add_task",
            "complete_task": "complete_task",
            "delete_task": "delete_task",
            "list_tasks": "list_tasks",
            "handle_unknown": "handle_unknown"
        }
    )

    # æ‰€æœ‰æ“ä½œèŠ‚ç‚¹éƒ½ç»“æŸ
    for node in ["add_task", "complete_task", "delete_task", "list_tasks", "handle_unknown"]:
        graph.add_edge(node, END)

    graph.set_entry_point("parse")

    return graph.compile()

# ä½¿ç”¨ç¤ºä¾‹
def run_todo_manager():
    app = create_todo_manager()

    # åˆå§‹çŠ¶æ€
    state = {
        "tasks": [],
        "message": []
    }

    # æµ‹è¯•å‘½ä»¤
    commands = [
        "add å­¦ä¹  LangGraph|é˜…è¯»å®˜æ–¹æ–‡æ¡£|high",
        "add å†™ä»£ç |å®Œæˆå®æˆ˜é¡¹ç›®|medium",
        "add ä¼‘æ¯|å–æ¯å’–å•¡|low",
        "list",
        "complete 1",
        "list high",
        "delete 3",
        "list"
    ]

    for cmd in commands:
        print(f"\næ‰§è¡Œå‘½ä»¤: {cmd}")
        state["current_command"] = cmd
        state["message"] = []

        result = app.invoke(state)
        state = result

        for msg in result["message"]:
            print(msg)

# è¿è¡Œ
if __name__ == "__main__":
    run_todo_manager()
```

## ä¸‰ã€æ¡ˆä¾‹äºŒï¼šå¤šæ­¥éª¤è¡¨å•éªŒè¯ç³»ç»Ÿ

### 3.1 éœ€æ±‚è¯´æ˜

åˆ›å»ºä¸€ä¸ªå¤šæ­¥éª¤è¡¨å•éªŒè¯ç³»ç»Ÿï¼ŒåŒ…æ‹¬æ ¼å¼éªŒè¯ã€ä¸šåŠ¡è§„åˆ™éªŒè¯å’Œæ•°æ®å®Œæ•´æ€§æ£€æŸ¥ã€‚

### 3.2 å®ç°ä»£ç 

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Dict, Annotated
import operator
import re
from datetime import datetime

class FormState(TypedDict):
    # è¡¨å•æ•°æ®
    name: str
    email: str
    phone: str
    age: int
    country: str

    # éªŒè¯ç»“æœ
    validation_errors: Annotated[List[str], operator.add]
    validation_warnings: Annotated[List[str], operator.add]
    validation_passed: bool

    # å¤„ç†æ­¥éª¤
    current_step: str
    steps_completed: Annotated[List[str], operator.add]

def validate_format(state: FormState) -> FormState:
    """æ ¼å¼éªŒè¯"""
    errors = []
    warnings = []

    # å§“åéªŒè¯
    if not state.get("name"):
        errors.append("å§“åä¸èƒ½ä¸ºç©º")
    elif len(state["name"]) < 2:
        errors.append("å§“åè‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦")
    elif len(state["name"]) > 50:
        warnings.append("å§“åè¿‡é•¿ï¼Œå»ºè®®ä¸è¶…è¿‡50ä¸ªå­—ç¬¦")

    # é‚®ç®±éªŒè¯
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not state.get("email"):
        errors.append("é‚®ç®±ä¸èƒ½ä¸ºç©º")
    elif not re.match(email_pattern, state["email"]):
        errors.append("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")

    # ç”µè¯éªŒè¯
    phone_pattern = r'^[\d\s\-\+\(\)]+$'
    if not state.get("phone"):
        errors.append("ç”µè¯ä¸èƒ½ä¸ºç©º")
    elif not re.match(phone_pattern, state["phone"]):
        errors.append("ç”µè¯æ ¼å¼ä¸æ­£ç¡®")
    elif len(re.sub(r'\D', '', state["phone"])) < 10:
        errors.append("ç”µè¯å·ç è‡³å°‘éœ€è¦10ä½æ•°å­—")

    return {
        "validation_errors": errors,
        "validation_warnings": warnings,
        "steps_completed": ["format_validation"],
        "current_step": "format_validation"
    }

def validate_business_rules(state: FormState) -> FormState:
    """ä¸šåŠ¡è§„åˆ™éªŒè¯"""
    errors = []
    warnings = []

    # å¹´é¾„éªŒè¯
    if state.get("age") is None:
        errors.append("å¹´é¾„ä¸èƒ½ä¸ºç©º")
    elif state["age"] < 0:
        errors.append("å¹´é¾„ä¸èƒ½ä¸ºè´Ÿæ•°")
    elif state["age"] < 18:
        errors.append("å¿…é¡»å¹´æ»¡18å²")
    elif state["age"] > 120:
        warnings.append("å¹´é¾„ä¼¼ä¹ä¸å¤ªåˆç†")

    # å›½å®¶éªŒè¯
    valid_countries = ["ä¸­å›½", "ç¾å›½", "è‹±å›½", "æ—¥æœ¬", "å¾·å›½", "æ³•å›½"]
    if not state.get("country"):
        errors.append("å›½å®¶ä¸èƒ½ä¸ºç©º")
    elif state["country"] not in valid_countries:
        warnings.append(f"å›½å®¶ '{state['country']}' ä¸åœ¨å¸¸ç”¨åˆ—è¡¨ä¸­")

    # ç‰¹æ®Šä¸šåŠ¡è§„åˆ™
    if state.get("age") and state["age"] < 21 and state.get("country") == "ç¾å›½":
        warnings.append("åœ¨ç¾å›½ï¼Œ21å²ä»¥ä¸‹å¯èƒ½æœ‰æŸäº›é™åˆ¶")

    return {
        "validation_errors": errors,
        "validation_warnings": warnings,
        "steps_completed": ["business_validation"],
        "current_step": "business_validation"
    }

def validate_data_integrity(state: FormState) -> FormState:
    """æ•°æ®å®Œæ•´æ€§æ£€æŸ¥"""
    errors = []
    warnings = []

    # æ£€æŸ¥é‚®ç®±å”¯ä¸€æ€§ï¼ˆæ¨¡æ‹Ÿï¼‰
    existing_emails = ["test@example.com", "admin@company.com"]
    if state.get("email") in existing_emails:
        errors.append("è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ")

    # æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
    if state.get("country") == "ä¸­å›½":
        if state.get("phone") and not state["phone"].startswith("+86"):
            warnings.append("ä¸­å›½ç”µè¯é€šå¸¸ä»¥ +86 å¼€å¤´")

    # äº¤å‰éªŒè¯
    if state.get("email"):
        email_domain = state["email"].split("@")[-1]
        if ".cn" in email_domain and state.get("country") != "ä¸­å›½":
            warnings.append("é‚®ç®±åŸŸåä¸å›½å®¶ä¸åŒ¹é…")

    return {
        "validation_errors": errors,
        "validation_warnings": warnings,
        "steps_completed": ["integrity_check"],
        "current_step": "integrity_check"
    }

def generate_summary(state: FormState) -> FormState:
    """ç”ŸæˆéªŒè¯æ‘˜è¦"""
    total_errors = len(state.get("validation_errors", []))
    total_warnings = len(state.get("validation_warnings", []))

    validation_passed = total_errors == 0

    summary = [
        "=" * 40,
        "è¡¨å•éªŒè¯æ‘˜è¦",
        "=" * 40,
        f"é”™è¯¯æ•°é‡: {total_errors}",
        f"è­¦å‘Šæ•°é‡: {total_warnings}",
        f"éªŒè¯ç»“æœ: {'âœ… é€šè¿‡' if validation_passed else 'âŒ æœªé€šè¿‡'}"
    ]

    if state.get("validation_errors"):
        summary.append("\nâŒ é”™è¯¯åˆ—è¡¨:")
        for error in state["validation_errors"]:
            summary.append(f"  - {error}")

    if state.get("validation_warnings"):
        summary.append("\nâš ï¸ è­¦å‘Šåˆ—è¡¨:")
        for warning in state["validation_warnings"]:
            summary.append(f"  - {warning}")

    print("\n".join(summary))

    return {
        "validation_passed": validation_passed,
        "steps_completed": ["summary"],
        "current_step": "summary"
    }

def route_after_format(state: FormState) -> str:
    """æ ¼å¼éªŒè¯åçš„è·¯ç”±"""
    # è·å–å½“å‰æ­¥éª¤çš„é”™è¯¯
    errors = [e for e in state.get("validation_errors", [])
              if "æ ¼å¼" in e or "ä¸èƒ½ä¸ºç©º" in e]

    if len(errors) > 3:  # å¦‚æœæ ¼å¼é”™è¯¯å¤ªå¤šï¼Œç›´æ¥ç»“æŸ
        return "summary"
    return "business_rules"

def route_after_business(state: FormState) -> str:
    """ä¸šåŠ¡è§„åˆ™éªŒè¯åçš„è·¯ç”±"""
    critical_errors = [e for e in state.get("validation_errors", [])
                      if "å¿…é¡»" in e or "ä¸èƒ½" in e]

    if critical_errors:
        return "summary"
    return "data_integrity"

# åˆ›å»ºéªŒè¯æµç¨‹
def create_form_validator():
    graph = StateGraph(FormState)

    # æ·»åŠ èŠ‚ç‚¹
    graph.add_node("format", validate_format)
    graph.add_node("business_rules", validate_business_rules)
    graph.add_node("data_integrity", validate_data_integrity)
    graph.add_node("summary", generate_summary)

    # æ·»åŠ æ¡ä»¶è¾¹
    graph.add_conditional_edges(
        "format",
        route_after_format,
        {
            "business_rules": "business_rules",
            "summary": "summary"
        }
    )

    graph.add_conditional_edges(
        "business_rules",
        route_after_business,
        {
            "data_integrity": "data_integrity",
            "summary": "summary"
        }
    )

    graph.add_edge("data_integrity", "summary")
    graph.add_edge("summary", END)

    graph.set_entry_point("format")

    return graph.compile()

# æµ‹è¯•è¡¨å•éªŒè¯
def test_form_validation():
    validator = create_form_validator()

    # æµ‹è¯•ç”¨ä¾‹
    test_cases = [
        {
            "name": "å¼ ä¸‰",
            "email": "zhangsan@example.cn",
            "phone": "+86 138 0000 0000",
            "age": 25,
            "country": "ä¸­å›½"
        },
        {
            "name": "J",
            "email": "invalid-email",
            "phone": "123",
            "age": 15,
            "country": "ç«æ˜Ÿ"
        },
        {
            "name": "John Doe",
            "email": "test@example.com",  # å·²å­˜åœ¨
            "phone": "+1 555 123 4567",
            "age": 30,
            "country": "ç¾å›½"
        }
    ]

    for i, test_case in enumerate(test_cases, 1):
        print(f"\n{'='*50}")
        print(f"æµ‹è¯•ç”¨ä¾‹ {i}: {test_case['name']}")
        print('='*50)

        initial_state = {
            **test_case,
            "validation_errors": [],
            "validation_warnings": [],
            "steps_completed": []
        }

        result = validator.invoke(initial_state)
        print(f"\nå®Œæˆæ­¥éª¤: {result['steps_completed']}")

if __name__ == "__main__":
    test_form_validation()
```

## å››ã€æ¡ˆä¾‹ä¸‰ï¼šç®€å•å¯¹è¯æœºå™¨äºº

### 4.1 éœ€æ±‚è¯´æ˜

åˆ›å»ºä¸€ä¸ªå…·æœ‰æ„å›¾è¯†åˆ«ã€ä¸Šä¸‹æ–‡ç®¡ç†å’Œå¤šè½®å¯¹è¯èƒ½åŠ›çš„ç®€å•æœºå™¨äººã€‚

### 4.2 å®ç°ä»£ç 

```python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from typing import TypedDict, List, Annotated, Optional
import operator
import random

class ChatState(TypedDict):
    messages: Annotated[List[Dict[str, str]], operator.add]
    user_input: str
    intent: str
    context: Dict[str, any]
    turn_count: int
    should_end: bool

class IntentClassifier:
    """ç®€å•çš„æ„å›¾åˆ†ç±»å™¨"""

    @staticmethod
    def classify(text: str) -> str:
        text_lower = text.lower()

        # é—®å€™
        if any(word in text_lower for word in ["ä½ å¥½", "hello", "hi", "å—¨"]):
            return "greeting"

        # å‘Šåˆ«
        if any(word in text_lower for word in ["å†è§", "bye", "æ‹œæ‹œ", "é€€å‡º"]):
            return "farewell"

        # è¯¢é—®å¤©æ°”
        if "å¤©æ°”" in text_lower or "weather" in text_lower:
            return "weather"

        # è¯¢é—®æ—¶é—´
        if any(word in text_lower for word in ["æ—¶é—´", "å‡ ç‚¹", "time"]):
            return "time"

        # è¯¢é—®åå­—
        if "åå­—" in text_lower or "name" in text_lower:
            return "name"

        # å¸®åŠ©
        if any(word in text_lower for word in ["å¸®åŠ©", "help", "åŠŸèƒ½"]):
            return "help"

        # é—²èŠ
        return "chitchat"

def get_user_input(state: ChatState) -> ChatState:
    """è·å–ç”¨æˆ·è¾“å…¥"""
    user_input = input("\nğŸ‘¤ ç”¨æˆ·: ")

    return {
        "user_input": user_input,
        "messages": [{"role": "user", "content": user_input}],
        "turn_count": state.get("turn_count", 0) + 1
    }

def classify_intent(state: ChatState) -> ChatState:
    """æ„å›¾è¯†åˆ«"""
    intent = IntentClassifier.classify(state["user_input"])

    return {
        "intent": intent,
        "messages": [{"role": "system", "content": f"è¯†åˆ«æ„å›¾: {intent}"}]
    }

def handle_greeting(state: ChatState) -> ChatState:
    """å¤„ç†é—®å€™"""
    greetings = [
        "ä½ å¥½ï¼å¾ˆé«˜å…´è§åˆ°ä½ ï¼ğŸ˜Š",
        "å—¨ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ",
        "ä½ å¥½å‘€ï¼ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿ"
    ]

    response = random.choice(greetings)

    # å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡é—®å€™ï¼Œè®°å½•åœ¨ä¸Šä¸‹æ–‡ä¸­
    if not state.get("context", {}).get("greeted"):
        state["context"] = state.get("context", {})
        state["context"]["greeted"] = True
        response += " æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚"

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def handle_farewell(state: ChatState) -> ChatState:
    """å¤„ç†å‘Šåˆ«"""
    farewells = [
        "å†è§ï¼ç¥ä½ æœ‰ä¸ªç¾å¥½çš„ä¸€å¤©ï¼ğŸ‘‹",
        "æ‹œæ‹œï¼éšæ—¶æ¬¢è¿å›æ¥èŠå¤©ï¼",
        "å†è§ï¼å¾ˆé«˜å…´å’Œä½ äº¤è°ˆï¼"
    ]

    response = random.choice(farewells)

    # å¦‚æœèŠå¤©æ—¶é—´è¾ƒé•¿ï¼Œæ·»åŠ é¢å¤–çš„å‘Šåˆ«è¯­
    if state.get("turn_count", 0) > 5:
        response += " æ„Ÿè°¢è¿™æ¬¡æ„‰å¿«çš„å¯¹è¯ï¼"

    return {
        "messages": [{"role": "assistant", "content": response}],
        "should_end": True
    }

def handle_weather(state: ChatState) -> ChatState:
    """å¤„ç†å¤©æ°”æŸ¥è¯¢"""
    cities = ["åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³"]
    weather_types = ["æ™´å¤©", "å¤šäº‘", "å°é›¨", "é˜´å¤©"]
    temps = range(15, 30)

    city = random.choice(cities)
    weather = random.choice(weather_types)
    temp = random.choice(temps)

    response = f"ä»Šå¤©{city}çš„å¤©æ°”æ˜¯{weather}ï¼Œæ¸©åº¦çº¦{temp}Â°Cã€‚"

    # æ·»åŠ å»ºè®®
    if "é›¨" in weather:
        response += " è®°å¾—å¸¦ä¼å“¦ï¼â˜”"
    elif weather == "æ™´å¤©":
        response += " é€‚åˆå‡ºé—¨æ´»åŠ¨ï¼â˜€ï¸"

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def handle_time(state: ChatState) -> ChatState:
    """å¤„ç†æ—¶é—´æŸ¥è¯¢"""
    from datetime import datetime

    now = datetime.now()
    response = f"ç°åœ¨æ˜¯ {now.strftime('%Yå¹´%mæœˆ%dæ—¥ %H:%M:%S')}"

    hour = now.hour
    if hour < 6:
        response += " å¤œæ·±äº†ï¼Œæ³¨æ„ä¼‘æ¯ï¼"
    elif hour < 12:
        response += " æ—©ä¸Šå¥½ï¼"
    elif hour < 18:
        response += " ä¸‹åˆå¥½ï¼"
    else:
        response += " æ™šä¸Šå¥½ï¼"

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def handle_name(state: ChatState) -> ChatState:
    """å¤„ç†åå­—è¯¢é—®"""
    response = "æˆ‘æ˜¯ LangGraph åŠ©æ‰‹ï¼Œä¸€ä¸ªåŸºäºçŠ¶æ€å›¾çš„æ™ºèƒ½å¯¹è¯ç³»ç»Ÿï¼"

    # å¦‚æœç”¨æˆ·ä¹‹å‰æåˆ°è¿‡è‡ªå·±çš„åå­—ï¼Œè®°ä½å®ƒ
    if "user_name" in state.get("context", {}):
        response += f" æˆ‘è®°å¾—ä½ æ˜¯ {state['context']['user_name']}ï¼"

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def handle_help(state: ChatState) -> ChatState:
    """å¤„ç†å¸®åŠ©è¯·æ±‚"""
    response = """æˆ‘å¯ä»¥å¸®ä½ ï¼š
    1. ğŸŒ¤ï¸ æŸ¥è¯¢å¤©æ°”
    2. â° å‘Šè¯‰ä½ æ—¶é—´
    3. ğŸ’¬ å’Œä½ é—²èŠ
    4. ğŸ‘‹ é—®å€™å’Œå‘Šåˆ«

    ä½ å¯ä»¥è¯•è¯•è¯´ï¼š
    - "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"
    - "ç°åœ¨å‡ ç‚¹äº†ï¼Ÿ"
    - "ä½ å«ä»€ä¹ˆåå­—ï¼Ÿ"
    """

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def handle_chitchat(state: ChatState) -> ChatState:
    """å¤„ç†é—²èŠ"""
    responses = [
        "è¿™å¾ˆæœ‰è¶£ï¼èƒ½è¯¦ç»†è¯´è¯´å—ï¼Ÿ",
        "æˆ‘æ˜ç™½äº†ï¼Œè¿˜æœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ",
        "å¬èµ·æ¥ä¸é”™ï¼",
        f"ä½ è¯´çš„æ˜¯ï¼š{state['user_input']}ã€‚è¿™ä¸ªè¯é¢˜å¾ˆæœ‰æ„æ€ï¼",
        "å—¯å—¯ï¼Œæˆ‘åœ¨å¬å‘¢ï¼"
    ]

    response = random.choice(responses)

    return {
        "messages": [{"role": "assistant", "content": response}]
    }

def route_by_intent(state: ChatState) -> str:
    """æ ¹æ®æ„å›¾è·¯ç”±"""
    intent_routes = {
        "greeting": "greeting",
        "farewell": "farewell",
        "weather": "weather",
        "time": "time",
        "name": "name",
        "help": "help",
        "chitchat": "chitchat"
    }

    return intent_routes.get(state["intent"], "chitchat")

def should_continue_chat(state: ChatState) -> str:
    """å†³å®šæ˜¯å¦ç»§ç»­å¯¹è¯"""
    if state.get("should_end"):
        return "end"

    if state.get("turn_count", 0) >= 10:
        return "farewell"  # å¯¹è¯è½®æ•°è¿‡å¤šï¼Œä¸»åŠ¨ç»“æŸ

    return "continue"

def print_response(state: ChatState) -> ChatState:
    """æ‰“å°æœºå™¨äººå“åº”"""
    for msg in state.get("messages", []):
        if msg["role"] == "assistant":
            print(f"ğŸ¤– åŠ©æ‰‹: {msg['content']}")

    return state

# åˆ›å»ºèŠå¤©æœºå™¨äºº
def create_chatbot():
    graph = StateGraph(ChatState)

    # æ·»åŠ èŠ‚ç‚¹
    graph.add_node("input", get_user_input)
    graph.add_node("classify", classify_intent)
    graph.add_node("greeting", handle_greeting)
    graph.add_node("farewell", handle_farewell)
    graph.add_node("weather", handle_weather)
    graph.add_node("time", handle_time)
    graph.add_node("name", handle_name)
    graph.add_node("help", handle_help)
    graph.add_node("chitchat", handle_chitchat)
    graph.add_node("print", print_response)

    # è®¾ç½®å…¥å£
    graph.set_entry_point("input")

    # ä»è¾“å…¥åˆ°åˆ†ç±»
    graph.add_edge("input", "classify")

    # æ ¹æ®æ„å›¾è·¯ç”±
    graph.add_conditional_edges(
        "classify",
        route_by_intent,
        {
            "greeting": "greeting",
            "farewell": "farewell",
            "weather": "weather",
            "time": "time",
            "name": "name",
            "help": "help",
            "chitchat": "chitchat"
        }
    )

    # æ‰€æœ‰å¤„ç†èŠ‚ç‚¹éƒ½åˆ°æ‰“å°
    for handler in ["greeting", "weather", "time", "name", "help", "chitchat"]:
        graph.add_edge(handler, "print")

    # å‘Šåˆ«ç‰¹æ®Šå¤„ç†
    graph.add_edge("farewell", "print")

    # æ‰“å°åå†³å®šæ˜¯å¦ç»§ç»­
    graph.add_conditional_edges(
        "print",
        should_continue_chat,
        {
            "continue": "input",
            "farewell": "farewell",
            "end": END
        }
    )

    # ä½¿ç”¨å†…å­˜æ£€æŸ¥ç‚¹ä¿å­˜å¯¹è¯å†å²
    memory = MemorySaver()

    return graph.compile(checkpointer=memory)

# è¿è¡ŒèŠå¤©æœºå™¨äºº
def run_chatbot():
    print("="*50)
    print("ğŸ¤– LangGraph èŠå¤©æœºå™¨äºº")
    print("="*50)
    print("è¾“å…¥ 'å†è§' æˆ– 'bye' é€€å‡º")
    print("è¾“å…¥ 'å¸®åŠ©' æˆ– 'help' æŸ¥çœ‹åŠŸèƒ½")
    print("-"*50)

    chatbot = create_chatbot()

    # é…ç½®ä¼šè¯
    config = {"configurable": {"thread_id": "chat-001"}}

    # åˆå§‹çŠ¶æ€
    initial_state = {
        "messages": [],
        "context": {},
        "turn_count": 0,
        "should_end": False
    }

    try:
        # è¿è¡Œå¯¹è¯å¾ªç¯
        chatbot.invoke(initial_state, config)
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ å¯¹è¯è¢«ä¸­æ–­ï¼Œå†è§ï¼")
    except Exception as e:
        print(f"\nâŒ å‘ç”Ÿé”™è¯¯ï¼š{e}")

if __name__ == "__main__":
    run_chatbot()
```

## äº”ã€æ¡ˆä¾‹æ€»ç»“ä¸å¯¹æ¯”

### 5.1 ä¸‰ä¸ªæ¡ˆä¾‹çš„ç‰¹ç‚¹å¯¹æ¯”

| ç‰¹æ€§ | å¾…åŠäº‹é¡¹ç®¡ç†å™¨ | è¡¨å•éªŒè¯ç³»ç»Ÿ | å¯¹è¯æœºå™¨äºº |
|------|--------------|-------------|-----------|
| **çŠ¶æ€å¤æ‚åº¦** | ä¸­ç­‰ | ç®€å• | å¤æ‚ |
| **èŠ‚ç‚¹æ•°é‡** | 6ä¸ª | 4ä¸ª | 10+ |
| **è·¯ç”±å¤æ‚åº¦** | ç®€å•æ¡ä»¶ | å¤šæ¡ä»¶ | æ„å›¾è·¯ç”± |
| **çŠ¶æ€æŒä¹…åŒ–** | å¦ | å¦ | æ˜¯ |
| **ç”¨æˆ·äº¤äº’** | å‘½ä»¤å¼ | æ‰¹å¤„ç† | å¯¹è¯å¼ |
| **é€‚ç”¨åœºæ™¯** | CRUDæ“ä½œ | æ•°æ®éªŒè¯ | äº¤äº’ç³»ç»Ÿ |

### 5.2 å­¦åˆ°çš„å…³é”®æŠ€èƒ½

1. **çŠ¶æ€è®¾è®¡**
   - ä½¿ç”¨ TypedDict å®šä¹‰ç»“æ„åŒ–çŠ¶æ€
   - åˆç†ä½¿ç”¨ Annotated å’Œ reducer
   - åŒºåˆ†å¿…è¦çŠ¶æ€å’Œä¸´æ—¶çŠ¶æ€

2. **èŠ‚ç‚¹å¼€å‘**
   - å•ä¸€èŒè´£åŸåˆ™
   - é”™è¯¯å¤„ç†
   - è¿”å›éƒ¨åˆ†æ›´æ–°

3. **æµç¨‹æ§åˆ¶**
   - æ¡ä»¶è·¯ç”±
   - å¾ªç¯æ§åˆ¶
   - æå‰é€€å‡º

4. **å®è·µæŠ€å·§**
   - æ¨¡å—åŒ–è®¾è®¡
   - æµ‹è¯•ç”¨ä¾‹ç¼–å†™
   - è°ƒè¯•å’Œæ—¥å¿—

## å…­ã€ç»ƒä¹ å»ºè®®

### 6.1 æ‰©å±•ç»ƒä¹ 

1. **å¾…åŠäº‹é¡¹ç®¡ç†å™¨**
   - æ·»åŠ æˆªæ­¢æ—¥æœŸåŠŸèƒ½
   - å®ç°ä»»åŠ¡åˆ†ç±»
   - æ·»åŠ æŒä¹…åŒ–å­˜å‚¨

2. **è¡¨å•éªŒè¯ç³»ç»Ÿ**
   - æ·»åŠ å¼‚æ­¥éªŒè¯ï¼ˆå¦‚APIè°ƒç”¨ï¼‰
   - å®ç°è‡ªå®šä¹‰éªŒè¯è§„åˆ™
   - ç”ŸæˆéªŒè¯æŠ¥å‘Š

3. **å¯¹è¯æœºå™¨äºº**
   - é›†æˆçœŸå®çš„NLPæ¨¡å‹
   - æ·»åŠ å¤šè½®å¯¹è¯è®°å¿†
   - å®ç°ä¸ªæ€§åŒ–å“åº”

### 6.2 è¿›é˜¶æŒ‘æˆ˜

1. ç»“åˆä¸‰ä¸ªæ¡ˆä¾‹ï¼Œåˆ›å»ºä¸€ä¸ªä»»åŠ¡åŠ©æ‰‹æœºå™¨äºº
2. æ·»åŠ å¯è§†åŒ–ç•Œé¢å±•ç¤ºæ‰§è¡Œæµç¨‹
3. å®ç°é”™è¯¯æ¢å¤å’Œé‡è¯•æœºåˆ¶

## ä¸ƒã€æœ€ä½³å®è·µæ€»ç»“

1. **å…ˆè®¾è®¡åç¼–ç **ï¼šç”»å‡ºæµç¨‹å›¾å†å®ç°
2. **æ¸è¿›å¼å¼€å‘**ï¼šä»ç®€å•åŠŸèƒ½å¼€å§‹é€æ­¥å®Œå–„
3. **å……åˆ†æµ‹è¯•**ï¼šå‡†å¤‡å¤šæ ·çš„æµ‹è¯•ç”¨ä¾‹
4. **æ–‡æ¡£æ³¨é‡Š**ï¼šä¿æŒä»£ç çš„å¯è¯»æ€§
5. **æ€§èƒ½æ„è¯†**ï¼šé¿å…ä¸å¿…è¦çš„çŠ¶æ€æ›´æ–°

---

**ä¸‹ä¸€æ­¥ï¼š** æ·±å…¥å­¦ä¹  [04.çŠ¶æ€ç®¡ç†è¯¦è§£](./04.çŠ¶æ€ç®¡ç†è¯¦è§£.md)ï¼ŒæŒæ¡æ›´é«˜çº§çš„çŠ¶æ€ç®¡ç†æŠ€å·§ï¼