---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆäº”ï¼‰ï¼šå·¥å…·ç³»ç»Ÿæ¶æ„
date: 2025-11-18
permalink: /ai/claude-code/architecture-05-tool-system-architecture.html
categories:
  - Claude Code
---

# å·¥å…·ç³»ç»Ÿæ¶æ„

## ä¸€ã€å¼•è¨€

å·¥å…·ç³»ç»Ÿæ˜¯ Claude Code çš„"æ‰‹å’Œçœ¼"ï¼Œèµ‹äºˆäº† AI ä¸çœŸå®ä¸–ç•Œäº¤äº’çš„èƒ½åŠ›ã€‚å¦‚æœè¯´ AI å¼•æ“æ˜¯"å¤§è„‘"ï¼Œé‚£ä¹ˆå·¥å…·ç³»ç»Ÿå°±æ˜¯"å››è‚¢"ï¼Œè´Ÿè´£æ‰§è¡Œå®é™…çš„æ–‡ä»¶æ“ä½œã€ä»£ç æœç´¢ã€å‘½ä»¤æ‰§è¡Œç­‰ä»»åŠ¡ã€‚æœ¬æ–‡å°†æ·±å…¥è§£æ Claude Code å·¥å…·ç³»ç»Ÿçš„å®Œæ•´æ¶æ„ã€‚

### ä¸ºä»€ä¹ˆå·¥å…·ç³»ç»Ÿå¦‚æ­¤é‡è¦ï¼Ÿ

1. **èµ‹èƒ½ AI**ï¼šè®© AI ä»"åªèƒ½è¯´"å˜æˆ"æ—¢èƒ½è¯´åˆèƒ½åš"
2. **æ ‡å‡†åŒ–äº¤äº’**ï¼šç»Ÿä¸€çš„å·¥å…·æ¥å£ï¼Œé™ä½é›†æˆå¤æ‚åº¦
3. **å®‰å…¨å¯æ§**ï¼šé€šè¿‡æƒé™ç®¡ç†å’Œå‚æ•°éªŒè¯ç¡®ä¿å®‰å…¨
4. **å¯æ‰©å±•æ€§**ï¼šæ’ä»¶åŒ–è®¾è®¡ï¼Œæ”¯æŒæ— é™æ‰©å±•
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ™ºèƒ½è°ƒåº¦å’Œå¹¶è¡Œæ‰§è¡Œæå‡æ•ˆç‡

### æœ¬æ–‡ç›®æ ‡

- ç†è§£å·¥å…·ç³»ç»Ÿçš„æ•´ä½“æ¶æ„
- æŒæ¡ Tool Schema è®¾è®¡è§„èŒƒ
- å­¦ä¹ å·¥å…·æ³¨å†Œå’Œè°ƒç”¨æµç¨‹
- äº†è§£æƒé™ç®¡ç†å’Œå®‰å…¨æœºåˆ¶
- å®æˆ˜å¼€å‘ä¸€ä¸ªè‡ªå®šä¹‰å·¥å…·


## äºŒã€Tool Schema è®¾è®¡è§„èŒƒ

### 2.1 JSON Schema æ ‡å‡†

Claude Code é‡‡ç”¨ JSON Schema å®šä¹‰å·¥å…·æ¥å£ï¼Œè¿™æ˜¯ Anthropic API çš„æ ‡å‡†æ ¼å¼ã€‚

```typescript
// å·¥å…·å®šä¹‰çš„å®Œæ•´ç±»å‹
interface ToolDefinition {
  // å·¥å…·åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ç¬¦ï¼‰
  name: string;

  // å·¥å…·æè¿°ï¼ˆAIç”¨äºç†è§£å·¥å…·ç”¨é€”ï¼‰
  description: string;

  // è¾“å…¥å‚æ•°çš„JSON Schema
  input_schema: {
    type: 'object';
    properties: Record<string, PropertySchema>;
    required?: string[];
    additionalProperties?: boolean;
  };
}

// å±æ€§å®šä¹‰
interface PropertySchema {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  description: string;
  enum?: any[];
  items?: PropertySchema;
  default?: any;
}
```

### 2.2 å†…ç½®å·¥å…·ç¤ºä¾‹

#### Read å·¥å…·å®šä¹‰

```typescript
const ReadToolDefinition: ToolDefinition = {
  name: 'Read',
  description: `Reads a file from the local filesystem. You can access any file directly by using this tool.

Usage:
- The file_path parameter must be an absolute path, not a relative path
- By default, it reads up to 2000 lines starting from the beginning
- You can optionally specify a line offset and limit (especially handy for long files)
- Any lines longer than 2000 characters will be truncated
- Results are returned using cat -n format, with line numbers starting at 1`,

  input_schema: {
    type: 'object',
    properties: {
      file_path: {
        type: 'string',
        description: 'The absolute path to the file to read'
      },
      offset: {
        type: 'number',
        description: 'The line number to start reading from. Only provide if the file is too large to read at once'
      },
      limit: {
        type: 'number',
        description: 'The number of lines to read. Only provide if the file is too large to read at once'
      }
    },
    required: ['file_path']
  }
};
```

#### Bash å·¥å…·å®šä¹‰

```typescript
const BashToolDefinition: ToolDefinition = {
  name: 'Bash',
  description: `Executes a given bash command in a persistent shell session.

Usage notes:
- Always quote file paths that contain spaces with double quotes
- The command argument is required
- You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes)
- You can use run_in_background parameter to run commands in background
- Avoid using Bash with find, grep, cat commands - use dedicated tools instead`,

  input_schema: {
    type: 'object',
    properties: {
      command: {
        type: 'string',
        description: 'The command to execute'
      },
      description: {
        type: 'string',
        description: 'Clear, concise description of what this command does in 5-10 words'
      },
      timeout: {
        type: 'number',
        description: 'Optional timeout in milliseconds (max 600000)',
        default: 120000
      },
      run_in_background: {
        type: 'boolean',
        description: 'Set to true to run this command in the background',
        default: false
      }
    },
    required: ['command']
  }
};
```

#### Edit å·¥å…·å®šä¹‰

```typescript
const EditToolDefinition: ToolDefinition = {
  name: 'Edit',
  description: `Performs exact string replacements in files.

Usage:
- You must use Read tool at least once before editing
- Preserve exact indentation as it appears in the file
- The edit will FAIL if old_string is not unique in the file
- Use replace_all for replacing and renaming strings across the file`,

  input_schema: {
    type: 'object',
    properties: {
      file_path: {
        type: 'string',
        description: 'The absolute path to the file to modify'
      },
      old_string: {
        type: 'string',
        description: 'The text to replace'
      },
      new_string: {
        type: 'string',
        description: 'The text to replace it with (must be different from old_string)'
      },
      replace_all: {
        type: 'boolean',
        description: 'Replace all occurences of old_string (default false)',
        default: false
      }
    },
    required: ['file_path', 'old_string', 'new_string']
  }
};
```

### 2.3 Schema è®¾è®¡æœ€ä½³å®è·µ

**1. æè¿°æ¸…æ™°**

```typescript
// âŒ ä¸å¥½çš„æè¿°
{
  name: 'search',
  description: 'Search files',
  // ...
}

// âœ… å¥½çš„æè¿°
{
  name: 'Grep',
  description: `A powerful search tool built on ripgrep.

Usage:
- ALWAYS use Grep for search tasks. NEVER invoke grep as a Bash command
- Supports full regex syntax (e.g., "log.*Error", "function\\s+\\w+")
- Filter files with glob parameter (e.g., "*.js", "**/*.tsx")
- Output modes: "content" shows matching lines, "files_with_matches" shows only file paths`,
  // ...
}
```

**2. å‚æ•°ç±»å‹æ˜ç¡®**

```typescript
// å®Œæ•´çš„å‚æ•°å®šä¹‰
properties: {
  file_path: {
    type: 'string',
    description: 'The absolute path to the file to read'
  },
  line_number: {
    type: 'number',
    description: 'The line number to start from (1-indexed)'
  },
  case_sensitive: {
    type: 'boolean',
    description: 'Whether the search is case sensitive',
    default: false
  },
  file_types: {
    type: 'array',
    description: 'File extensions to search (e.g., ["ts", "js"])',
    items: {
      type: 'string'
    }
  }
}
```

**3. å¿…éœ€å‚æ•°æ ‡æ³¨**

```typescript
{
  input_schema: {
    type: 'object',
    properties: {
      file_path: { type: 'string', description: '...' },
      content: { type: 'string', description: '...' },
      encoding: { type: 'string', description: '...', default: 'utf-8' }
    },
    // æ˜ç¡®æ ‡æ³¨å¿…éœ€å‚æ•°
    required: ['file_path', 'content']
  }
}
```


## ä¸‰ã€å‚æ•°éªŒè¯å’Œç±»å‹æ£€æŸ¥

### 3.1 å‚æ•°éªŒè¯å™¨

```typescript
/**
 * å‚æ•°éªŒè¯å™¨
 * è´Ÿè´£éªŒè¯å·¥å…·è°ƒç”¨å‚æ•°æ˜¯å¦ç¬¦åˆ Schema å®šä¹‰
 */
class ParameterValidator {
  /**
   * éªŒè¯å‚æ•°
   * @param toolName å·¥å…·åç§°
   * @param params å‚æ•°å¯¹è±¡
   * @param schema å‚æ•°çš„ JSON Schema
   * @returns éªŒè¯ç»“æœ
   */
  validate(
    toolName: string,
    params: Record<string, any>,
    schema: ToolDefinition['input_schema']
  ): ValidationResult {
    const errors: string[] = [];

    // 1. æ£€æŸ¥å¿…éœ€å‚æ•°
    if (schema.required) {
      for (const requiredField of schema.required) {
        if (!(requiredField in params)) {
          errors.push(`Missing required parameter: ${requiredField}`);
        }
      }
    }

    // 2. æ£€æŸ¥å‚æ•°ç±»å‹
    for (const [fieldName, value] of Object.entries(params)) {
      const fieldSchema = schema.properties[fieldName];

      if (!fieldSchema) {
        // æ£€æŸ¥æ˜¯å¦å…è®¸é¢å¤–å‚æ•°
        if (schema.additionalProperties === false) {
          errors.push(`Unknown parameter: ${fieldName}`);
        }
        continue;
      }

      // ç±»å‹æ£€æŸ¥
      const typeError = this.validateType(fieldName, value, fieldSchema);
      if (typeError) {
        errors.push(typeError);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * éªŒè¯å‚æ•°ç±»å‹
   */
  private validateType(
    fieldName: string,
    value: any,
    schema: PropertySchema
  ): string | null {
    const actualType = this.getType(value);

    if (schema.type === 'string' && actualType !== 'string') {
      return `Parameter ${fieldName} must be a string, got ${actualType}`;
    }

    if (schema.type === 'number' && actualType !== 'number') {
      return `Parameter ${fieldName} must be a number, got ${actualType}`;
    }

    if (schema.type === 'boolean' && actualType !== 'boolean') {
      return `Parameter ${fieldName} must be a boolean, got ${actualType}`;
    }

    if (schema.type === 'array') {
      if (!Array.isArray(value)) {
        return `Parameter ${fieldName} must be an array, got ${actualType}`;
      }

      // éªŒè¯æ•°ç»„å…ƒç´ 
      if (schema.items) {
        for (let i = 0; i < value.length; i++) {
          const itemError = this.validateType(
            `${fieldName}[${i}]`,
            value[i],
            schema.items
          );
          if (itemError) {
            return itemError;
          }
        }
      }
    }

    if (schema.type === 'object') {
      if (actualType !== 'object') {
        return `Parameter ${fieldName} must be an object, got ${actualType}`;
      }
    }

    // æ£€æŸ¥æšä¸¾å€¼
    if (schema.enum && !schema.enum.includes(value)) {
      return `Parameter ${fieldName} must be one of: ${schema.enum.join(', ')}`;
    }

    return null;
  }

  /**
   * è·å–å€¼çš„ç±»å‹
   */
  private getType(value: any): string {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (Array.isArray(value)) return 'array';
    return typeof value;
  }
}

/**
 * éªŒè¯ç»“æœ
 */
interface ValidationResult {
  valid: boolean;
  errors: string[];
}
```

### 4.2 å‚æ•°éªŒè¯ç¤ºä¾‹

```typescript
// ä½¿ç”¨ç¤ºä¾‹
const validator = new ParameterValidator();

// éªŒè¯ Read å·¥å…·å‚æ•°
const readParams = {
  file_path: '/path/to/file.ts',
  offset: 10,
  limit: 100
};

const result = validator.validate('Read', readParams, ReadToolDefinition.input_schema);

if (!result.valid) {
  console.error('Parameter validation failed:');
  result.errors.forEach(error => console.error(`  - ${error}`));
}

// é”™è¯¯ç¤ºä¾‹ï¼šç¼ºå°‘å¿…éœ€å‚æ•°
const invalidParams = {
  offset: 10
  // ç¼ºå°‘ file_path
};

const invalidResult = validator.validate('Read', invalidParams, ReadToolDefinition.input_schema);
// invalidResult.valid === false
// invalidResult.errors === ['Missing required parameter: file_path']
```


## å››ã€å·¥å…·è°ƒç”¨æµç¨‹

### 4.1 å®Œæ•´è°ƒç”¨æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant AI as Claude AI
    participant Dispatcher as å·¥å…·è°ƒåº¦å™¨
    participant Registry as å·¥å…·æ³¨å†Œè¡¨
    participant Validator as å‚æ•°éªŒè¯å™¨
    participant Permission as æƒé™ç®¡ç†å™¨
    participant Executor as å·¥å…·æ‰§è¡Œå™¨
    participant User as ç”¨æˆ·

    AI->>Dispatcher: Tool Call Request
    Note over AI,Dispatcher: tool_name: "Read"<br/>input: {file_path: "..."}

    Dispatcher->>Registry: æŸ¥æ‰¾å·¥å…·
    Registry-->>Dispatcher: è¿”å›å·¥å…·å®šä¹‰å’Œæ‰§è¡Œå™¨

    alt å·¥å…·ä¸å­˜åœ¨
        Dispatcher-->>AI: é”™è¯¯ï¼šå·¥å…·æœªæ‰¾åˆ°
    end

    Dispatcher->>Validator: éªŒè¯å‚æ•°
    Validator->>Validator: æ£€æŸ¥å¿…éœ€å‚æ•°
    Validator->>Validator: æ£€æŸ¥ç±»å‹
    Validator-->>Dispatcher: éªŒè¯ç»“æœ

    alt éªŒè¯å¤±è´¥
        Dispatcher-->>AI: é”™è¯¯ï¼šå‚æ•°æ— æ•ˆ
    end

    Dispatcher->>Permission: æ£€æŸ¥æƒé™
    Permission->>Permission: æ£€æŸ¥é»‘åå•
    Permission->>Permission: æ£€æŸ¥ç™½åå•

    alt éœ€è¦ç”¨æˆ·ç¡®è®¤
        Permission->>User: è¯·æ±‚ç¡®è®¤
        User-->>Permission: ç¡®è®¤/æ‹’ç»
    end

    Permission-->>Dispatcher: æƒé™æ£€æŸ¥ç»“æœ

    alt æƒé™è¢«æ‹’ç»
        Dispatcher-->>AI: é”™è¯¯ï¼šæƒé™è¢«æ‹’ç»
    end

    Dispatcher->>Executor: æ‰§è¡Œå·¥å…·
    Executor->>Executor: å®é™…æ“ä½œ<br/>ï¼ˆè¯»æ–‡ä»¶/æ‰§è¡Œå‘½ä»¤ç­‰ï¼‰

    alt æ‰§è¡ŒæˆåŠŸ
        Executor-->>Dispatcher: æˆåŠŸç»“æœ
        Dispatcher-->>AI: è¿”å›ç»“æœ
    else æ‰§è¡Œå¤±è´¥
        Executor-->>Dispatcher: é”™è¯¯ä¿¡æ¯
        Dispatcher-->>AI: è¿”å›é”™è¯¯
    end
```

### 6.2 å·¥å…·è°ƒåº¦å™¨å®ç°

```typescript
/**
 * å·¥å…·è°ƒåº¦å™¨
 * è´Ÿè´£åè°ƒå·¥å…·è°ƒç”¨çš„æ•´ä¸ªæµç¨‹
 */
class ToolDispatcher {
  private registry: ToolRegistry;
  private validator: ParameterValidator;
  private permissionManager: PermissionManager;

  constructor(
    registry: ToolRegistry,
    validator: ParameterValidator,
    permissionManager: PermissionManager
  ) {
    this.registry = registry;
    this.validator = validator;
    this.permissionManager = permissionManager;
  }

  /**
   * æ‰§è¡Œå·¥å…·è°ƒç”¨
   * @param toolCall AI çš„å·¥å…·è°ƒç”¨è¯·æ±‚
   * @returns å·¥å…·æ‰§è¡Œç»“æœ
   */
  async execute(toolCall: ToolCall): Promise<ToolResult> {
    const { name, input } = toolCall;

    try {
      // 1. æŸ¥æ‰¾å·¥å…·
      const executor = this.registry.getExecutor(name);
      if (!executor) {
        return {
          success: false,
          error: `Tool not found: ${name}`
        };
      }

      const definition = this.registry.getAllDefinitions().find(d => d.name === name);
      if (!definition) {
        return {
          success: false,
          error: `Tool definition not found: ${name}`
        };
      }

      // 2. éªŒè¯å‚æ•°
      const validationResult = this.validator.validate(
        name,
        input,
        definition.input_schema
      );

      if (!validationResult.valid) {
        return {
          success: false,
          error: `Parameter validation failed:\n${validationResult.errors.join('\n')}`
        };
      }

      // 3. æ£€æŸ¥æƒé™
      const permissionResult = await this.permissionManager.checkPermission(name, input);

      if (!permissionResult.allowed) {
        return {
          success: false,
          error: `Permission denied: ${permissionResult.reason || 'Unknown reason'}`
        };
      }

      // 4. æ‰§è¡Œå·¥å…·
      console.log(`ğŸ”§ Executing tool: ${name}`);
      const startTime = Date.now();

      const result = await executor.execute(input);

      const duration = Date.now() - startTime;
      console.log(`âœ… Tool ${name} completed in ${duration}ms`);

      return result;

    } catch (error) {
      console.error(`âŒ Tool ${name} failed:`, error);

      return {
        success: false,
        error: `Tool execution failed: ${error.message}`
      };
    }
  }

  /**
   * æ‰¹é‡æ‰§è¡Œå·¥å…·è°ƒç”¨
   * @param toolCalls å¤šä¸ªå·¥å…·è°ƒç”¨
   * @returns æ‰€æœ‰å·¥å…·çš„æ‰§è¡Œç»“æœ
   */
  async executeBatch(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
    return Promise.all(
      toolCalls.map(toolCall => this.execute(toolCall))
    );
  }
}

/**
 * å·¥å…·è°ƒç”¨è¯·æ±‚ï¼ˆæ¥è‡ªAIï¼‰
 */
interface ToolCall {
  id: string;
  type: 'tool_use';
  name: string;
  input: Record<string, any>;
}
```

### 6.3 ç«¯åˆ°ç«¯ç¤ºä¾‹

```typescript
// å®Œæ•´çš„å·¥å…·è°ƒç”¨ç¤ºä¾‹
async function exampleToolCallFlow() {
  // 1. åˆå§‹åŒ–ç³»ç»Ÿ
  const registry = new ToolRegistry();
  const validator = new ParameterValidator();
  const permissionManager = new PermissionManager();
  const dispatcher = new ToolDispatcher(registry, validator, permissionManager);

  // 2. æ³¨å†Œå·¥å…·
  registerBuiltInTools(registry);

  // 3. AI å‘èµ·å·¥å…·è°ƒç”¨
  const toolCall: ToolCall = {
    id: 'tool_call_123',
    type: 'tool_use',
    name: 'Read',
    input: {
      file_path: '/Users/user/project/src/index.ts',
      offset: 0,
      limit: 50
    }
  };

  // 4. æ‰§è¡Œå·¥å…·
  const result = await dispatcher.execute(toolCall);

  // 5. å¤„ç†ç»“æœ
  if (result.success) {
    console.log('æ–‡ä»¶å†…å®¹ï¼š');
    console.log(result.content);
  } else {
    console.error('æ‰§è¡Œå¤±è´¥ï¼š', result.error);
  }
}
```


## äº”ã€æœ€ä½³å®è·µ

### 5.1 å·¥å…·è®¾è®¡åŸåˆ™

**1. å•ä¸€èŒè´£**
```typescript
// âŒ ä¸å¥½ï¼šä¸€ä¸ªå·¥å…·åšå¤ªå¤šäº‹æƒ…
{
  name: 'FileManager',
  description: 'Manage files: read, write, delete, move, etc.'
}

// âœ… å¥½ï¼šæ¯ä¸ªå·¥å…·èŒè´£å•ä¸€
{
  name: 'Read',
  description: 'Reads a file from the filesystem'
}
```

**2. æ¸…æ™°çš„æ¥å£**
```typescript
// âœ… å¥½çš„å·¥å…·å®šä¹‰
{
  name: 'SearchCode',
  description: 'Search for patterns in code using regular expressions',
  input_schema: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description: 'Regular expression pattern to search for'
      },
      path: {
        type: 'string',
        description: 'Directory to search in (default: current directory)'
      },
      file_type: {
        type: 'string',
        description: 'File type filter (e.g., "ts", "js", "py")',
        enum: ['ts', 'js', 'py', 'java', 'go']
      }
    },
    required: ['pattern']
  }
}
```

**3. è¯¦ç»†çš„é”™è¯¯å¤„ç†**
```typescript
async execute(input: Record<string, any>): Promise<ToolResult> {
  try {
    // æ‰§è¡Œé€»è¾‘
  } catch (error) {
    // æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    return {
      success: false,
      error: `Failed to execute tool: ${error.message}\n\nSuggestion: Check if the file exists and you have read permissions.`
    };
  }
}
```

### 8.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

**1. å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·**
```typescript
// å½“å¤šä¸ªå·¥å…·è°ƒç”¨ç›¸äº’ç‹¬ç«‹æ—¶ï¼Œå¹¶è¡Œæ‰§è¡Œ
async function optimizedExecution(toolCalls: ToolCall[]) {
  // åˆ†æä¾èµ–å…³ç³»
  const independent = toolCalls.filter(call => !hasDependencies(call));
  const dependent = toolCalls.filter(call => hasDependencies(call));

  // å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·
  const independentResults = await Promise.all(
    independent.map(call => dispatcher.execute(call))
  );

  // é¡ºåºæ‰§è¡Œæœ‰ä¾èµ–çš„å·¥å…·
  const dependentResults = [];
  for (const call of dependent) {
    const result = await dispatcher.execute(call);
    dependentResults.push(result);
  }

  return [...independentResults, ...dependentResults];
}
```

**2. ç»“æœç¼“å­˜**
```typescript
class CachedToolExecutor implements ToolExecutor {
  private cache: Map<string, { result: ToolResult; timestamp: number }> = new Map();
  private ttl = 5 * 60 * 1000; // 5åˆ†é’Ÿ

  async execute(input: Record<string, any>): Promise<ToolResult> {
    const cacheKey = this.getCacheKey(input);

    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      console.log('âœ… Returning cached result');
      return cached.result;
    }

    // æ‰§è¡Œå·¥å…·
    const result = await this.actualExecute(input);

    // ç¼“å­˜ç»“æœ
    this.cache.set(cacheKey, {
      result,
      timestamp: Date.now()
    });

    return result;
  }

  private getCacheKey(input: Record<string, any>): string {
    return JSON.stringify(input);
  }
}
```

### 8.3 å®‰å…¨å»ºè®®

**1. è¾“å…¥éªŒè¯**
```typescript
// å§‹ç»ˆéªŒè¯å’Œæ¸…ç†è¾“å…¥
function sanitizeInput(input: string): string {
  // ç§»é™¤å±é™©å­—ç¬¦
  return input.replace(/[;&|`$]/g, '');
}
```

**2. è·¯å¾„éªŒè¯**
```typescript
function validatePath(filePath: string, workspaceRoot: string): boolean {
  const resolved = path.resolve(filePath);

  // ç¡®ä¿åœ¨å·¥ä½œåŒºå†…
  if (!resolved.startsWith(workspaceRoot)) {
    throw new Error('Access denied: path outside workspace');
  }

  // æ£€æŸ¥è·¯å¾„éå†æ”»å‡»
  if (filePath.includes('..')) {
    throw new Error('Invalid path: contains ".."');
  }

  return true;
}
```


## å…­ã€å®æˆ˜ç»ƒä¹ ï¼šåˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰å·¥å…·

### ç»ƒä¹ ç›®æ ‡

åˆ›å»ºä¸€ä¸ª `FileSearch` å·¥å…·ï¼Œå®ç°æ–‡ä»¶å†…å®¹æœç´¢å’Œæ›¿æ¢åŠŸèƒ½ã€‚

### ç»ƒä¹ æ­¥éª¤

**1. å®šä¹‰å·¥å…· Schema**

```typescript
const FileSearchToolDefinition: ToolDefinition = {
  name: 'FileSearch',
  description: `Search and optionally replace text in files.

Usage:
- Searches for a pattern across multiple files
- Supports regular expressions
- Can preview changes before replacing
- Returns list of matches with line numbers`,

  input_schema: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description: 'Pattern to search for (supports regex)'
      },
      path: {
        type: 'string',
        description: 'Directory to search in'
      },
      file_glob: {
        type: 'string',
        description: 'File pattern (e.g., "*.ts")',
        default: '*'
      },
      replace_with: {
        type: 'string',
        description: 'Replacement text (optional, for search and replace)'
      },
      preview_only: {
        type: 'boolean',
        description: 'Only preview changes without applying them',
        default: true
      }
    },
    required: ['pattern', 'path']
  }
};
```

**2. å®ç°æ‰§è¡Œå™¨**

```typescript
class FileSearchExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const {
      pattern,
      path: searchPath,
      file_glob = '*',
      replace_with,
      preview_only = true
    } = input;

    try {
      // 1. æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
      const fg = require('fast-glob');
      const files = await fg(file_glob, {
        cwd: searchPath,
        absolute: true
      });

      // 2. æœç´¢æ¯ä¸ªæ–‡ä»¶
      const matches: SearchMatch[] = [];
      const regex = new RegExp(pattern, 'g');

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');
        const lines = content.split('\n');

        lines.forEach((line, idx) => {
          if (regex.test(line)) {
            matches.push({
              file,
              lineNumber: idx + 1,
              line,
              match: pattern
            });
          }
          regex.lastIndex = 0; // é‡ç½®æ­£åˆ™
        });
      }

      // 3. å¦‚æœæ˜¯æ›¿æ¢æ“ä½œ
      if (replace_with && !preview_only) {
        for (const match of matches) {
          const content = fs.readFileSync(match.file, 'utf-8');
          const newContent = content.replace(new RegExp(pattern, 'g'), replace_with);
          fs.writeFileSync(match.file, newContent, 'utf-8');
        }
      }

      // 4. æ ¼å¼åŒ–è¾“å‡º
      const output = this.formatMatches(matches, replace_with, preview_only);

      return {
        success: true,
        content: output,
        metadata: {
          totalMatches: matches.length,
          filesSearched: files.length,
          replaced: !preview_only && !!replace_with
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `File search failed: ${error.message}`
      };
    }
  }

  private formatMatches(
    matches: SearchMatch[],
    replaceWith?: string,
    previewOnly?: boolean
  ): string {
    if (matches.length === 0) {
      return 'No matches found';
    }

    let output = `Found ${matches.length} matches:\n\n`;

    for (const match of matches) {
      output += `${match.file}:${match.lineNumber}\n`;
      output += `  ${match.line}\n`;

      if (replaceWith) {
        const preview = match.line.replace(
          new RegExp(match.match, 'g'),
          replaceWith
        );
        output += `  â†’ ${preview}\n`;
      }

      output += '\n';
    }

    if (replaceWith && previewOnly) {
      output += '\nâš ï¸  Preview only. Set preview_only=false to apply changes.';
    }

    return output;
  }
}

interface SearchMatch {
  file: string;
  lineNumber: number;
  line: string;
  match: string;
}
```

**3. æ³¨å†Œå’Œæµ‹è¯•**

```typescript
// æ³¨å†Œå·¥å…·
toolRegistry.register(FileSearchToolDefinition, new FileSearchExecutor());

// æµ‹è¯•å·¥å…·
const testCall: ToolCall = {
  id: 'test_1',
  type: 'tool_use',
  name: 'FileSearch',
  input: {
    pattern: 'TODO',
    path: '/Users/user/project/src',
    file_glob: '**/*.ts',
    preview_only: true
  }
};

const result = await dispatcher.execute(testCall);
console.log(result.content);
```

### åç»­æ‰©å±•

1. æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•éªŒè¯
2. æ”¯æŒå¤šè¡ŒåŒ¹é…
3. æ·»åŠ æ’é™¤æ¨¡å¼ï¼ˆå¿½ç•¥æŸäº›æ–‡ä»¶ï¼‰
4. å®ç°æ‰¹é‡æ›¿æ¢çš„æ’¤é”€åŠŸèƒ½
5. æ·»åŠ è¿›åº¦æ˜¾ç¤ºï¼ˆå¤§å‹æœç´¢ï¼‰

