---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆäºŒï¼‰ï¼šæ ¸å¿ƒå¼•æ“å®ç°
date: 2025-01-14
permalink: /ai/claude-code/architecture-02-core-engine.html
tags:
  - Claude Code
categories:
  - Claude Code
---

# æ ¸å¿ƒå¼•æ“å®ç°

## å¼•è¨€

AI å¼•æ“æ˜¯ Claude Code çš„"å¤§è„‘"ï¼Œè´Ÿè´£ç†è§£ç”¨æˆ·æ„å›¾ã€åšå‡ºå†³ç­–ã€è°ƒç”¨å·¥å…·ã€ç”Ÿæˆå“åº”ã€‚æœ¬æ–‡å°†æ·±å…¥å‰–æ AI å¼•æ“çš„å®ç°åŸç†ï¼ŒåŒ…æ‹¬åˆå§‹åŒ–æµç¨‹ã€Prompt å·¥ç¨‹ã€æ¶ˆæ¯å¤„ç†ã€æµå¼å“åº”å’Œé”™è¯¯æ¢å¤ç­‰æ ¸å¿ƒæŠ€æœ¯ã€‚

### ä¸ºä»€ä¹ˆè¦ç†è§£ AI å¼•æ“ï¼Ÿ

1. **ä¼˜åŒ–äº¤äº’ä½“éªŒ**ï¼šç†è§£å¼•æ“å·¥ä½œåŸç†ï¼Œèƒ½æ›´å¥½åœ°ä¸ AI æ²Ÿé€š
2. **å®šåˆ¶åŒ–å¼€å‘**ï¼šä¸ºå¼€å‘è‡ªå·±çš„ AI åº”ç”¨æ‰“åŸºç¡€
3. **é—®é¢˜è¯Šæ–­**ï¼šå¿«é€Ÿå®šä½å’Œè§£å†³ä½¿ç”¨ä¸­çš„é—®é¢˜
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šäº†è§£æ€§èƒ½ç“¶é¢ˆï¼Œåšé’ˆå¯¹æ€§ä¼˜åŒ–

### ä¸ä¼ ç»Ÿç¼–ç¨‹çš„åŒºåˆ«

**ä¼ ç»Ÿç¼–ç¨‹**ï¼š
```
è¾“å…¥ â†’ ç¡®å®šæ€§é€»è¾‘ â†’ è¾“å‡º
```

**AI é©±åŠ¨ç¼–ç¨‹**ï¼š
```
è¾“å…¥ â†’ AIæ¨ç†ï¼ˆæ¦‚ç‡æ€§ï¼‰â†’ å·¥å…·è°ƒç”¨ â†’ ç»“æœæ•´åˆ â†’ è¾“å‡º
```

å…³é”®å·®å¼‚ï¼š
- âŒ ä¸æ˜¯å®Œå…¨ç¡®å®šæ€§çš„
- âœ… èƒ½å¤Ÿç†è§£è‡ªç„¶è¯­è¨€
- âœ… å…·æœ‰ä¸Šä¸‹æ–‡æ„ŸçŸ¥èƒ½åŠ›
- âœ… å¯ä»¥è‡ªä¸»å†³ç­–å’Œè°ƒç”¨å·¥å…·

## ä¸€ã€AI å¼•æ“æ•´ä½“æ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶

```mermaid
graph TB
    subgraph "AI Engine"
        A[Engine Core] --> B[Message Manager]
        A --> C[API Client]
        A --> D[Stream Processor]
        A --> E[Tool Handler]
        A --> F[Response Parser]
        A --> G[Error Handler]
    end

    subgraph "å¤–éƒ¨ä¾èµ–"
        H[Anthropic API]
        I[Tool Registry]
        J[Context Manager]
        K[Session Store]
    end

    C --> H
    E --> I
    B --> J
    A --> K

    style A fill:#ffe1f5,stroke:#333,stroke-width:3px
    style H fill:#e1f5ff,stroke:#333,stroke-width:2px
```

### 1.2 ç»„ä»¶èŒè´£

| ç»„ä»¶ | èŒè´£ | å…³é”®åŠŸèƒ½ |
|------|------|---------|
| **Engine Core** | å¼•æ“æ ¸å¿ƒåè°ƒå™¨ | ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€æµç¨‹ç¼–æ’ |
| **Message Manager** | æ¶ˆæ¯ç®¡ç† | æ¶ˆæ¯æ ¼å¼åŒ–ã€å†å²ç®¡ç† |
| **API Client** | APIé€šä¿¡ | HTTPè¯·æ±‚ã€è®¤è¯ã€é‡è¯• |
| **Stream Processor** | æµå¼å¤„ç† | SSEè§£æã€å¢é‡è¾“å‡º |
| **Tool Handler** | å·¥å…·å¤„ç† | å·¥å…·è°ƒç”¨ã€ç»“æœæ”¶é›† |
| **Response Parser** | å“åº”è§£æ | å†…å®¹æå–ã€æ ¼å¼è½¬æ¢ |
| **Error Handler** | é”™è¯¯å¤„ç† | å¼‚å¸¸æ•è·ã€æ¢å¤ç­–ç•¥ |



## äºŒã€åˆå§‹åŒ–æµç¨‹

### 2.1 åˆå§‹åŒ–æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant Main as ä¸»ç¨‹åº
    participant Engine as AI Engine
    participant Config as é…ç½®ç®¡ç†
    participant API as API Client
    participant Tools as å·¥å…·æ³¨å†Œè¡¨
    participant Prompt as PromptåŠ è½½å™¨

    Main->>Engine: åˆ›å»ºå¼•æ“å®ä¾‹
    Engine->>Config: åŠ è½½é…ç½®
    Config-->>Engine: è¿”å›é…ç½®

    Engine->>API: åˆå§‹åŒ–APIå®¢æˆ·ç«¯
    API->>API: éªŒè¯API Key
    API-->>Engine: å®¢æˆ·ç«¯å°±ç»ª

    Engine->>Tools: åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨
    Tools->>Tools: æ³¨å†Œå†…ç½®å·¥å…·
    Tools->>Tools: åŠ è½½MCPå·¥å…·
    Tools-->>Engine: å·¥å…·åˆ—è¡¨

    Engine->>Prompt: åŠ è½½ç³»ç»Ÿæç¤ºè¯
    Prompt->>Prompt: è¯»å–æ¨¡æ¿
    Prompt->>Prompt: å˜é‡æ›¿æ¢
    Prompt-->>Engine: ç³»ç»Ÿæç¤ºè¯

    Engine->>Engine: åˆå§‹åŒ–çŠ¶æ€
    Engine-->>Main: å¼•æ“å°±ç»ª
```

### 2.2 åˆå§‹åŒ–ä»£ç å®ç°

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { ToolRegistry } from './tools/registry';
import { ContextManager } from './context/manager';
import { SessionStore } from './session/store';

/**
 * AI å¼•æ“é…ç½®æ¥å£
 */
interface AIEngineConfig {
  apiKey: string;                    // Anthropic API Key
  model?: string;                    // æ¨¡å‹åç§°
  maxTokens?: number;                // æœ€å¤§tokenæ•°
  temperature?: number;              // æ¸©åº¦å‚æ•°
  systemPromptPath?: string;         // ç³»ç»Ÿæç¤ºè¯è·¯å¾„
  enableStreaming?: boolean;         // æ˜¯å¦å¯ç”¨æµå¼å“åº”
  enableToolCalling?: boolean;       // æ˜¯å¦å¯ç”¨å·¥å…·è°ƒç”¨
  maxToolCallDepth?: number;         // å·¥å…·è°ƒç”¨æœ€å¤§æ·±åº¦
}

/**
 * AI å¼•æ“æ ¸å¿ƒç±»
 */
class AIEngine {
  private client: Anthropic;
  private config: AIEngineConfig;
  private toolRegistry: ToolRegistry;
  private contextManager: ContextManager;
  private sessionStore: SessionStore;
  private systemPrompt: string;
  private isInitialized: boolean = false;

  constructor(config: AIEngineConfig) {
    this.config = this.normalizeConfig(config);
    this.validateConfig();
  }

  /**
   * åˆå§‹åŒ–å¼•æ“
   */
  async initialize(): Promise<void> {
    console.log('ğŸš€ åˆå§‹åŒ– AI å¼•æ“...');

    try {
      // 1. åˆå§‹åŒ– API å®¢æˆ·ç«¯
      await this.initializeAPIClient();

      // 2. åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨
      await this.initializeTools();

      // 3. åŠ è½½ç³»ç»Ÿæç¤ºè¯
      await this.loadSystemPrompt();

      // 4. åˆå§‹åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨
      this.contextManager = new ContextManager({
        maxTokens: this.config.maxTokens || 100000
      });

      // 5. åˆå§‹åŒ–ä¼šè¯å­˜å‚¨
      this.sessionStore = new SessionStore();

      this.isInitialized = true;
      console.log('âœ… AI å¼•æ“åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      console.error('âŒ AI å¼•æ“åˆå§‹åŒ–å¤±è´¥:', error);
      throw new Error(`Engine initialization failed: ${error.message}`);
    }
  }

  /**
   * åˆå§‹åŒ– API å®¢æˆ·ç«¯
   */
  private async initializeAPIClient(): Promise<void> {
    console.log('  ğŸ“¡ åˆå§‹åŒ– API å®¢æˆ·ç«¯...');

    this.client = new Anthropic({
      apiKey: this.config.apiKey,
      // å¯é€‰ï¼šè‡ªå®šä¹‰è¶…æ—¶ã€é‡è¯•ç­‰
      timeout: 60000,
      maxRetries: 3
    });

    // éªŒè¯ API Keyï¼ˆå‘é€ä¸€ä¸ªç®€å•è¯·æ±‚ï¼‰
    try {
      await this.client.messages.create({
        model: this.config.model!,
        max_tokens: 10,
        messages: [{ role: 'user', content: 'test' }]
      });
      console.log('  âœ… API å®¢æˆ·ç«¯å°±ç»ª');
    } catch (error) {
      throw new Error(`API Key validation failed: ${error.message}`);
    }
  }

  /**
   * åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨
   */
  private async initializeTools(): Promise<void> {
    console.log('  ğŸ”§ åˆå§‹åŒ–å·¥å…·æ³¨å†Œè¡¨...');

    this.toolRegistry = new ToolRegistry();

    // æ³¨å†Œå†…ç½®å·¥å…·
    await this.toolRegistry.registerBuiltinTools();

    // åŠ è½½ MCP å·¥å…·
    await this.toolRegistry.loadMCPTools();

    const toolCount = this.toolRegistry.getToolCount();
    console.log(`  âœ… å·²åŠ è½½ ${toolCount} ä¸ªå·¥å…·`);
  }

  /**
   * åŠ è½½ç³»ç»Ÿæç¤ºè¯
   */
  private async loadSystemPrompt(): Promise<void> {
    console.log('  ğŸ“ åŠ è½½ç³»ç»Ÿæç¤ºè¯...');

    const promptLoader = new SystemPromptLoader();
    this.systemPrompt = await promptLoader.load(
      this.config.systemPromptPath || './prompts/system.md'
    );

    // å˜é‡æ›¿æ¢
    this.systemPrompt = this.replaceVariables(this.systemPrompt, {
      currentDate: new Date().toISOString().split('T')[0],
      platform: process.platform,
      workingDirectory: process.cwd()
    });

    console.log('  âœ… ç³»ç»Ÿæç¤ºè¯åŠ è½½å®Œæˆ');
  }

  /**
   * é…ç½®æ ‡å‡†åŒ–
   */
  private normalizeConfig(config: AIEngineConfig): AIEngineConfig {
    return {
      model: 'claude-3-5-sonnet-20250929',
      maxTokens: 8000,
      temperature: 0,
      enableStreaming: true,
      enableToolCalling: true,
      maxToolCallDepth: 5,
      ...config
    };
  }

  /**
   * é…ç½®éªŒè¯
   */
  private validateConfig(): void {
    if (!this.config.apiKey) {
      throw new Error('API Key is required');
    }

    if (this.config.maxTokens! < 1 || this.config.maxTokens! > 200000) {
      throw new Error('maxTokens must be between 1 and 200000');
    }

    if (this.config.temperature! < 0 || this.config.temperature! > 1) {
      throw new Error('temperature must be between 0 and 1');
    }
  }

  /**
   * å˜é‡æ›¿æ¢
   */
  private replaceVariables(
    template: string,
    variables: Record<string, string>
  ): string {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
    }
    return result;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
   */
  private ensureInitialized(): void {
    if (!this.isInitialized) {
      throw new Error('Engine not initialized. Call initialize() first.');
    }
  }
}

export { AIEngine, AIEngineConfig };
```



## ä¸‰ã€Prompt å·¥ç¨‹è¯¦è§£

### 3.1 ç³»ç»Ÿæç¤ºè¯çš„ä½œç”¨

ç³»ç»Ÿæç¤ºè¯ï¼ˆSystem Promptï¼‰æ˜¯ AI å¼•æ“çš„"æ“ä½œæ‰‹å†Œ"ï¼Œå®šä¹‰äº†ï¼š
- âœ… AI çš„è§’è‰²å’Œèƒ½åŠ›
- âœ… è¡Œä¸ºå‡†åˆ™å’Œé™åˆ¶
- âœ… å·¥å…·ä½¿ç”¨æŒ‡å—
- âœ… è¾“å‡ºæ ¼å¼è¦æ±‚

### 3.2 Claude Code ç³»ç»Ÿæç¤ºè¯ç»“æ„

```markdown
# System Prompt ç»“æ„

## 1. è§’è‰²å®šä¹‰ï¼ˆRole Definitionï¼‰
ä½ æ˜¯ Claude Codeï¼ŒAnthropic çš„å®˜æ–¹ CLI ä»£ç ç¼–è¾‘å™¨...

## 2. èƒ½åŠ›è¯´æ˜ï¼ˆCapabilitiesï¼‰
ä½ å¯ä»¥è®¿é—®ä»¥ä¸‹å·¥å…·ï¼š
- Read: è¯»å–æ–‡ä»¶
- Write: å†™å…¥æ–‡ä»¶
- Edit: ç¼–è¾‘æ–‡ä»¶
- Bash: æ‰§è¡Œå‘½ä»¤
...

## 3. è¡Œä¸ºå‡†åˆ™ï¼ˆGuidelinesï¼‰
- åœ¨æ‰§è¡Œç ´åæ€§æ“ä½œå‰å¿…é¡»è¯¢é—®ç”¨æˆ·
- æä¾›æ¸…æ™°çš„è§£é‡Šå’Œç†ç”±
- éµå¾ªç¼–ç¨‹æœ€ä½³å®è·µ
...

## 4. å·¥å…·ä½¿ç”¨ç¤ºä¾‹ï¼ˆTool Usage Examplesï¼‰
### ç¤ºä¾‹ 1ï¼šè¯»å–æ–‡ä»¶
ç”¨æˆ·ï¼š"å¸®æˆ‘çœ‹çœ‹ README.md çš„å†…å®¹"
ä½ çš„æ€è€ƒï¼šéœ€è¦ä½¿ç”¨ Read å·¥å…·
å·¥å…·è°ƒç”¨ï¼šRead(file_path="/path/to/README.md")
...

## 5. è¾“å‡ºæ ¼å¼ï¼ˆOutput Formatï¼‰
- ä½¿ç”¨ Markdown æ ¼å¼
- ä»£ç å—æŒ‡å®šè¯­è¨€
- æ–‡ä»¶å¼•ç”¨ä½¿ç”¨ file_path:line_number æ ¼å¼
...

## 6. ç¯å¢ƒä¿¡æ¯ï¼ˆEnvironmentï¼‰
- å½“å‰æ—¥æœŸï¼š{{currentDate}}
- æ“ä½œç³»ç»Ÿï¼š{{platform}}
- å·¥ä½œç›®å½•ï¼š{{workingDirectory}}
...
```

### 3.3 åŠ¨æ€æç¤ºè¯ç”Ÿæˆ

```typescript
/**
 * ç³»ç»Ÿæç¤ºè¯åŠ è½½å™¨
 */
class SystemPromptLoader {
  /**
   * åŠ è½½ç³»ç»Ÿæç¤ºè¯
   */
  async load(promptPath: string): Promise<string> {
    // 1. è¯»å–åŸºç¡€æ¨¡æ¿
    const template = await fs.readFile(promptPath, 'utf-8');

    // 2. æ·»åŠ å·¥å…·æ–‡æ¡£
    const toolDocs = await this.generateToolDocumentation();

    // 3. æ·»åŠ é¡¹ç›®ç‰¹å®šä¿¡æ¯
    const projectInfo = await this.getProjectInfo();

    // 4. ç»„åˆ
    return this.combinePrompt(template, toolDocs, projectInfo);
  }

  /**
   * ç”Ÿæˆå·¥å…·æ–‡æ¡£
   */
  private async generateToolDocumentation(): Promise<string> {
    const tools = toolRegistry.getAllTools();

    let docs = '\n## Available Tools\n\n';

    for (const tool of tools) {
      docs += `### ${tool.name}\n`;
      docs += `${tool.description}\n\n`;
      docs += `**Parameters:**\n`;

      for (const [name, schema] of Object.entries(tool.input_schema.properties)) {
        const required = tool.input_schema.required?.includes(name) ? '(required)' : '(optional)';
        docs += `- \`${name}\` ${required}: ${schema.description}\n`;
      }

      docs += '\n';
    }

    return docs;
  }

  /**
   * è·å–é¡¹ç›®ä¿¡æ¯
   */
  private async getProjectInfo(): Promise<string> {
    let info = '\n## Project Context\n\n';

    // Git ä¿¡æ¯
    try {
      const branch = await execCommand('git rev-parse --abbrev-ref HEAD');
      info += `- Current branch: ${branch}\n`;
    } catch {
      info += '- Not a git repository\n';
    }

    // package.json
    try {
      const pkg = await fs.readJSON('./package.json');
      info += `- Project: ${pkg.name}\n`;
      info += `- Version: ${pkg.version}\n`;
    } catch {
      // å¿½ç•¥
    }

    return info;
  }

  /**
   * ç»„åˆæç¤ºè¯
   */
  private combinePrompt(
    template: string,
    toolDocs: string,
    projectInfo: string
  ): string {
    // åœ¨æ¨¡æ¿ä¸­æ’å…¥åŠ¨æ€å†…å®¹
    return template
      .replace('{{TOOL_DOCS}}', toolDocs)
      .replace('{{PROJECT_INFO}}', projectInfo);
  }
}
```

### 3.4 Few-Shot ç¤ºä¾‹è®¾è®¡

Few-shot ç¤ºä¾‹èƒ½æ˜¾è‘—æå‡ AI çš„è¡¨ç°ã€‚

**ç¤ºä¾‹é€‰æ‹©åŸåˆ™**ï¼š
1. **è¦†ç›–å¸¸è§åœºæ™¯**ï¼šæ–‡ä»¶æ“ä½œã€ä»£ç æœç´¢ã€è°ƒè¯•ç­‰
2. **å±•ç¤ºæœ€ä½³å®è·µ**ï¼šå¦‚ä½•æ­£ç¡®ä½¿ç”¨å·¥å…·
3. **åŒ…å«è¾¹ç•Œæƒ…å†µ**ï¼šé”™è¯¯å¤„ç†ã€æƒé™é—®é¢˜ç­‰
4. **ç®€æ´æ˜äº†**ï¼šæ¯ä¸ªç¤ºä¾‹3-5è½®å¯¹è¯

**Few-Shot ç¤ºä¾‹æ¨¡æ¿**ï¼š
```markdown
## Example: æ–‡ä»¶è¯»å–å’Œåˆ†æ

User: "å¸®æˆ‘åˆ†æä¸€ä¸‹ src/index.ts çš„ä»£ç ç»“æ„"

Assistant: "å¥½çš„,æˆ‘æ¥å¸®ä½ åˆ†æ src/index.ts çš„ä»£ç ç»“æ„ã€‚"

<tool_call>
{
  "name": "Read",
  "parameters": {
    "file_path": "/project/src/index.ts"
  }
}
</tool_call>

<tool_result>
// src/index.ts
import express from 'express';
import { router } from './routes';

const app = express();
app.use(express.json());
app.use('/api', router);

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
</tool_result>

Assistant: "æˆ‘å·²ç»è¯»å–äº† src/index.ts æ–‡ä»¶ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ExpressæœåŠ¡å™¨é…ç½®æ–‡ä»¶:

**ä»£ç ç»“æ„åˆ†æ**:

1. **å¯¼å…¥æ¨¡å—** (ç¬¬1-2è¡Œ):
   - å¯¼å…¥Expressæ¡†æ¶
   - å¯¼å…¥æœ¬åœ°è·¯ç”±æ¨¡å—

2. **åº”ç”¨é…ç½®** (ç¬¬4-6è¡Œ):
   - åˆ›å»ºExpressåº”ç”¨å®ä¾‹
   - æ·»åŠ JSONä¸­é—´ä»¶
   - å°†è·¯ç”±æŒ‚è½½åˆ°/apiè·¯å¾„

3. **æœåŠ¡å™¨å¯åŠ¨** (ç¬¬8-10è¡Œ):
   - ç›‘å¬3000ç«¯å£
   - è¾“å‡ºå¯åŠ¨æ—¥å¿—

**å»ºè®®**:
- å¯ä»¥è€ƒè™‘å°†ç«¯å£å·æå–ä¸ºç¯å¢ƒå˜é‡
- æ·»åŠ é”™è¯¯å¤„ç†ä¸­é—´ä»¶
- è€ƒè™‘æ·»åŠ CORSé…ç½®"
```

**ç¤ºä¾‹2ï¼šæ‰¹é‡å·¥å…·è°ƒç”¨**:
```markdown
## Example: æ‰¹é‡æ–‡ä»¶æ“ä½œ

User: "å¸®æˆ‘æŠŠtestsç›®å½•ä¸‹æ‰€æœ‰.spec.tsæ–‡ä»¶æ”¹æˆ.test.ts"

Assistant: "å¥½çš„,æˆ‘éœ€è¦å…ˆæ‰¾åˆ°æ‰€æœ‰.spec.tsæ–‡ä»¶,ç„¶åé€ä¸ªé‡å‘½åã€‚"

<tool_call>
{
  "name": "Glob",
  "parameters": {
    "pattern": "tests/**/*.spec.ts"
  }
}
</tool_call>

<tool_result>
tests/unit/user.spec.ts
tests/unit/auth.spec.ts
tests/integration/api.spec.ts
</tool_result>

Assistant: "æ‰¾åˆ°äº†3ä¸ª.spec.tsæ–‡ä»¶ã€‚ç°åœ¨æˆ‘å°†é€ä¸ªé‡å‘½å:"

<tool_call>
{
  "name": "Bash",
  "parameters": {
    "command": "mv tests/unit/user.spec.ts tests/unit/user.test.ts && mv tests/unit/auth.spec.ts tests/unit/auth.test.ts && mv tests/integration/api.spec.ts tests/integration/api.test.ts"
  }
}
</tool_call>

<tool_result>
[å‘½ä»¤æ‰§è¡ŒæˆåŠŸ]
</tool_result>

Assistant: "âœ… å·²å®Œæˆé‡å‘½å:
- tests/unit/user.spec.ts â†’ user.test.ts
- tests/unit/auth.spec.ts â†’ auth.test.ts  
- tests/integration/api.spec.ts â†’ api.test.ts

æ‰€æœ‰æµ‹è¯•æ–‡ä»¶å·²æ›´æ–°ä¸º.test.tsæ‰©å±•åã€‚"
```



## å››ã€æ¶ˆæ¯é˜Ÿåˆ—å’Œäº‹ä»¶é©±åŠ¨æ¶æ„

### 4.1 æ¶ˆæ¯æµè½¬æµç¨‹

Claude Code ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„å¤„ç†ç”¨æˆ·è¾“å…¥å’ŒAIå“åº”ã€‚

```mermaid
sequenceDiagram
    participant User
    participant CLI
    participant MsgQueue as æ¶ˆæ¯é˜Ÿåˆ—
    participant Engine as AI Engine  
    participant API as Anthropic API
    participant EventBus as äº‹ä»¶æ€»çº¿

    User->>CLI: è¾“å…¥æ¶ˆæ¯
    CLI->>MsgQueue: å…¥é˜Ÿç”¨æˆ·æ¶ˆæ¯
    MsgQueue->>Engine: åˆ†å‘æ¶ˆæ¯
    
    Engine->>EventBus: å‘å¸ƒ message_received äº‹ä»¶
    Engine->>API: å‘é€APIè¯·æ±‚
    
    loop æµå¼å“åº”
        API-->>Engine: SSEæ•°æ®æµ
        Engine->>EventBus: å‘å¸ƒ chunk_received äº‹ä»¶
        EventBus-->>CLI: å®æ—¶æ˜¾ç¤º
    end
    
    API-->>Engine: å“åº”å®Œæˆ
    Engine->>EventBus: å‘å¸ƒ message_completed äº‹ä»¶
    EventBus-->>CLI: æ˜¾ç¤ºå®Œæ•´å“åº”
    CLI-->>User: è¾“å‡ºç»“æœ
```

### 4.2 æ¶ˆæ¯é˜Ÿåˆ—å®ç°

```typescript
import { EventEmitter } from 'events';

/**
 * æ¶ˆæ¯ç±»å‹å®šä¹‰
 */
interface Message {
  id: string;                  // æ¶ˆæ¯å”¯ä¸€ID
  role: 'user' | 'assistant'; // è§’è‰²
  content: string | Content[]; // å†…å®¹
  timestamp: number;           // æ—¶é—´æˆ³
  metadata?: Record<string, any>; // å…ƒæ•°æ®
}

/**
 * æ¶ˆæ¯é˜Ÿåˆ—
 */
class MessageQueue extends EventEmitter {
  private queue: Message[] = [];
  private processing: boolean = false;
  private maxSize: number;

  constructor(maxSize: number = 1000) {
    super();
    this.maxSize = maxSize;
  }

  /**
   * æ·»åŠ æ¶ˆæ¯åˆ°é˜Ÿåˆ—
   */
  enqueue(message: Message): void {
    // æ£€æŸ¥é˜Ÿåˆ—å¤§å°
    if (this.queue.length >= this.maxSize) {
      this.emit('queue_full', this.queue.length);
      // ç§»é™¤æœ€æ—§çš„æ¶ˆæ¯
      this.queue.shift();
    }

    // æ·»åŠ æ¶ˆæ¯
    this.queue.push(message);
    this.emit('message_enqueued', message);

    // è§¦å‘å¤„ç†
    this.processNext();
  }

  /**
   * å¤„ç†ä¸‹ä¸€æ¡æ¶ˆæ¯
   */
  private async processNext(): Promise<void> {
    // å¦‚æœæ­£åœ¨å¤„ç†æˆ–é˜Ÿåˆ—ä¸ºç©º,ç›´æ¥è¿”å›
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    const message = this.queue[0]; // æŸ¥çœ‹ä½†ä¸ç§»é™¤

    try {
      // å‘å¸ƒæ¶ˆæ¯å¤„ç†äº‹ä»¶
      this.emit('message_processing', message);

      // ç­‰å¾…å¤„ç†å®Œæˆ
      await this.processMessage(message);

      // å¤„ç†æˆåŠŸ,ç§»é™¤æ¶ˆæ¯
      this.queue.shift();
      this.emit('message_processed', message);
    } catch (error) {
      this.emit('message_error', { message, error });
      // é”™è¯¯å¤„ç†ç­–ç•¥
      this.handleError(message, error);
    } finally {
      this.processing = false;
      // ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡
      setImmediate(() => this.processNext());
    }
  }

  /**
   * å¤„ç†å•æ¡æ¶ˆæ¯
   */
  private async processMessage(message: Message): Promise<void> {
    return new Promise((resolve, reject) => {
      // ç”±å¤–éƒ¨å¤„ç†å™¨å¤„ç†
      this.emit('message_ready', message, (error?: Error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  private handleError(message: Message, error: Error): void {
    console.error(`æ¶ˆæ¯å¤„ç†å¤±è´¥ [${message.id}]:`, error);
    
    // å¯ä»¥å®ç°é‡è¯•é€»è¾‘
    const retryCount = message.metadata?.retryCount || 0;
    if (retryCount < 3) {
      // é‡æ–°å…¥é˜Ÿ
      message.metadata = {
        ...message.metadata,
        retryCount: retryCount + 1
      };
      this.queue.shift(); // ç§»é™¤å½“å‰
      this.queue.unshift(message); // é‡æ–°æ·»åŠ åˆ°é˜Ÿé¦–
    } else {
      // è¶…è¿‡é‡è¯•æ¬¡æ•°,ç§»é™¤æ¶ˆæ¯
      this.queue.shift();
      this.emit('message_failed', { message, error });
    }
  }

  /**
   * è·å–é˜Ÿåˆ—çŠ¶æ€
   */
  getStatus(): { size: number; processing: boolean } {
    return {
      size: this.queue.length,
      processing: this.processing
    };
  }

  /**
   * æ¸…ç©ºé˜Ÿåˆ—
   */
  clear(): void {
    this.queue = [];
    this.emit('queue_cleared');
  }
}

export { MessageQueue, Message };
```

### 4.3 äº‹ä»¶æ€»çº¿å®ç°

```typescript
/**
 * äº‹ä»¶æ€»çº¿ - ç”¨äºè§£è€¦ç»„ä»¶é€šä¿¡
 */
class EventBus {
  private static instance: EventBus;
  private emitter: EventEmitter;
  private listeners: Map<string, number>;

  private constructor() {
    this.emitter = new EventEmitter();
    this.listeners = new Map();
    // å¢åŠ æœ€å¤§ç›‘å¬å™¨æ•°é‡
    this.emitter.setMaxListeners(100);
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): EventBus {
    if (\!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }

  /**
   * è®¢é˜…äº‹ä»¶
   */
  on(event: string, handler: (...args: any[]) => void): void {
    this.emitter.on(event, handler);
    
    // è®°å½•ç›‘å¬å™¨æ•°é‡
    const count = this.listeners.get(event) || 0;
    this.listeners.set(event, count + 1);
  }

  /**
   * è®¢é˜…ä¸€æ¬¡æ€§äº‹ä»¶
   */
  once(event: string, handler: (...args: any[]) => void): void {
    this.emitter.once(event, handler);
  }

  /**
   * å‘å¸ƒäº‹ä»¶
   */
  emit(event: string, ...args: any[]): boolean {
    return this.emitter.emit(event, ...args);
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  off(event: string, handler: (...args: any[]) => void): void {
    this.emitter.off(event, handler);
    
    // æ›´æ–°ç›‘å¬å™¨æ•°é‡
    const count = this.listeners.get(event) || 0;
    if (count > 0) {
      this.listeners.set(event, count - 1);
    }
  }

  /**
   * ç§»é™¤æ‰€æœ‰ç›‘å¬å™¨
   */
  removeAllListeners(event?: string): void {
    if (event) {
      this.emitter.removeAllListeners(event);
      this.listeners.delete(event);
    } else {
      this.emitter.removeAllListeners();
      this.listeners.clear();
    }
  }

  /**
   * è·å–äº‹ä»¶ç»Ÿè®¡
   */
  getStats(): Record<string, number> {
    const stats: Record<string, number> = {};
    this.listeners.forEach((count, event) => {
      stats[event] = count;
    });
    return stats;
  }
}

// å¯¼å‡ºå•ä¾‹
export default EventBus.getInstance();
```

### 4.4 äº‹ä»¶ç±»å‹å®šä¹‰

```typescript
/**
 * ç³»ç»Ÿäº‹ä»¶ç±»å‹
 */
enum SystemEvent {
  // å¼•æ“ç”Ÿå‘½å‘¨æœŸ
  ENGINE_INITIALIZED = 'engine:initialized',
  ENGINE_SHUTDOWN = 'engine:shutdown',
  
  // æ¶ˆæ¯äº‹ä»¶
  MESSAGE_RECEIVED = 'message:received',
  MESSAGE_PROCESSING = 'message:processing',
  MESSAGE_COMPLETED = 'message:completed',
  MESSAGE_ERROR = 'message:error',
  
  // æµå¼å“åº”äº‹ä»¶
  STREAM_START = 'stream:start',
  STREAM_CHUNK = 'stream:chunk',
  STREAM_END = 'stream:end',
  STREAM_ERROR = 'stream:error',
  
  // å·¥å…·è°ƒç”¨äº‹ä»¶
  TOOL_CALL_START = 'tool:call:start',
  TOOL_CALL_COMPLETE = 'tool:call:complete',
  TOOL_CALL_ERROR = 'tool:call:error',
  
  // ä¸Šä¸‹æ–‡äº‹ä»¶
  CONTEXT_UPDATED = 'context:updated',
  CONTEXT_CLEARED = 'context:cleared',
}

export { SystemEvent };
```



## äº”ã€æµå¼å“åº”å¤„ç†

### 5.1 SSE (Server-Sent Events) åŸç†

Anthropic API ä½¿ç”¨ SSE åè®®å®ç°æµå¼å“åº”,è¿™è®© Claude Code èƒ½å¤Ÿå®æ—¶æ˜¾ç¤ºAIçš„æ€è€ƒè¿‡ç¨‹ã€‚

```mermaid
sequenceDiagram
    participant Client as AI Engine
    participant API as Anthropic API
    participant Parser as Stream Parser
    participant UI as CLIç•Œé¢

    Client->>API: å‘é€æµå¼è¯·æ±‚ (stream: true)
    activate API

    loop æµå¼ä¼ è¾“
        API-->>Client: data: {event_type: "message_start"}
        Client->>Parser: è§£æäº‹ä»¶
        Parser->>UI: æ˜¾ç¤ºå¼€å§‹æ ‡è®°

        API-->>Client: data: {event_type: "content_block_delta"}
        Client->>Parser: è§£æå¢é‡å†…å®¹
        Parser->>UI: å®æ—¶æ¸²æŸ“æ–‡æœ¬

        API-->>Client: data: {event_type: "tool_use"}
        Client->>Parser: è§£æå·¥å…·è°ƒç”¨
        Parser->>UI: æ˜¾ç¤ºå·¥å…·æ‰§è¡Œ
    end

    API-->>Client: data: {event_type: "message_stop"}
    deactivate API
    Client->>Parser: è§£æç»“æŸäº‹ä»¶
    Parser->>UI: æ˜¾ç¤ºå®Œæˆæ ‡è®°
```

### 5.2 æµå¼å¤„ç†å™¨å®ç°

```typescript
import { Anthropic } from '@anthropic-ai/sdk';

/**
 * SSEäº‹ä»¶ç±»å‹
 */
enum SSEEventType {
  MESSAGE_START = 'message_start',
  CONTENT_BLOCK_START = 'content_block_start',
  CONTENT_BLOCK_DELTA = 'content_block_delta',
  CONTENT_BLOCK_STOP = 'content_block_stop',
  MESSAGE_DELTA = 'message_delta',
  MESSAGE_STOP = 'message_stop',
  PING = 'ping',
  ERROR = 'error'
}

/**
 * æµå¼å“åº”å¤„ç†å™¨
 */
class StreamProcessor {
  private buffer: string = '';
  private currentBlock: any = null;
  private messageId: string = '';

  /**
   * å¤„ç†æµå¼å“åº”
   */
  async processStream(
    stream: AsyncIterable<Anthropic.MessageStreamEvent>,
    onChunk: (chunk: ProcessedChunk) => void,
    onComplete: (message: any) => void,
    onError: (error: Error) => void
  ): Promise<void> {
    try {
      for await (const event of stream) {
        const processed = this.processEvent(event);

        if (processed) {
          onChunk(processed);
        }

        // æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if (event.type === 'message_stop') {
          onComplete(this.buildCompleteMessage());
        }
      }
    } catch (error) {
      onError(error as Error);
    }
  }

  /**
   * å¤„ç†å•ä¸ªSSEäº‹ä»¶
   */
  private processEvent(event: Anthropic.MessageStreamEvent): ProcessedChunk | null {
    switch (event.type) {
      case 'message_start':
        return this.handleMessageStart(event);

      case 'content_block_start':
        return this.handleContentBlockStart(event);

      case 'content_block_delta':
        return this.handleContentBlockDelta(event);

      case 'content_block_stop':
        return this.handleContentBlockStop(event);

      case 'message_delta':
        return this.handleMessageDelta(event);

      default:
        return null;
    }
  }

  /**
   * å¤„ç†æ¶ˆæ¯å¼€å§‹
   */
  private handleMessageStart(event: any): ProcessedChunk {
    this.messageId = event.message.id;

    return {
      type: 'message_start',
      messageId: this.messageId,
      model: event.message.model,
      role: event.message.role
    };
  }

  /**
   * å¤„ç†å†…å®¹å—å¼€å§‹
   */
  private handleContentBlockStart(event: any): ProcessedChunk {
    const block = event.content_block;
    this.currentBlock = block;

    if (block.type === 'text') {
      return {
        type: 'text_start',
        index: event.index
      };
    } else if (block.type === 'tool_use') {
      return {
        type: 'tool_start',
        toolName: block.name,
        toolId: block.id,
        index: event.index
      };
    }

    return null;
  }

  /**
   * å¤„ç†å†…å®¹å—å¢é‡
   */
  private handleContentBlockDelta(event: any): ProcessedChunk {
    const delta = event.delta;

    if (delta.type === 'text_delta') {
      // æ–‡æœ¬å¢é‡
      this.buffer += delta.text;

      return {
        type: 'text_delta',
        text: delta.text,
        index: event.index
      };
    } else if (delta.type === 'input_json_delta') {
      // å·¥å…·è¾“å…¥JSONå¢é‡
      return {
        type: 'tool_input_delta',
        partialJson: delta.partial_json,
        index: event.index
      };
    }

    return null;
  }

  /**
   * å¤„ç†å†…å®¹å—åœæ­¢
   */
  private handleContentBlockStop(event: any): ProcessedChunk {
    const result: ProcessedChunk = {
      type: 'block_stop',
      index: event.index
    };

    // å¦‚æœæ˜¯æ–‡æœ¬å—,é™„åŠ å®Œæ•´æ–‡æœ¬
    if (this.currentBlock?.type === 'text') {
      result.completeText = this.buffer;
      this.buffer = '';
    }

    this.currentBlock = null;
    return result;
  }

  /**
   * å¤„ç†æ¶ˆæ¯å¢é‡ï¼ˆusageç­‰ï¼‰
   */
  private handleMessageDelta(event: any): ProcessedChunk | null {
    if (event.delta.stop_reason) {
      return {
        type: 'stop_reason',
        reason: event.delta.stop_reason,
        usage: event.usage
      };
    }
    return null;
  }

  /**
   * æ„å»ºå®Œæ•´æ¶ˆæ¯
   */
  private buildCompleteMessage(): any {
    return {
      id: this.messageId,
      // ... å…¶ä»–æ¶ˆæ¯å­—æ®µ
    };
  }
}

/**
 * å¤„ç†åçš„æ•°æ®å—
 */
interface ProcessedChunk {
  type: string;
  [key: string]: any;
}

export { StreamProcessor, SSEEventType, ProcessedChunk };
```

### 5.3 å¢é‡è§£æå™¨

```typescript
/**
 * JSONå¢é‡è§£æå™¨ - ç”¨äºè§£æå·¥å…·è°ƒç”¨çš„JSONå‚æ•°
 */
class IncrementalJSONParser {
  private buffer: string = '';
  private depth: number = 0;
  private inString: boolean = false;
  private escapeNext: boolean = false;

  /**
   * æ·»åŠ æ–°çš„JSONç‰‡æ®µ
   */
  append(chunk: string): void {
    this.buffer += chunk;
  }

  /**
   * å°è¯•è§£æå½“å‰ç¼“å†²åŒº
   * @returns å¦‚æœèƒ½è§£æä¸ºå®Œæ•´JSONåˆ™è¿”å›å¯¹è±¡,å¦åˆ™è¿”å›null
   */
  tryParse(): any | null {
    try {
      return JSON.parse(this.buffer);
    } catch {
      return null;
    }
  }

  /**
   * æ£€æŸ¥å½“å‰æ˜¯å¦å¯èƒ½æ˜¯å®Œæ•´JSON
   */
  isComplete(): boolean {
    // ç®€å•çš„å®Œæ•´æ€§æ£€æŸ¥
    if (!this.buffer.trim()) {
      return false;
    }

    let depth = 0;
    let inString = false;
    let escape = false;

    for (const char of this.buffer) {
      if (escape) {
        escape = false;
        continue;
      }

      if (char === '\\') {
        escape = true;
        continue;
      }

      if (char === '"') {
        inString = !inString;
        continue;
      }

      if (inString) {
        continue;
      }

      if (char === '{' || char === '[') {
        depth++;
      } else if (char === '}' || char === ']') {
        depth--;
      }
    }

    return depth === 0 && !inString;
  }

  /**
   * è·å–éƒ¨åˆ†è§£æçš„ç»“æœï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
   */
  getPartialResult(): Record<string, any> {
    // å°è¯•è§£æå·²å®Œæ•´çš„é”®å€¼å¯¹
    const result: Record<string, any> = {};

    // ä½¿ç”¨æ­£åˆ™æå–å®Œæ•´çš„é”®å€¼å¯¹
    const regex = /"(\w+)"\s*:\s*("(?:[^"\\]|\\.)*"|[^,}\]]+)/g;
    let match;

    while ((match = regex.exec(this.buffer)) !== null) {
      const key = match[1];
      let value = match[2].trim();

      // è§£æå€¼
      try {
        if (value.startsWith('"') && value.endsWith('"')) {
          value = JSON.parse(value);
        } else if (value === 'true') {
          value = true;
        } else if (value === 'false') {
          value = false;
        } else if (value === 'null') {
          value = null;
        } else if (!isNaN(Number(value))) {
          value = Number(value);
        }

        result[key] = value;
      } catch {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }

    return result;
  }

  /**
   * é‡ç½®è§£æå™¨
   */
  reset(): void {
    this.buffer = '';
    this.depth = 0;
    this.inString = false;
    this.escapeNext = false;
  }
}

export { IncrementalJSONParser };
```

### 5.4 æµå¼æ¸²æŸ“ç¤ºä¾‹

```typescript
import EventBus from './event-bus';
import { SystemEvent } from './events';
import { StreamProcessor } from './stream-processor';

/**
 * æµå¼å“åº”ç®¡ç†å™¨
 */
class StreamingResponseManager {
  private streamProcessor: StreamProcessor;
  private currentToolCall: { name: string; input: string } | null = null;

  constructor() {
    this.streamProcessor = new StreamProcessor();
    this.setupEventHandlers();
  }

  /**
   * å¼€å§‹å¤„ç†æµå¼å“åº”
   */
  async handleStreamingResponse(
    stream: AsyncIterable<any>
  ): Promise<void> {
    await this.streamProcessor.processStream(
      stream,
      (chunk) => this.onChunk(chunk),
      (message) => this.onComplete(message),
      (error) => this.onError(error)
    );
  }

  /**
   * å¤„ç†æ•°æ®å—
   */
  private onChunk(chunk: any): void {
    switch (chunk.type) {
      case 'message_start':
        console.log(`\n[AIå¼€å§‹å“åº” - ${chunk.model}]`);
        EventBus.emit(SystemEvent.STREAM_START, chunk);
        break;

      case 'text_delta':
        // å®æ—¶è¾“å‡ºæ–‡æœ¬
        process.stdout.write(chunk.text);
        EventBus.emit(SystemEvent.STREAM_CHUNK, chunk);
        break;

      case 'tool_start':
        console.log(`\nğŸ”§ è°ƒç”¨å·¥å…·: ${chunk.toolName}`);
        this.currentToolCall = {
          name: chunk.toolName,
          input: ''
        };
        break;

      case 'tool_input_delta':
        // ç´¯ç§¯å·¥å…·è¾“å…¥
        if (this.currentToolCall) {
          this.currentToolCall.input += chunk.partialJson;
        }
        break;

      case 'block_stop':
        if (this.currentToolCall) {
          try {
            const input = JSON.parse(this.currentToolCall.input);
            console.log('  å‚æ•°:', JSON.stringify(input, null, 2));

            EventBus.emit(SystemEvent.TOOL_CALL_START, {
              name: this.currentToolCall.name,
              input
            });
          } catch {
            console.log('  å‚æ•°è§£æä¸­...');
          }
          this.currentToolCall = null;
        }
        break;

      case 'stop_reason':
        console.log(`\n[åœæ­¢åŸå› : ${chunk.reason}]`);
        if (chunk.usage) {
          console.log(`[Tokenä½¿ç”¨: è¾“å…¥=${chunk.usage.input_tokens}, è¾“å‡º=${chunk.usage.output_tokens}]`);
        }
        break;
    }
  }

  /**
   * å“åº”å®Œæˆ
   */
  private onComplete(message: any): void {
    console.log('\n[AIå“åº”å®Œæˆ]\n');
    EventBus.emit(SystemEvent.STREAM_END, message);
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  private onError(error: Error): void {
    console.error('\nâŒ æµå¼å“åº”é”™è¯¯:', error.message);
    EventBus.emit(SystemEvent.STREAM_ERROR, error);
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†å™¨
   */
  private setupEventHandlers(): void {
    EventBus.on(SystemEvent.TOOL_CALL_COMPLETE, (result) => {
      console.log('âœ… å·¥å…·æ‰§è¡Œå®Œæˆ');
    });

    EventBus.on(SystemEvent.TOOL_CALL_ERROR, (error) => {
      console.error('âŒ å·¥å…·æ‰§è¡Œå¤±è´¥:', error.message);
    });
  }
}

export { StreamingResponseManager };
```



## å…­ã€å·¥å…·è°ƒç”¨å¾ªç¯

### 6.1 å·¥å…·è°ƒç”¨æµç¨‹

```mermaid
flowchart TD
    Start[å¼€å§‹] --> SendMessage[å‘é€ç”¨æˆ·æ¶ˆæ¯]
    SendMessage --> WaitResponse[ç­‰å¾…AIå“åº”]

    WaitResponse --> CheckStopReason{æ£€æŸ¥åœæ­¢åŸå› }

    CheckStopReason -->|end_turn| End[ç»“æŸå¯¹è¯]
    CheckStopReason -->|max_tokens| HandleMaxTokens[å¤„ç†tokené™åˆ¶]
    CheckStopReason -->|tool_use| ExtractTools[æå–å·¥å…·è°ƒç”¨]

    ExtractTools --> HasTools{æœ‰å·¥å…·è°ƒç”¨?}
    HasTools -->|å¦| End
    HasTools -->|æ˜¯| ExecuteTools[å¹¶å‘æ‰§è¡Œå·¥å…·]

    ExecuteTools --> CollectResults[æ”¶é›†æ‰§è¡Œç»“æœ]
    CollectResults --> FormatResults[æ ¼å¼åŒ–ä¸ºå·¥å…·ç»“æœæ¶ˆæ¯]
    FormatResults --> CheckDepth{æ£€æŸ¥è°ƒç”¨æ·±åº¦}

    CheckDepth -->|è¶…è¿‡é™åˆ¶| WarnDepth[è­¦å‘Š: è¾¾åˆ°æœ€å¤§æ·±åº¦]
    WarnDepth --> End
    CheckDepth -->|æœªè¶…è¿‡| IncDepth[æ·±åº¦+1]

    IncDepth --> SendMessage

    HandleMaxTokens --> TruncateContext[æˆªæ–­ä¸Šä¸‹æ–‡]
    TruncateContext --> SendMessage

    style Start fill:#e1f5e1
    style End fill:#ffe1e1
    style ExecuteTools fill:#fff4e1
    style CheckDepth fill:#e1f0ff
```

### 6.2 å·¥å…·è°ƒç”¨å¾ªç¯å®ç°

```typescript
/**
 * å·¥å…·è°ƒç”¨å¾ªç¯ç®¡ç†å™¨
 */
class ToolCallLoop {
  private client: Anthropic;
  private toolRegistry: ToolRegistry;
  private maxDepth: number;
  private currentDepth: number = 0;

  constructor(
    client: Anthropic,
    toolRegistry: ToolRegistry,
    maxDepth: number = 5
  ) {
    this.client = client;
    this.toolRegistry = toolRegistry;
    this.maxDepth = maxDepth;
  }

  /**
   * æ‰§è¡Œå¯¹è¯å¾ªç¯ï¼ˆå¸¦å·¥å…·è°ƒç”¨ï¼‰
   */
  async executeConversation(
    messages: Anthropic.MessageParam[],
    systemPrompt: string
  ): Promise<Anthropic.Message> {
    let currentMessages = [...messages];
    this.currentDepth = 0;

    while (this.currentDepth < this.maxDepth) {
      console.log(`\n=== å¾ªç¯è½®æ¬¡ ${this.currentDepth + 1} ===`);

      // 1. è°ƒç”¨API
      const response = await this.client.messages.create({
        model: 'claude-3-5-sonnet-20250929',
        max_tokens: 8000,
        system: systemPrompt,
        messages: currentMessages,
        tools: this.toolRegistry.getToolDefinitions(),
        stream: true
      });

      // 2. å¤„ç†æµå¼å“åº”
      const message = await this.processStreamResponse(response);

      // 3. æ·»åŠ AIå“åº”åˆ°æ¶ˆæ¯å†å²
      currentMessages.push({
        role: 'assistant',
        content: message.content
      });

      // 4. æ£€æŸ¥åœæ­¢åŸå› 
      if (message.stop_reason === 'end_turn') {
        console.log('âœ… å¯¹è¯æ­£å¸¸ç»“æŸ');
        return message;
      }

      if (message.stop_reason === 'max_tokens') {
        console.log('âš ï¸  è¾¾åˆ°tokené™åˆ¶,å°è¯•æˆªæ–­ä¸Šä¸‹æ–‡');
        currentMessages = this.truncateContext(currentMessages);
        continue;
      }

      if (message.stop_reason === 'tool_use') {
        console.log('ğŸ”§ æ£€æµ‹åˆ°å·¥å…·è°ƒç”¨');

        // 5. æå–å¹¶æ‰§è¡Œå·¥å…·
        const toolCalls = this.extractToolCalls(message.content);
        if (toolCalls.length === 0) {
          console.log('âš ï¸  æœªæ‰¾åˆ°å·¥å…·è°ƒç”¨,ç»“æŸå¾ªç¯');
          return message;
        }

        // 6. å¹¶å‘æ‰§è¡Œå·¥å…·
        const toolResults = await this.executeTools(toolCalls);

        // 7. æ·»åŠ å·¥å…·ç»“æœåˆ°æ¶ˆæ¯å†å²
        currentMessages.push({
          role: 'user',
          content: toolResults
        });

        // 8. å¢åŠ æ·±åº¦è®¡æ•°
        this.currentDepth++;
      } else {
        // æœªçŸ¥åœæ­¢åŸå› 
        console.log(`âš ï¸  æœªçŸ¥åœæ­¢åŸå› : ${message.stop_reason}`);
        return message;
      }
    }

    // è¾¾åˆ°æœ€å¤§æ·±åº¦
    console.warn(`âš ï¸  è¾¾åˆ°æœ€å¤§å·¥å…·è°ƒç”¨æ·±åº¦: ${this.maxDepth}`);
    throw new Error(`Maximum tool call depth (${this.maxDepth}) exceeded`);
  }

  /**
   * å¤„ç†æµå¼å“åº”
   */
  private async processStreamResponse(
    stream: AsyncIterable<Anthropic.MessageStreamEvent>
  ): Promise<Anthropic.Message> {
    const message: Partial<Anthropic.Message> = {
      id: '',
      model: '',
      role: 'assistant',
      content: [],
      stop_reason: null,
      usage: { input_tokens: 0, output_tokens: 0 }
    };

    for await (const event of stream) {
      switch (event.type) {
        case 'message_start':
          message.id = event.message.id;
          message.model = event.message.model;
          message.role = event.message.role;
          message.usage = event.message.usage;
          break;

        case 'content_block_start':
          message.content!.push(event.content_block);
          break;

        case 'content_block_delta':
          const lastBlock = message.content![message.content!.length - 1];
          if (event.delta.type === 'text_delta') {
            (lastBlock as any).text += event.delta.text;
            process.stdout.write(event.delta.text);
          } else if (event.delta.type === 'input_json_delta') {
            (lastBlock as any).input += event.delta.partial_json;
          }
          break;

        case 'message_delta':
          if (event.delta.stop_reason) {
            message.stop_reason = event.delta.stop_reason;
          }
          if (event.usage) {
            message.usage!.output_tokens = event.usage.output_tokens;
          }
          break;
      }
    }

    return message as Anthropic.Message;
  }

  /**
   * æå–å·¥å…·è°ƒç”¨
   */
  private extractToolCalls(content: any[]): ToolCall[] {
    return content
      .filter(block => block.type === 'tool_use')
      .map(block => ({
        id: block.id,
        name: block.name,
        input: block.input
      }));
  }

  /**
   * å¹¶å‘æ‰§è¡Œå¤šä¸ªå·¥å…·
   */
  private async executeTools(toolCalls: ToolCall[]): Promise<any[]> {
    console.log(`\næ‰§è¡Œ ${toolCalls.length} ä¸ªå·¥å…·è°ƒç”¨...`);

    const results = await Promise.allSettled(
      toolCalls.map(async (call) => {
        try {
          console.log(`  â€¢ ${call.name}...`);
          const result = await this.toolRegistry.executeTool(
            call.name,
            call.input
          );
          console.log(`    âœ… ${call.name} å®Œæˆ`);

          return {
            type: 'tool_result',
            tool_use_id: call.id,
            content: JSON.stringify(result)
          };
        } catch (error) {
          console.error(`    âŒ ${call.name} å¤±è´¥:`, error.message);

          return {
            type: 'tool_result',
            tool_use_id: call.id,
            content: `Error: ${error.message}`,
            is_error: true
          };
        }
      })
    );

    // æå–ç»“æœï¼ˆåŒ…æ‹¬æˆåŠŸå’Œå¤±è´¥çš„ï¼‰
    return results.map(r =>
      r.status === 'fulfilled' ? r.value : r.reason
    );
  }

  /**
   * æˆªæ–­ä¸Šä¸‹æ–‡ï¼ˆå½“è¾¾åˆ°tokené™åˆ¶æ—¶ï¼‰
   */
  private truncateContext(messages: Anthropic.MessageParam[]): Anthropic.MessageParam[] {
    // ä¿ç•™æœ€è¿‘çš„Næ¡æ¶ˆæ¯
    const keepCount = Math.floor(messages.length * 0.7);
    return messages.slice(-keepCount);
  }
}

interface ToolCall {
  id: string;
  name: string;
  input: Record<string, any>;
}

export { ToolCallLoop, ToolCall };
```

### 6.3 å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

```typescript
/**
 * å®Œæ•´ç¤ºä¾‹ï¼šå¤„ç†ç”¨æˆ·è¯·æ±‚å¹¶è‡ªåŠ¨è°ƒç”¨å·¥å…·
 */
async function handleUserRequest(userMessage: string): Promise<void> {
  // 1. åˆå§‹åŒ–
  const engine = new AIEngine({
    apiKey: process.env.ANTHROPIC_API_KEY!
  });
  await engine.initialize();

  // 2. åˆ›å»ºå·¥å…·è°ƒç”¨å¾ªç¯
  const toolLoop = new ToolCallLoop(
    engine.client,
    engine.toolRegistry,
    5 // æœ€å¤§æ·±åº¦
  );

  // 3. å‡†å¤‡æ¶ˆæ¯
  const messages: Anthropic.MessageParam[] = [
    {
      role: 'user',
      content: userMessage
    }
  ];

  try {
    // 4. æ‰§è¡Œå¯¹è¯å¾ªç¯
    const finalResponse = await toolLoop.executeConversation(
      messages,
      engine.systemPrompt
    );

    // 5. æå–æœ€ç»ˆæ–‡æœ¬å“åº”
    const textContent = finalResponse.content
      .filter(block => block.type === 'text')
      .map(block => (block as any).text)
      .join('\n');

    console.log('\n\n=== æœ€ç»ˆå“åº” ===');
    console.log(textContent);

    // 6. æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    console.log('\n=== ç»Ÿè®¡ä¿¡æ¯ ===');
    console.log(`Tokenä½¿ç”¨: è¾“å…¥=${finalResponse.usage.input_tokens}, è¾“å‡º=${finalResponse.usage.output_tokens}`);
    console.log(`å·¥å…·è°ƒç”¨æ·±åº¦: ${toolLoop.currentDepth}`);
  } catch (error) {
    console.error('âŒ å¤„ç†å¤±è´¥:', error.message);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
handleUserRequest('å¸®æˆ‘åˆ†æé¡¹ç›®ä¸­æ‰€æœ‰TypeScriptæ–‡ä»¶çš„å¯¼å…¥ä¾èµ–å…³ç³»');
```



## ä¸ƒã€é”™è¯¯æ¢å¤æœºåˆ¶

### 7.1 é”™è¯¯ç±»å‹å’Œå¤„ç†ç­–ç•¥

```typescript
/**
 * é”™è¯¯ç±»å‹æšä¸¾
 */
enum ErrorType {
  // APIé”™è¯¯
  API_ERROR = 'api_error',
  AUTH_ERROR = 'auth_error',
  RATE_LIMIT = 'rate_limit',
  NETWORK_ERROR = 'network_error',
  TIMEOUT = 'timeout',

  // å·¥å…·é”™è¯¯
  TOOL_NOT_FOUND = 'tool_not_found',
  TOOL_EXECUTION_ERROR = 'tool_execution_error',
  TOOL_TIMEOUT = 'tool_timeout',

  // ä¸Šä¸‹æ–‡é”™è¯¯
  CONTEXT_TOO_LARGE = 'context_too_large',
  INVALID_MESSAGE = 'invalid_message',

  // ç³»ç»Ÿé”™è¯¯
  INTERNAL_ERROR = 'internal_error',
  OUT_OF_MEMORY = 'out_of_memory'
}

/**
 * é”™è¯¯æ¢å¤ç­–ç•¥
 */
interface RecoveryStrategy {
  maxRetries: number;      // æœ€å¤§é‡è¯•æ¬¡æ•°
  retryDelay: number;      // é‡è¯•å»¶è¿Ÿ(ms)
  backoffMultiplier: number; // é€€é¿ä¹˜æ•°
  fallback?: () => Promise<any>; // å›é€€æ–¹æ¡ˆ
}

/**
 * é”™è¯¯å¤„ç†å™¨
 */
class ErrorHandler {
  private retryCount: Map<string, number> = new Map();
  private strategies: Map<ErrorType, RecoveryStrategy> = new Map();

  constructor() {
    this.initializeStrategies();
  }

  /**
   * åˆå§‹åŒ–é”™è¯¯æ¢å¤ç­–ç•¥
   */
  private initializeStrategies(): void {
    // APIé”™è¯¯ - é‡è¯•3æ¬¡
    this.strategies.set(ErrorType.API_ERROR, {
      maxRetries: 3,
      retryDelay: 1000,
      backoffMultiplier: 2
    });

    // é€Ÿç‡é™åˆ¶ - é‡è¯•5æ¬¡,é•¿å»¶è¿Ÿ
    this.strategies.set(ErrorType.RATE_LIMIT, {
      maxRetries: 5,
      retryDelay: 5000,
      backoffMultiplier: 2
    });

    // ç½‘ç»œé”™è¯¯ - é‡è¯•5æ¬¡
    this.strategies.set(ErrorType.NETWORK_ERROR, {
      maxRetries: 5,
      retryDelay: 2000,
      backoffMultiplier: 1.5
    });

    // è¶…æ—¶ - é‡è¯•2æ¬¡
    this.strategies.set(ErrorType.TIMEOUT, {
      maxRetries: 2,
      retryDelay: 3000,
      backoffMultiplier: 1
    });

    // å·¥å…·æ‰§è¡Œé”™è¯¯ - ä¸é‡è¯•,ä½¿ç”¨å›é€€
    this.strategies.set(ErrorType.TOOL_EXECUTION_ERROR, {
      maxRetries: 0,
      retryDelay: 0,
      backoffMultiplier: 1,
      fallback: async () => {
        return { error: 'å·¥å…·æ‰§è¡Œå¤±è´¥', success: false };
      }
    });

    // ä¸Šä¸‹æ–‡è¿‡å¤§ - ä¸é‡è¯•,ç«‹å³æˆªæ–­
    this.strategies.set(ErrorType.CONTEXT_TOO_LARGE, {
      maxRetries: 0,
      retryDelay: 0,
      backoffMultiplier: 1
    });
  }

  /**
   * å¤„ç†é”™è¯¯å¹¶å°è¯•æ¢å¤
   */
  async handleError<T>(
    operation: () => Promise<T>,
    errorType: ErrorType,
    operationId: string
  ): Promise<T> {
    const strategy = this.strategies.get(errorType);
    if (!strategy) {
      throw new Error(`No recovery strategy for error type: ${errorType}`);
    }

    let lastError: Error;
    const retryKey = `${errorType}:${operationId}`;
    const currentRetries = this.retryCount.get(retryKey) || 0;

    for (let attempt = 0; attempt <= strategy.maxRetries; attempt++) {
      try {
        const result = await operation();
        // æˆåŠŸ,é‡ç½®é‡è¯•è®¡æ•°
        this.retryCount.delete(retryKey);
        return result;
      } catch (error) {
        lastError = error as Error;

        console.warn(
          `æ“ä½œå¤±è´¥ (å°è¯• ${attempt + 1}/${strategy.maxRetries + 1}):`,
          error.message
        );

        // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½é‡è¯•
        if (attempt < strategy.maxRetries) {
          // è®¡ç®—å»¶è¿Ÿï¼ˆæŒ‡æ•°é€€é¿ï¼‰
          const delay = strategy.retryDelay * Math.pow(
            strategy.backoffMultiplier,
            attempt
          );

          console.log(`ç­‰å¾… ${delay}ms åé‡è¯•...`);
          await this.sleep(delay);

          // æ›´æ–°é‡è¯•è®¡æ•°
          this.retryCount.set(retryKey, currentRetries + 1);
        }
      }
    }

    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    console.error(`æ“ä½œæœ€ç»ˆå¤±è´¥: ${lastError!.message}`);

    // å°è¯•å›é€€æ–¹æ¡ˆ
    if (strategy.fallback) {
      console.log('å°è¯•å›é€€æ–¹æ¡ˆ...');
      try {
        return await strategy.fallback();
      } catch (fallbackError) {
        console.error('å›é€€æ–¹æ¡ˆä¹Ÿå¤±è´¥äº†:', fallbackError);
      }
    }

    // æŠ›å‡ºåŸå§‹é”™è¯¯
    throw lastError!;
  }

  /**
   * è¾…åŠ©:ç¡çœ å‡½æ•°
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * åˆ†ç±»é”™è¯¯ç±»å‹
   */
  classifyError(error: any): ErrorType {
    const message = error.message?.toLowerCase() || '';
    const status = error.status || error.statusCode;

    // è®¤è¯é”™è¯¯
    if (status === 401 || message.includes('unauthorized')) {
      return ErrorType.AUTH_ERROR;
    }

    // é€Ÿç‡é™åˆ¶
    if (status === 429 || message.includes('rate limit')) {
      return ErrorType.RATE_LIMIT;
    }

    // è¶…æ—¶
    if (message.includes('timeout') || message.includes('timed out')) {
      return ErrorType.TIMEOUT;
    }

    // ç½‘ç»œé”™è¯¯
    if (message.includes('network') || message.includes('connect')) {
      return ErrorType.NETWORK_ERROR;
    }

    // ä¸Šä¸‹æ–‡è¿‡å¤§
    if (message.includes('context') || message.includes('too large')) {
      return ErrorType.CONTEXT_TOO_LARGE;
    }

    // é»˜è®¤ä¸ºAPIé”™è¯¯
    return ErrorType.API_ERROR;
  }

  /**
   * è·å–é‡è¯•ç»Ÿè®¡
   */
  getRetryStats(): Map<string, number> {
    return new Map(this.retryCount);
  }

  /**
   * æ¸…ç©ºé‡è¯•è®¡æ•°
   */
  clearRetryStats(): void {
    this.retryCount.clear();
  }
}

export { ErrorHandler, ErrorType, RecoveryStrategy };
```

### 7.2 å®é™…ä½¿ç”¨ç¤ºä¾‹

```typescript
/**
 * åœ¨AIå¼•æ“ä¸­é›†æˆé”™è¯¯å¤„ç†
 */
class AIEngineWithErrorHandling {
  private client: Anthropic;
  private errorHandler: ErrorHandler;

  constructor(config: AIEngineConfig) {
    this.client = new Anthropic({ apiKey: config.apiKey });
    this.errorHandler = new ErrorHandler();
  }

  /**
   * å‘é€æ¶ˆæ¯(å¸¦é”™è¯¯å¤„ç†)
   */
  async sendMessage(messages: Anthropic.MessageParam[]): Promise<Anthropic.Message> {
    return this.errorHandler.handleError(
      async () => {
        return await this.client.messages.create({
          model: 'claude-3-5-sonnet-20250929',
          max_tokens: 8000,
          messages
        });
      },
      ErrorType.API_ERROR,
      'send_message'
    );
  }

  /**
   * æ‰§è¡Œå·¥å…·(å¸¦é”™è¯¯å¤„ç†)
   */
  async executeTool(toolName: string, input: any): Promise<any> {
    return this.errorHandler.handleError(
      async () => {
        const tool = this.toolRegistry.getTool(toolName);
        if (!tool) {
          throw new Error(`Tool not found: ${toolName}`);
        }
        return await tool.execute(input);
      },
      ErrorType.TOOL_EXECUTION_ERROR,
      `tool_${toolName}`
    );
  }

  /**
   * å…¨å±€é”™è¯¯å¤„ç†
   */
  async executeWithErrorHandling<T>(
    operation: () => Promise<T>
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      // åˆ†ç±»é”™è¯¯
      const errorType = this.errorHandler.classifyError(error);

      // å°è¯•æ¢å¤
      return await this.errorHandler.handleError(
        operation,
        errorType,
        'global_operation'
      );
    }
  }
}
```



## å…«ã€æ€§èƒ½ä¼˜åŒ–

### 8.1 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

| ä¼˜åŒ–ç‚¹ | ç­–ç•¥ | æ•ˆæœ |
|--------|------|------|
| **APIè°ƒç”¨** | è¯·æ±‚åˆå¹¶ã€æ‰¹å¤„ç† | å‡å°‘ç½‘ç»œå¾€è¿” |
| **ä¸Šä¸‹æ–‡ç®¡ç†** | æ™ºèƒ½æˆªæ–­ã€å‹ç¼© | é™ä½Tokenæ¶ˆè€— |
| **å·¥å…·æ‰§è¡Œ** | å¹¶å‘æ‰§è¡Œã€ç¼“å­˜ | æå‡å“åº”é€Ÿåº¦ |
| **æµå¼æ¸²æŸ“** | å¢é‡æ›´æ–°ã€èŠ‚æµ | ä¼˜åŒ–UIæ€§èƒ½ |
| **å†…å­˜ç®¡ç†** | å¯¹è±¡æ± ã€åŠæ—¶é‡Šæ”¾ | å‡å°‘GCå‹åŠ› |

### 8.2 ä¸Šä¸‹æ–‡ä¼˜åŒ–

```typescript
/**
 * ä¸Šä¸‹æ–‡ä¼˜åŒ–å™¨
 */
class ContextOptimizer {
  private maxTokens: number;
  private tokenCounter: TokenCounter;

  constructor(maxTokens: number = 100000) {
    this.maxTokens = maxTokens;
    this.tokenCounter = new TokenCounter();
  }

  /**
   * ä¼˜åŒ–æ¶ˆæ¯å†å²
   */
  optimizeMessages(messages: Anthropic.MessageParam[]): Anthropic.MessageParam[] {
    // 1. è®¡ç®—å½“å‰tokenæ•°
    const currentTokens = this.tokenCounter.countMessages(messages);

    if (currentTokens <= this.maxTokens * 0.8) {
      // æœªè¾¾åˆ°é˜ˆå€¼,æ— éœ€ä¼˜åŒ–
      return messages;
    }

    console.log(`ä¸Šä¸‹æ–‡ä¼˜åŒ–: ${currentTokens} tokens -> ç›®æ ‡: ${this.maxTokens * 0.7} tokens`);

    // 2. æ‰§è¡Œä¼˜åŒ–ç­–ç•¥
    let optimized = messages;

    // ç­–ç•¥1: ç§»é™¤æ—§æ¶ˆæ¯ï¼ˆä¿ç•™ç³»ç»Ÿæ¶ˆæ¯å’Œæœ€è¿‘Næ¡ï¼‰
    optimized = this.removeOldMessages(optimized);

    // ç­–ç•¥2: å‹ç¼©å·¥å…·ç»“æœ
    optimized = this.compressToolResults(optimized);

    // ç­–ç•¥3: æ€»ç»“å†å²å¯¹è¯
    // optimized = await this.summarizeHistory(optimized);

    const newTokens = this.tokenCounter.countMessages(optimized);
    console.log(`ä¼˜åŒ–å®Œæˆ: ${newTokens} tokens (å‡å°‘ ${currentTokens - newTokens})`);

    return optimized;
  }

  /**
   * ç§»é™¤æ—§æ¶ˆæ¯
   */
  private removeOldMessages(messages: Anthropic.MessageParam[]): Anthropic.MessageParam[] {
    // ä¿ç•™æœ€è¿‘20æ¡æ¶ˆæ¯
    const keepCount = Math.min(20, messages.length);
    return messages.slice(-keepCount);
  }

  /**
   * å‹ç¼©å·¥å…·ç»“æœ
   */
  private compressToolResults(messages: Anthropic.MessageParam[]): Anthropic.MessageParam[] {
    return messages.map(msg => {
      if (msg.role === 'user' && Array.isArray(msg.content)) {
        // æŸ¥æ‰¾å·¥å…·ç»“æœ
        const compressed = msg.content.map(block => {
          if (block.type === 'tool_result') {
            const content = block.content;
            if (typeof content === 'string' && content.length > 1000) {
              // æˆªæ–­é•¿å†…å®¹
              return {
                ...block,
                content: content.slice(0, 1000) + '\n... (truncated)'
              };
            }
          }
          return block;
        });

        return { ...msg, content: compressed };
      }
      return msg;
    });
  }
}

/**
 * Tokenè®¡æ•°å™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰
 */
class TokenCounter {
  /**
   * è®¡ç®—æ¶ˆæ¯çš„tokenæ•°ï¼ˆç²—ç•¥ä¼°ç®—ï¼‰
   */
  countMessages(messages: Anthropic.MessageParam[]): number {
    let total = 0;

    for (const msg of messages) {
      if (typeof msg.content === 'string') {
        total += this.estimateTokens(msg.content);
      } else if (Array.isArray(msg.content)) {
        for (const block of msg.content) {
          if ('text' in block) {
            total += this.estimateTokens(block.text);
          } else if ('content' in block) {
            total += this.estimateTokens(String(block.content));
          }
        }
      }
    }

    return total;
  }

  /**
   * ä¼°ç®—æ–‡æœ¬çš„tokenæ•°
   * ç®€åŒ–ç®—æ³•: è‹±æ–‡çº¦4å­—ç¬¦=1 token, ä¸­æ–‡çº¦1.5å­—ç¬¦=1 token
   */
  private estimateTokens(text: string): number {
    // ç»Ÿè®¡ä¸­è‹±æ–‡å­—ç¬¦
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const otherChars = text.length - chineseChars;

    return Math.ceil(chineseChars / 1.5 + otherChars / 4);
  }
}

export { ContextOptimizer, TokenCounter };
```

### 8.3 å·¥å…·æ‰§è¡Œå¹¶å‘æ§åˆ¶

```typescript
/**
 * å¹¶å‘é™åˆ¶å™¨
 */
class ConcurrencyLimiter {
  private maxConcurrent: number;
  private running: number = 0;
  private queue: Array<() => void> = [];

  constructor(maxConcurrent: number = 5) {
    this.maxConcurrent = maxConcurrent;
  }

  /**
   * æ‰§è¡Œä»»åŠ¡(å¸¦å¹¶å‘æ§åˆ¶)
   */
  async execute<T>(task: () => Promise<T>): Promise<T> {
    // ç­‰å¾…è·å–æ‰§è¡Œæƒ
    await this.waitForSlot();

    this.running++;

    try {
      return await task();
    } finally {
      this.running--;
      this.releaseSlot();
    }
  }

  /**
   * ç­‰å¾…ç©ºé—²æ§½ä½
   */
  private waitForSlot(): Promise<void> {
    if (this.running < this.maxConcurrent) {
      return Promise.resolve();
    }

    return new Promise(resolve => {
      this.queue.push(resolve);
    });
  }

  /**
   * é‡Šæ”¾æ§½ä½
   */
  private releaseSlot(): void {
    const next = this.queue.shift();
    if (next) {
      next();
    }
  }

  /**
   * è·å–çŠ¶æ€
   */
  getStatus(): { running: number; queued: number } {
    return {
      running: this.running,
      queued: this.queue.length
    };
  }
}

/**
 * å¸¦ç¼“å­˜çš„å·¥å…·æ‰§è¡Œå™¨
 */
class CachedToolExecutor {
  private cache: Map<string, { result: any; timestamp: number }> = new Map();
  private cacheTTL: number = 60000; // 1åˆ†é’Ÿ
  private limiter: ConcurrencyLimiter;

  constructor(maxConcurrent: number = 5) {
    this.limiter = new ConcurrencyLimiter(maxConcurrent);
  }

  /**
   * æ‰§è¡Œå·¥å…·(å¸¦ç¼“å­˜)
   */
  async executeTool(
    toolName: string,
    input: any,
    options: { useCache?: boolean } = {}
  ): Promise<any> {
    // ç”Ÿæˆç¼“å­˜é”®
    const cacheKey = this.generateCacheKey(toolName, input);

    // æ£€æŸ¥ç¼“å­˜
    if (options.useCache !== false) {
      const cached = this.getFromCache(cacheKey);
      if (cached) {
        console.log(`âœ… ä½¿ç”¨ç¼“å­˜: ${toolName}`);
        return cached;
      }
    }

    // æ‰§è¡Œå·¥å…·(å¸¦å¹¶å‘æ§åˆ¶)
    const result = await this.limiter.execute(async () => {
      console.log(`ğŸ”§ æ‰§è¡Œ: ${toolName}`);
      const tool = toolRegistry.getTool(toolName);
      return await tool.execute(input);
    });

    // å­˜å…¥ç¼“å­˜
    if (options.useCache !== false) {
      this.setToCache(cacheKey, result);
    }

    return result;
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”®
   */
  private generateCacheKey(toolName: string, input: any): string {
    return `${toolName}:${JSON.stringify(input)}`;
  }

  /**
   * ä»ç¼“å­˜è·å–
   */
  private getFromCache(key: string): any | null {
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - entry.timestamp > this.cacheTTL) {
      this.cache.delete(key);
      return null;
    }

    return entry.result;
  }

  /**
   * å­˜å…¥ç¼“å­˜
   */
  private setToCache(key: string, result: any): void {
    this.cache.set(key, {
      result,
      timestamp: Date.now()
    });
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  cleanupCache(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.cacheTTL) {
        this.cache.delete(key);
      }
    }
  }
}

export { ConcurrencyLimiter, CachedToolExecutor };
```



## ä¹ã€å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆAIæœ‰æ—¶ä¼š"å¹»è§‰"ï¼Ÿ

**åŸå› **:
- è®­ç»ƒæ•°æ®ä¸­çš„é”™è¯¯ä¿¡æ¯
- å¯¹ä¸ç¡®å®šä¿¡æ¯çš„è¿‡åº¦æ¨æµ‹
- ä¸Šä¸‹æ–‡ä¿¡æ¯ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**:
```typescript
// 1. åœ¨ç³»ç»Ÿæç¤ºè¯ä¸­å¼ºè°ƒå‡†ç¡®æ€§
const systemPrompt = `
ä½ å¿…é¡»:
- å¯¹ä¸ç¡®å®šçš„ä¿¡æ¯æ˜ç¡®è¯´æ˜
- å¼•ç”¨å·¥å…·è¿”å›çš„å®é™…æ•°æ®
- ä¸è¦æ¨æµ‹æˆ–ç¼–é€ ä¿¡æ¯
`;

// 2. ä½¿ç”¨å·¥å…·éªŒè¯ä¿¡æ¯
if (needsVerification) {
  await toolRegistry.executeTool('Read', { file_path: '/path/to/file' });
}
```

### Q2: å¦‚ä½•æ§åˆ¶AIçš„Tokenæ¶ˆè€—ï¼Ÿ

**æ–¹æ³•**:

1. **ä¼˜åŒ–ç³»ç»Ÿæç¤ºè¯**: ç§»é™¤å†—ä½™è¯´æ˜
2. **æ™ºèƒ½æˆªæ–­ä¸Šä¸‹æ–‡**: åªä¿ç•™å¿…è¦çš„å†å²æ¶ˆæ¯
3. **å‹ç¼©å·¥å…·ç»“æœ**: æˆªæ–­é•¿è¾“å‡º
4. **ä½¿ç”¨æµå¼å“åº”**: å¯ä»¥æå‰ä¸­æ–­

```typescript
// ç¤ºä¾‹:è®¾ç½®åˆç†çš„max_tokens
const response = await client.messages.create({
  model: 'claude-3-5-sonnet-20250929',
  max_tokens: 2000, // è€Œä¸æ˜¯8000
  messages: optimizedMessages
});
```

### Q3: å·¥å…·è°ƒç”¨å¤±è´¥å¦‚ä½•å¤„ç†ï¼Ÿ

**ç­–ç•¥**:

```typescript
// 1. è¿”å›é”™è¯¯ä¿¡æ¯ç»™AI,è®©å®ƒå†³å®šå¦‚ä½•å¤„ç†
const toolResult = {
  type: 'tool_result',
  tool_use_id: callId,
  content: `Error: ${error.message}`,
  is_error: true
};

// 2. å®ç°é‡è¯•æœºåˆ¶
const result = await retryWithBackoff(
  () => tool.execute(input),
  { maxRetries: 3, delay: 1000 }
);

// 3. æä¾›å›é€€æ–¹æ¡ˆ
try {
  return await primaryTool.execute(input);
} catch {
  return await fallbackTool.execute(input);
}
```

### Q4: å¦‚ä½•è°ƒè¯•AIçš„å†³ç­–è¿‡ç¨‹ï¼Ÿ

**æ–¹æ³•**:

```typescript
// 1. å¯ç”¨è¯¦ç»†æ—¥å¿—
EventBus.on(SystemEvent.TOOL_CALL_START, (event) => {
  console.log('å·¥å…·è°ƒç”¨:', JSON.stringify(event, null, 2));
});

// 2. ä¿å­˜å®Œæ•´å¯¹è¯å†å²
const debugLog = messages.map(msg => ({
  role: msg.role,
  content: JSON.stringify(msg.content)
}));
fs.writeFileSync('debug.json', JSON.stringify(debugLog, null, 2));

// 3. åœ¨æç¤ºè¯ä¸­è¦æ±‚AIè§£é‡Šæ¨ç†
const systemPrompt = `
åœ¨æ‰§è¡Œæ“ä½œå‰,è¯·ç®€è¦è¯´æ˜ä½ çš„æ¨ç†è¿‡ç¨‹ã€‚
`;
```

### Q5: æµå¼å“åº”ä¸­æ–­å¦‚ä½•å¤„ç†ï¼Ÿ

```typescript
// è®¾ç½®è¶…æ—¶å’Œä¸­æ–­å¤„ç†
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 30000);

try {
  const stream = await client.messages.create({
    model: 'claude-3-5-sonnet-20250929',
    messages,
    stream: true,
    signal: controller.signal // ä¼ å…¥ä¿¡å·
  });

  for await (const event of stream) {
    // å¤„ç†äº‹ä»¶
  }
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('æµå¼å“åº”è¶…æ—¶,ä½¿ç”¨éƒ¨åˆ†ç»“æœ');
  }
} finally {
  clearTimeout(timeout);
}
```



## åã€æ‰©å±•é˜…è¯»

### 10.1 å®˜æ–¹æ–‡æ¡£

1. **Anthropic API æ–‡æ¡£**
   - URL: https://docs.anthropic.com/
   - å†…å®¹: APIå®Œæ•´å‚è€ƒã€æœ€ä½³å®è·µ

2. **Tool Use æŒ‡å—**
   - URL: https://docs.anthropic.com/claude/docs/tool-use
   - å†…å®¹: å·¥å…·è°ƒç”¨çš„è¯¦ç»†è¯´æ˜

3. **Prompt Engineering**
   - URL: https://docs.anthropic.com/claude/docs/prompt-engineering
   - å†…å®¹: æç¤ºè¯å·¥ç¨‹æœ€ä½³å®è·µ

### 10.2 ç›¸å…³æŠ€æœ¯

1. **Server-Sent Events (SSE)**
   - MDN: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
   - äº†è§£æµå¼ä¼ è¾“åè®®

2. **Event-Driven Architecture**
   - äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼
   - æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡

3. **TypeScript æ³›å‹å’Œç±»å‹ç³»ç»Ÿ**
   - ç”¨äºæ„å»ºç±»å‹å®‰å…¨çš„AIåº”ç”¨

### 10.3 å¼€æºé¡¹ç›®å‚è€ƒ

1. **LangChain**
   - GitHub: https://github.com/langchain-ai/langchainjs
   - AIåº”ç”¨å¼€å‘æ¡†æ¶

2. **Vercel AI SDK**
   - GitHub: https://github.com/vercel/ai
   - æµå¼AIå“åº”å¤„ç†

3. **AutoGPT**
   - GitHub: https://github.com/Significant-Gravitas/AutoGPT
   - è‡ªä¸»AIä»£ç†å®ç°

## æ€»ç»“

æœ¬æ–‡æ·±å…¥è®²è§£äº†Claude Codeçš„æ ¸å¿ƒå¼•æ“å®ç°,æ¶µç›–äº†ä»¥ä¸‹å…³é”®æŠ€æœ¯:

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **AIå¼•æ“æ¶æ„**
   - æ¨¡å—åŒ–è®¾è®¡,èŒè´£æ¸…æ™°
   - äº‹ä»¶é©±åŠ¨,æ¾è€¦åˆ
   - æ”¯æŒæ‰©å±•å’Œå®šåˆ¶

2. **Promptå·¥ç¨‹**
   - ç³»ç»Ÿæç¤ºè¯æ˜¯AIçš„"æ“ä½œæ‰‹å†Œ"
   - åŠ¨æ€ç”Ÿæˆ,åŒ…å«å·¥å…·æ–‡æ¡£å’Œä¸Šä¸‹æ–‡
   - Few-shotç¤ºä¾‹æå‡æ€§èƒ½

3. **æ¶ˆæ¯é˜Ÿåˆ—å’Œäº‹ä»¶æ€»çº¿**
   - å¼‚æ­¥å¤„ç†ç”¨æˆ·è¯·æ±‚
   - äº‹ä»¶è§£è€¦ç»„ä»¶é€šä¿¡
   - æ”¯æŒé”™è¯¯æ¢å¤å’Œé‡è¯•

4. **æµå¼å“åº”å¤„ç†**
   - SSEåè®®å®ç°å®æ—¶è¾“å‡º
   - å¢é‡è§£ææå‡ä½“éªŒ
   - æ”¯æŒå·¥å…·è°ƒç”¨çš„æµå¼å¤„ç†

5. **å·¥å…·è°ƒç”¨å¾ªç¯**
   - è‡ªåŠ¨æ‰§è¡Œå·¥å…·å¹¶ç»§ç»­å¯¹è¯
   - æ·±åº¦æ§åˆ¶é˜²æ­¢æ— é™å¾ªç¯
   - å¹¶å‘æ‰§è¡Œæå‡æ•ˆç‡

6. **é”™è¯¯æ¢å¤æœºåˆ¶**
   - åˆ†ç±»é”™è¯¯,å·®å¼‚åŒ–å¤„ç†
   - æŒ‡æ•°é€€é¿é‡è¯•
   - å›é€€æ–¹æ¡ˆä¿è¯å¯ç”¨æ€§

7. **æ€§èƒ½ä¼˜åŒ–**
   - ä¸Šä¸‹æ–‡æ™ºèƒ½å‹ç¼©
   - å·¥å…·æ‰§è¡Œå¹¶å‘æ§åˆ¶
   - ç»“æœç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
