---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆåï¼‰ï¼šæµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆ
date: 2025-01-15
permalink: /ai/claude-code/architecture-10-browser-automation.html
tags:
  - Claude Code
categories:
  - Claude Code
---

# æµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆ

## ä¸€ã€å¼•è¨€

æµè§ˆå™¨è‡ªåŠ¨åŒ–æ˜¯ç°ä»£è½¯ä»¶å¼€å‘ä¸­ä¸å¯æˆ–ç¼ºçš„èƒ½åŠ›ï¼Œæ— è®ºæ˜¯ Web åº”ç”¨æµ‹è¯•ã€ç½‘é¡µæ•°æ®æŠ“å–ï¼Œè¿˜æ˜¯è‡ªåŠ¨åŒ–è¿ç»´ä»»åŠ¡ï¼Œéƒ½éœ€è¦ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’ã€‚Claude Code é€šè¿‡ Playwright MCP Server æä¾›äº†å¼ºå¤§çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›ï¼Œè®© AI èƒ½å¤Ÿåƒäººç±»ä¸€æ ·æ“ä½œæµè§ˆå™¨ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦æµè§ˆå™¨è‡ªåŠ¨åŒ–ï¼Ÿ

åœ¨ AI è¾…åŠ©å¼€å‘ä¸­ï¼Œæµè§ˆå™¨è‡ªåŠ¨åŒ–æœ‰ä»¥ä¸‹åº”ç”¨åœºæ™¯ï¼š

1. **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šè‡ªåŠ¨æ‰§è¡Œ Web åº”ç”¨çš„ç«¯åˆ°ç«¯æµ‹è¯•
2. **ç½‘é¡µæ•°æ®é‡‡é›†**ï¼šä»åŠ¨æ€ç½‘é¡µä¸­æå–æ•°æ®
3. **UI äº¤äº’è°ƒè¯•**ï¼šæ¨¡æ‹Ÿç”¨æˆ·æ“ä½œï¼Œå®šä½å‰ç«¯é—®é¢˜
4. **æˆªå›¾å’Œæ–‡æ¡£ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆåº”ç”¨æˆªå›¾å’Œæ–‡æ¡£
5. **ç½‘ç«™ç›‘æ§**ï¼šå®šæœŸæ£€æŸ¥ç½‘ç«™å¯ç”¨æ€§å’ŒåŠŸèƒ½æ­£å¸¸æ€§

### æœ¬æ–‡ç›®æ ‡

é€šè¿‡æœ¬æ–‡ï¼Œä½ å°†å­¦ä¹ åˆ°ï¼š
- Playwright MCP Server çš„å®ç°åŸç†
- é¡µé¢å¿«ç…§å’Œ DOM è§£æï¼ˆAccessibility Treeï¼‰
- å…ƒç´ å®šä½å’Œäº¤äº’ï¼ˆclickã€typeã€select ç­‰ï¼‰
- ç½‘ç»œè¯·æ±‚ç›‘æ§å’Œæ‹¦æˆª
- æˆªå›¾å’Œ PDF ç”Ÿæˆ
- è‡ªåŠ¨åŒ–æµ‹è¯•åœºæ™¯
- å®Œæ•´çš„ Web è‡ªåŠ¨åŒ–å®æˆ˜æ¡ˆä¾‹


## äºŒã€Playwright MCP Server å®ç°

### 2.1 æ•´ä½“æ¶æ„

Claude Code é€šè¿‡ MCPï¼ˆModel Context Protocolï¼‰ä¸ Playwright Server é€šä¿¡ï¼Œå®ç°æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›ã€‚

```mermaid
graph TB
    subgraph "Claude Code"
        A[Claude AI] --> B[MCP Client]
    end

    subgraph "Playwright MCP Server"
        B --> C[JSON-RPC Handler]
        C --> D[Tool Router]
        D --> E1[Browser Manager]
        D --> E2[Page Manager]
        D --> E3[Element Manager]

        E1 --> F[Playwright API]
        E2 --> F
        E3 --> F
    end

    subgraph "Browser"
        F --> G[Chromium/Firefox/WebKit]
        G --> H[Web Page]
    end

    style A fill:#e1f5ff
    style F fill:#ffe1f5
    style H fill:#e1ffe1
```

### 2.2 æ ¸å¿ƒç»„ä»¶

#### **BrowserManagerï¼ˆæµè§ˆå™¨ç®¡ç†å™¨ï¼‰**

è´Ÿè´£æµè§ˆå™¨å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š

```typescript
/**
 * æµè§ˆå™¨ç®¡ç†å™¨
 * ç®¡ç†æµè§ˆå™¨å®ä¾‹çš„åˆ›å»ºã€é…ç½®å’Œé”€æ¯
 */
class BrowserManager {
  private browser: Browser | null = null;
  private context: BrowserContext | null = null;
  private page: Page | null = null;

  /**
   * å¯åŠ¨æµè§ˆå™¨
   */
  async launch(options: LaunchOptions = {}): Promise<void> {
    const playwright = require('playwright');

    // é»˜è®¤é…ç½®
    const defaultOptions: LaunchOptions = {
      headless: false,  // æ˜¾ç¤ºæµè§ˆå™¨çª—å£
      slowMo: 0,        // æ“ä½œå»¶è¿Ÿï¼ˆmsï¼‰
      timeout: 30000,   // è¶…æ—¶æ—¶é—´
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ]
    };

    // å¯åŠ¨æµè§ˆå™¨
    this.browser = await playwright.chromium.launch({
      ...defaultOptions,
      ...options
    });

    // åˆ›å»ºæµè§ˆå™¨ä¸Šä¸‹æ–‡
    this.context = await this.browser.newContext({
      viewport: { width: 1280, height: 720 },
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: ['geolocation', 'notifications']
    });

    // åˆ›å»ºé¡µé¢
    this.page = await this.context.newPage();

    console.error('[BrowserManager] Browser launched successfully');
  }

  /**
   * è·å–å½“å‰é¡µé¢
   */
  getPage(): Page {
    if (!this.page) {
      throw new Error('Browser not launched. Call launch() first.');
    }
    return this.page;
  }

  /**
   * è°ƒæ•´çª—å£å¤§å°
   */
  async resize(width: number, height: number): Promise<void> {
    await this.getPage().setViewportSize({ width, height });
  }

  /**
   * å…³é—­æµè§ˆå™¨
   */
  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
      this.context = null;
      this.page = null;
      console.error('[BrowserManager] Browser closed');
    }
  }
}
```

#### **PageManagerï¼ˆé¡µé¢ç®¡ç†å™¨ï¼‰**

è´Ÿè´£é¡µé¢å¯¼èˆªå’ŒçŠ¶æ€ç®¡ç†ï¼š

```typescript
/**
 * é¡µé¢ç®¡ç†å™¨
 * ç®¡ç†é¡µé¢å¯¼èˆªã€ç½‘ç»œç›‘æ§ã€æ§åˆ¶å°æ¶ˆæ¯ç­‰
 */
class PageManager {
  private page: Page;
  private consoleMessages: ConsoleMessage[] = [];
  private networkRequests: Request[] = [];
  private dialogs: Dialog[] = [];

  constructor(page: Page) {
    this.page = page;
    this.setupListeners();
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬
   */
  private setupListeners(): void {
    // ç›‘å¬æ§åˆ¶å°æ¶ˆæ¯
    this.page.on('console', (msg) => {
      this.consoleMessages.push(msg);
      console.error(`[Console] ${msg.type()}: ${msg.text()}`);
    });

    // ç›‘å¬ç½‘ç»œè¯·æ±‚
    this.page.on('request', (request) => {
      this.networkRequests.push(request);
      console.error(`[Network] ${request.method()} ${request.url()}`);
    });

    // ç›‘å¬å¯¹è¯æ¡†
    this.page.on('dialog', (dialog) => {
      this.dialogs.push(dialog);
      console.error(`[Dialog] ${dialog.type()}: ${dialog.message()}`);
    });

    // ç›‘å¬é¡µé¢é”™è¯¯
    this.page.on('pageerror', (error) => {
      console.error('[PageError]', error);
    });
  }

  /**
   * å¯¼èˆªåˆ° URL
   */
  async navigate(url: string, options?: NavigationOptions): Promise<string> {
    try {
      console.error(`[PageManager] Navigating to: ${url}`);

      const response = await this.page.goto(url, {
        waitUntil: 'domcontentloaded',
        timeout: 30000,
        ...options
      });

      const status = response?.status() || 0;
      const finalUrl = this.page.url();

      return `Navigated to ${finalUrl} (Status: ${status})`;
    } catch (error) {
      throw new Error(`Navigation failed: ${error.message}`);
    }
  }

  /**
   * åé€€
   */
  async goBack(): Promise<string> {
    await this.page.goBack();
    return `Navigated back to ${this.page.url()}`;
  }

  /**
   * å‰è¿›
   */
  async goForward(): Promise<string> {
    await this.page.goForward();
    return `Navigated forward to ${this.page.url()}`;
  }

  /**
   * åˆ·æ–°é¡µé¢
   */
  async reload(): Promise<string> {
    await this.page.reload();
    return 'Page reloaded';
  }

  /**
   * ç­‰å¾…åŠ è½½å®Œæˆ
   */
  async waitForLoad(state: 'load' | 'domcontentloaded' | 'networkidle' = 'load'): Promise<void> {
    await this.page.waitForLoadState(state);
  }

  /**
   * è·å–æ§åˆ¶å°æ¶ˆæ¯
   */
  getConsoleMessages(onlyErrors = false): string {
    let messages = this.consoleMessages;

    if (onlyErrors) {
      messages = messages.filter(msg => msg.type() === 'error');
    }

    return messages
      .map(msg => `[${msg.type()}] ${msg.text()}`)
      .join('\n');
  }

  /**
   * è·å–ç½‘ç»œè¯·æ±‚
   */
  getNetworkRequests(): string {
    return this.networkRequests
      .map(req => `${req.method()} ${req.url()} -> ${req.response()?.status() || 'pending'}`)
      .join('\n');
  }

  /**
   * æ¸…ç©ºè®°å½•
   */
  clearRecords(): void {
    this.consoleMessages = [];
    this.networkRequests = [];
    this.dialogs = [];
  }
}
```

#### **ElementManagerï¼ˆå…ƒç´ ç®¡ç†å™¨ï¼‰**

è´Ÿè´£å…ƒç´ å®šä½å’Œäº¤äº’ï¼š

```typescript
/**
 * å…ƒç´ ç®¡ç†å™¨
 * è´Ÿè´£å…ƒç´ å®šä½ã€äº¤äº’å’Œæ“ä½œ
 */
class ElementManager {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * ç‚¹å‡»å…ƒç´ 
   */
  async click(selector: string, options?: ClickOptions): Promise<string> {
    try {
      // ç­‰å¾…å…ƒç´ å¯è§
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      // ç‚¹å‡»å…ƒç´ 
      await this.page.click(selector, {
        timeout: 5000,
        ...options
      });

      return `Clicked element: ${selector}`;
    } catch (error) {
      throw new Error(`Click failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è¾“å…¥æ–‡æœ¬
   */
  async type(selector: string, text: string, options?: TypeOptions): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      // æ¸…ç©ºè¾“å…¥æ¡†
      await this.page.fill(selector, '');

      // è¾“å…¥æ–‡æœ¬
      if (options?.slowly) {
        await this.page.type(selector, text, { delay: 100 });
      } else {
        await this.page.fill(selector, text);
      }

      // æ˜¯å¦æäº¤ï¼ˆæŒ‰ Enterï¼‰
      if (options?.submit) {
        await this.page.press(selector, 'Enter');
      }

      return `Typed text into ${selector}`;
    } catch (error) {
      throw new Error(`Type failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹
   */
  async select(selector: string, values: string[]): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });
      await this.page.selectOption(selector, values);
      return `Selected options in ${selector}: ${values.join(', ')}`;
    } catch (error) {
      throw new Error(`Select failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * å‹¾é€‰/å–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
   */
  async check(selector: string, checked: boolean): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      if (checked) {
        await this.page.check(selector);
      } else {
        await this.page.uncheck(selector);
      }

      return `${checked ? 'Checked' : 'Unchecked'} ${selector}`;
    } catch (error) {
      throw new Error(`Check failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * æ‚¬åœ
   */
  async hover(selector: string): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });
      await this.page.hover(selector);
      return `Hovered over ${selector}`;
    } catch (error) {
      throw new Error(`Hover failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * æ‹–æ‹½
   */
  async drag(sourceSelector: string, targetSelector: string): Promise<string> {
    try {
      await this.page.waitForSelector(sourceSelector, { state: 'visible', timeout: 10000 });
      await this.page.waitForSelector(targetSelector, { state: 'visible', timeout: 10000 });

      const source = await this.page.locator(sourceSelector);
      const target = await this.page.locator(targetSelector);

      await source.dragTo(target);

      return `Dragged ${sourceSelector} to ${targetSelector}`;
    } catch (error) {
      throw new Error(`Drag failed: ${error.message}`);
    }
  }

  /**
   * ç­‰å¾…å…ƒç´ 
   */
  async waitFor(selector: string, state: 'visible' | 'hidden' | 'attached' = 'visible'): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state, timeout: 30000 });
      return `Element ${selector} is now ${state}`;
    } catch (error) {
      throw new Error(`Wait failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è·å–å…ƒç´ æ–‡æœ¬
   */
  async getText(selector: string): Promise<string> {
    try {
      const element = await this.page.waitForSelector(selector, { timeout: 10000 });
      const text = await element.textContent();
      return text || '';
    } catch (error) {
      throw new Error(`Get text failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è·å–å…ƒç´ å±æ€§
   */
  async getAttribute(selector: string, attribute: string): Promise<string> {
    try {
      const element = await this.page.waitForSelector(selector, { timeout: 10000 });
      const value = await element.getAttribute(attribute);
      return value || '';
    } catch (error) {
      throw new Error(`Get attribute failed: ${error.message}`);
    }
  }
}
```

### 2.3 MCP Server å®ç°

å®Œæ•´çš„ Playwright MCP Server å®ç°ï¼š

```typescript
import { Browser, BrowserContext, Page } from 'playwright';
import { chromium } from 'playwright';

/**
 * Playwright MCP Server
 * æä¾›æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›
 */
class PlaywrightMCPServer {
  private browserManager: BrowserManager;
  private pageManager: PageManager | null = null;
  private elementManager: ElementManager | null = null;
  private tools: Map<string, any> = new Map();

  constructor() {
    this.browserManager = new BrowserManager();
    this.registerTools();
  }

  /**
   * æ³¨å†Œæ‰€æœ‰å·¥å…·
   */
  private registerTools(): void {
    // æµè§ˆå™¨æ§åˆ¶å·¥å…·
    this.registerTool({
      name: 'browser_navigate',
      description: 'Navigate to a URL',
      inputSchema: {
        type: 'object',
        properties: {
          url: {
            type: 'string',
            description: 'The URL to navigate to'
          }
        },
        required: ['url']
      }
    }, this.handleNavigate.bind(this));

    this.registerTool({
      name: 'browser_snapshot',
      description: 'Capture accessibility snapshot of the current page. This returns the DOM structure which is better than a screenshot for understanding page content.',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleSnapshot.bind(this));

    this.registerTool({
      name: 'browser_click',
      description: 'Click on an element',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          }
        },
        required: ['element', 'ref']
      }
    }, this.handleClick.bind(this));

    this.registerTool({
      name: 'browser_type',
      description: 'Type text into an editable element',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          },
          text: {
            type: 'string',
            description: 'Text to type'
          },
          submit: {
            type: 'boolean',
            description: 'Press Enter after typing'
          }
        },
        required: ['element', 'ref', 'text']
      }
    }, this.handleType.bind(this));

    this.registerTool({
      name: 'browser_select_option',
      description: 'Select an option in a dropdown',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          },
          values: {
            type: 'array',
            items: { type: 'string' },
            description: 'Values to select'
          }
        },
        required: ['element', 'ref', 'values']
      }
    }, this.handleSelectOption.bind(this));

    this.registerTool({
      name: 'browser_take_screenshot',
      description: 'Take a screenshot of the current page',
      inputSchema: {
        type: 'object',
        properties: {
          filename: {
            type: 'string',
            description: 'Filename for the screenshot'
          },
          fullPage: {
            type: 'boolean',
            description: 'Take full page screenshot'
          }
        }
      }
    }, this.handleScreenshot.bind(this));

    this.registerTool({
      name: 'browser_console_messages',
      description: 'Get all console messages from the page',
      inputSchema: {
        type: 'object',
        properties: {
          onlyErrors: {
            type: 'boolean',
            description: 'Only return error messages'
          }
        }
      }
    }, this.handleConsoleMessages.bind(this));

    this.registerTool({
      name: 'browser_network_requests',
      description: 'Get all network requests since loading the page',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleNetworkRequests.bind(this));

    this.registerTool({
      name: 'browser_evaluate',
      description: 'Execute JavaScript code in the page context',
      inputSchema: {
        type: 'object',
        properties: {
          function: {
            type: 'string',
            description: 'JavaScript function to execute'
          }
        },
        required: ['function']
      }
    }, this.handleEvaluate.bind(this));

    this.registerTool({
      name: 'browser_close',
      description: 'Close the browser',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleClose.bind(this));

    console.error(`[Playwright MCP] Registered ${this.tools.size} tools`);
  }

  /**
   * æ³¨å†Œå·¥å…·
   */
  private registerTool(tool: any, handler: (params: any) => Promise<string>): void {
    this.tools.set(tool.name, { tool, handler });
  }

  /**
   * ç¡®ä¿æµè§ˆå™¨å·²å¯åŠ¨
   */
  private async ensureBrowser(): Promise<void> {
    if (!this.browserManager.getPage) {
      await this.browserManager.launch();
      const page = this.browserManager.getPage();
      this.pageManager = new PageManager(page);
      this.elementManager = new ElementManager(page);
    }
  }

  // ========== å·¥å…·å¤„ç†å‡½æ•° ==========

  async handleNavigate(params: { url: string }): Promise<string> {
    await this.ensureBrowser();
    return await this.pageManager!.navigate(params.url);
  }

  async handleSnapshot(params: {}): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    // è·å– accessibility tree
    const snapshot = await page.accessibility.snapshot();

    // æ ¼å¼åŒ–è¾“å‡º
    return this.formatAccessibilityTree(snapshot);
  }

  private formatAccessibilityTree(node: any, indent = 0): string {
    if (!node) return '';

    const spaces = '  '.repeat(indent);
    let output = `${spaces}[${node.role}]`;

    if (node.name) {
      output += ` ${node.name}`;
    }

    if (node.value) {
      output += ` (value: ${node.value})`;
    }

    output += '\n';

    if (node.children) {
      for (const child of node.children) {
        output += this.formatAccessibilityTree(child, indent + 1);
      }
    }

    return output;
  }

  async handleClick(params: { element: string; ref: string }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.click(params.ref);
  }

  async handleType(params: { element: string; ref: string; text: string; submit?: boolean }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.type(params.ref, params.text, { submit: params.submit });
  }

  async handleSelectOption(params: { element: string; ref: string; values: string[] }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.select(params.ref, params.values);
  }

  async handleScreenshot(params: { filename?: string; fullPage?: boolean }): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    const filename = params.filename || `screenshot-${Date.now()}.png`;

    await page.screenshot({
      path: filename,
      fullPage: params.fullPage || false
    });

    return `Screenshot saved to ${filename}`;
  }

  async handleConsoleMessages(params: { onlyErrors?: boolean }): Promise<string> {
    await this.ensureBrowser();
    return this.pageManager!.getConsoleMessages(params.onlyErrors);
  }

  async handleNetworkRequests(params: {}): Promise<string> {
    await this.ensureBrowser();
    return this.pageManager!.getNetworkRequests();
  }

  async handleEvaluate(params: { function: string }): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    try {
      const result = await page.evaluate(params.function);
      return JSON.stringify(result, null, 2);
    } catch (error) {
      throw new Error(`Evaluate failed: ${error.message}`);
    }
  }

  async handleClose(params: {}): Promise<string> {
    await this.browserManager.close();
    this.pageManager = null;
    this.elementManager = null;
    return 'Browser closed';
  }

  // ========== MCP åè®®å¤„ç† ==========

  async handleToolsList(): Promise<{ tools: any[] }> {
    const tools = Array.from(this.tools.values()).map(t => t.tool);
    return { tools };
  }

  async handleToolCall(params: { name: string; arguments: any }): Promise<any> {
    const toolEntry = this.tools.get(params.name);

    if (!toolEntry) {
      throw new Error(`Tool not found: ${params.name}`);
    }

    try {
      const result = await toolEntry.handler(params.arguments);

      return {
        content: [
          {
            type: 'text',
            text: result
          }
        ],
        isError: false
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `Error: ${error.message}`
          }
        ],
        isError: true
      };
    }
  }

  async start(): Promise<void> {
    // å®ç° MCP Server å¯åŠ¨é€»è¾‘
    // ï¼ˆä¸å‰æ–‡ Git MCP Server ç±»ä¼¼ï¼‰
    console.error('[Playwright MCP] Server started');
  }
}

// å¯¼å‡º
export { PlaywrightMCPServer };
```


## ä¸‰ã€å…ƒç´ äº¤äº’æ“ä½œ

### 3.1 ç‚¹å‡»æ“ä½œ

```typescript
/**
 * ç‚¹å‡»æ“ä½œçš„å®Œæ•´å®ç°
 */
class ClickHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * æ™®é€šç‚¹å‡»
   */
  async click(selector: string): Promise<void> {
    await this.page.click(selector, {
      timeout: 5000,
      force: false  // ä¸å¼ºåˆ¶ç‚¹å‡»ï¼ˆç¡®ä¿å…ƒç´ å¯ç‚¹å‡»ï¼‰
    });
  }

  /**
   * åŒå‡»
   */
  async doubleClick(selector: string): Promise<void> {
    await this.page.dblclick(selector);
  }

  /**
   * å³é”®ç‚¹å‡»
   */
  async rightClick(selector: string): Promise<void> {
    await this.page.click(selector, { button: 'right' });
  }

  /**
   * å¸¦ä¿®é¥°é”®çš„ç‚¹å‡»
   */
  async clickWithModifier(
    selector: string,
    modifiers: ('Alt' | 'Control' | 'Meta' | 'Shift')[]
  ): Promise<void> {
    await this.page.click(selector, { modifiers });
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…å¯¼èˆª
   */
  async clickAndWaitForNavigation(selector: string): Promise<void> {
    await Promise.all([
      this.page.waitForNavigation(),
      this.page.click(selector)
    ]);
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…è¯·æ±‚
   */
  async clickAndWaitForRequest(
    selector: string,
    urlPattern: string | RegExp
  ): Promise<Request> {
    const [request] = await Promise.all([
      this.page.waitForRequest(urlPattern),
      this.page.click(selector)
    ]);
    return request;
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…å“åº”
   */
  async clickAndWaitForResponse(
    selector: string,
    urlPattern: string | RegExp
  ): Promise<Response> {
    const [response] = await Promise.all([
      this.page.waitForResponse(urlPattern),
      this.page.click(selector)
    ]);
    return response;
  }
}
```

### 3.2 è¾“å…¥æ“ä½œ

```typescript
/**
 * è¾“å…¥æ“ä½œçš„å®Œæ•´å®ç°
 */
class InputHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * å¿«é€Ÿå¡«å……ï¼ˆæ¨èï¼‰
   */
  async fill(selector: string, value: string): Promise<void> {
    // æ¸…ç©ºå¹¶å¡«å……
    await this.page.fill(selector, value);
  }

  /**
   * é€å­—ç¬¦è¾“å…¥ï¼ˆæ¨¡æ‹ŸçœŸå®è¾“å…¥ï¼‰
   */
  async type(selector: string, text: string, delay = 100): Promise<void> {
    // å…ˆæ¸…ç©º
    await this.page.fill(selector, '');

    // é€å­—ç¬¦è¾“å…¥
    await this.page.type(selector, text, { delay });
  }

  /**
   * æŒ‰é”®æ“ä½œ
   */
  async press(selector: string, key: string): Promise<void> {
    await this.page.press(selector, key);
  }

  /**
   * ç»„åˆé”®
   */
  async pressSequence(selector: string, keys: string[]): Promise<void> {
    for (const key of keys) {
      await this.page.press(selector, key);
    }
  }

  /**
   * æ¸…ç©ºè¾“å…¥æ¡†
   */
  async clear(selector: string): Promise<void> {
    await this.page.fill(selector, '');
  }

  /**
   * è¾“å…¥å¹¶æäº¤ï¼ˆæŒ‰ Enterï¼‰
   */
  async typeAndSubmit(selector: string, text: string): Promise<void> {
    await this.fill(selector, text);
    await this.press(selector, 'Enter');
  }

  /**
   * æ–‡ä»¶ä¸Šä¼ 
   */
  async uploadFile(selector: string, filePaths: string | string[]): Promise<void> {
    const paths = Array.isArray(filePaths) ? filePaths : [filePaths];
    await this.page.setInputFiles(selector, paths);
  }

  /**
   * æ¸…é™¤æ–‡ä»¶ä¸Šä¼ 
   */
  async clearFiles(selector: string): Promise<void> {
    await this.page.setInputFiles(selector, []);
  }
}
```

### 3.3 è¡¨å•æ“ä½œ

```typescript
/**
 * è¡¨å•æ“ä½œçš„å®Œæ•´å®ç°
 */
class FormHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * å‹¾é€‰å¤é€‰æ¡†
   */
  async check(selector: string): Promise<void> {
    await this.page.check(selector);
  }

  /**
   * å–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
   */
  async uncheck(selector: string): Promise<void> {
    await this.page.uncheck(selector);
  }

  /**
   * è®¾ç½®å¤é€‰æ¡†çŠ¶æ€
   */
  async setChecked(selector: string, checked: boolean): Promise<void> {
    if (checked) {
      await this.check(selector);
    } else {
      await this.uncheck(selector);
    }
  }

  /**
   * é€‰æ‹©å•é€‰æŒ‰é’®
   */
  async selectRadio(name: string, value: string): Promise<void> {
    await this.page.check(`input[type="radio"][name="${name}"][value="${value}"]`);
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹ï¼ˆå•é€‰ï¼‰
   */
  async selectOption(selector: string, value: string): Promise<void> {
    await this.page.selectOption(selector, value);
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹ï¼ˆå¤šé€‰ï¼‰
   */
  async selectMultipleOptions(selector: string, values: string[]): Promise<void> {
    await this.page.selectOption(selector, values);
  }

  /**
   * å¡«å……æ•´ä¸ªè¡¨å•
   */
  async fillForm(formData: Record<string, any>): Promise<void> {
    for (const [key, value] of Object.entries(formData)) {
      if (typeof value === 'boolean') {
        // å¤é€‰æ¡†
        await this.setChecked(`[name="${key}"]`, value);
      } else if (Array.isArray(value)) {
        // å¤šé€‰ä¸‹æ‹‰
        await this.selectMultipleOptions(`[name="${key}"]`, value);
      } else {
        // æ™®é€šè¾“å…¥
        await this.page.fill(`[name="${key}"]`, String(value));
      }
    }
  }

  /**
   * æäº¤è¡¨å•
   */
  async submit(formSelector: string): Promise<void> {
    await this.page.evaluate((selector) => {
      const form = document.querySelector(selector) as HTMLFormElement;
      if (form) {
        form.submit();
      }
    }, formSelector);
  }

  /**
   * è·å–è¡¨å•æ•°æ®
   */
  async getFormData(formSelector: string): Promise<Record<string, any>> {
    return await this.page.evaluate((selector) => {
      const form = document.querySelector(selector) as HTMLFormElement;
      if (!form) return {};

      const formData = new FormData(form);
      const data: Record<string, any> = {};

      for (const [key, value] of formData.entries()) {
        data[key] = value;
      }

      return data;
    }, formSelector);
  }
}
```


## å››ã€æˆªå›¾å’Œ PDF ç”Ÿæˆ

### 4.1 æˆªå›¾åŠŸèƒ½

```typescript
/**
 * æˆªå›¾å·¥å…·
 */
class ScreenshotTool {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * åŸºç¡€æˆªå›¾
   */
  async takeScreenshot(path: string): Promise<void> {
    await this.page.screenshot({ path });
  }

  /**
   * å…¨é¡µæˆªå›¾
   */
  async takeFullPageScreenshot(path: string): Promise<void> {
    await this.page.screenshot({
      path,
      fullPage: true
    });
  }

  /**
   * å…ƒç´ æˆªå›¾
   */
  async takeElementScreenshot(selector: string, path: string): Promise<void> {
    const element = await this.page.locator(selector);
    await element.screenshot({ path });
  }

  /**
   * æŒ‡å®šåŒºåŸŸæˆªå›¾
   */
  async takeClipScreenshot(
    path: string,
    clip: { x: number; y: number; width: number; height: number }
  ): Promise<void> {
    await this.page.screenshot({
      path,
      clip
    });
  }

  /**
   * æˆªå›¾ä¸º Bufferï¼ˆç”¨äºè¿›ä¸€æ­¥å¤„ç†ï¼‰
   */
  async screenshotToBuffer(): Promise<Buffer> {
    return await this.page.screenshot({ type: 'png' });
  }

  /**
   * æˆªå›¾ä¸º Base64
   */
  async screenshotToBase64(): Promise<string> {
    const buffer = await this.screenshotToBuffer();
    return buffer.toString('base64');
  }

  /**
   * éšè—å…ƒç´ åæˆªå›¾
   */
  async screenshotWithHiddenElements(
    path: string,
    hideSelectors: string[]
  ): Promise<void> {
    // éšè—å…ƒç´ 
    await this.page.evaluate((selectors) => {
      selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'hidden';
        });
      });
    }, hideSelectors);

    // æˆªå›¾
    await this.page.screenshot({ path });

    // æ¢å¤å…ƒç´ 
    await this.page.evaluate((selectors) => {
      selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'visible';
        });
      });
    }, hideSelectors);
  }

  /**
   * è‡ªåŠ¨ç­‰å¾…å¹¶æˆªå›¾
   */
  async screenshotWhenStable(path: string, maxWait = 5000): Promise<void> {
    // ç­‰å¾…ç½‘ç»œç©ºé—²
    await this.page.waitForLoadState('networkidle', { timeout: maxWait });

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿åŠ¨ç”»å®Œæˆ
    await this.page.waitForTimeout(500);

    // æˆªå›¾
    await this.page.screenshot({ path });
  }
}
```

### 4.2 PDF ç”Ÿæˆ

```typescript
/**
 * PDF ç”Ÿæˆå·¥å…·
 */
class PdfGenerator {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * åŸºç¡€ PDF ç”Ÿæˆ
   */
  async generatePdf(path: string): Promise<void> {
    await this.page.pdf({ path });
  }

  /**
   * è‡ªå®šä¹‰æ ¼å¼ PDF
   */
  async generateCustomPdf(
    path: string,
    options: {
      format?: 'A4' | 'Letter' | 'Legal';
      landscape?: boolean;
      printBackground?: boolean;
      margin?: {
        top?: string;
        right?: string;
        bottom?: string;
        left?: string;
      };
    } = {}
  ): Promise<void> {
    await this.page.pdf({
      path,
      format: options.format || 'A4',
      landscape: options.landscape || false,
      printBackground: options.printBackground !== false,
      margin: options.margin || {
        top: '1cm',
        right: '1cm',
        bottom: '1cm',
        left: '1cm'
      }
    });
  }

  /**
   * å¤šé¡µ PDF
   */
  async generateMultiPagePdf(
    urls: string[],
    outputPath: string
  ): Promise<void> {
    const PDFDocument = require('pdf-lib').PDFDocument;
    const mergedPdf = await PDFDocument.create();

    for (const url of urls) {
      // å¯¼èˆªåˆ°é¡µé¢
      await this.page.goto(url);

      // ç”Ÿæˆä¸´æ—¶ PDF
      const pdfBuffer = await this.page.pdf();

      // åŠ è½½ PDF
      const pdf = await PDFDocument.load(pdfBuffer);
      const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());

      // æ·»åŠ é¡µé¢
      copiedPages.forEach((page) => {
        mergedPdf.addPage(page);
      });
    }

    // ä¿å­˜åˆå¹¶åçš„ PDF
    const mergedPdfBytes = await mergedPdf.save();
    require('fs').writeFileSync(outputPath, mergedPdfBytes);
  }

  /**
   * å¸¦é¡µçœ‰é¡µè„šçš„ PDF
   */
  async generatePdfWithHeaderFooter(
    path: string,
    options: {
      headerTemplate?: string;
      footerTemplate?: string;
      displayHeaderFooter?: boolean;
    } = {}
  ): Promise<void> {
    await this.page.pdf({
      path,
      format: 'A4',
      displayHeaderFooter: options.displayHeaderFooter !== false,
      headerTemplate: options.headerTemplate || '<div></div>',
      footerTemplate: options.footerTemplate || `
        <div style="font-size: 10px; text-align: center; width: 100%;">
          Page <span class="pageNumber"></span> of <span class="totalPages"></span>
        </div>
      `,
      margin: {
        top: '2cm',
        bottom: '2cm'
      }
    });
  }
}
```


## äº”ã€æœ€ä½³å®è·µå’Œ FAQ

### 5.1 æœ€ä½³å®è·µ

#### **1. ä½¿ç”¨ç­‰å¾…è€Œéå»¶æ—¶**

```typescript
// âŒ ä¸å¥½ï¼šä½¿ç”¨å›ºå®šå»¶æ—¶
await page.waitForTimeout(3000);
await page.click('.button');

// âœ… å¥½ï¼šç­‰å¾…å…ƒç´ å¯äº¤äº’
await page.waitForSelector('.button', { state: 'visible' });
await page.click('.button');

// âœ… æ›´å¥½ï¼šPlaywright è‡ªåŠ¨ç­‰å¾…
await page.click('.button');  // Playwright ä¼šè‡ªåŠ¨ç­‰å¾…å…ƒç´ å¯ç‚¹å‡»
```

#### **2. ä½¿ç”¨æœ‰æ„ä¹‰çš„é€‰æ‹©å™¨**

```typescript
// âŒ ä¸å¥½ï¼šä½¿ç”¨è„†å¼±çš„é€‰æ‹©å™¨
await page.click('body > div:nth-child(3) > button:nth-child(2)');

// âœ… å¥½ï¼šä½¿ç”¨è¯­ä¹‰åŒ–é€‰æ‹©å™¨
await page.click('button[data-testid="submit-button"]');

// âœ… æ›´å¥½ï¼šä½¿ç”¨ Role å’Œ Text
await page.click('role=button[name="Submit"]');
```

#### **3. é¡µé¢å¯¹è±¡æ¨¡å¼**

```typescript
/**
 * é¡µé¢å¯¹è±¡æ¨¡å¼
 * å°è£…é¡µé¢çš„ç»“æ„å’Œè¡Œä¸º
 */
class LoginPage {
  private page: Page;

  // é€‰æ‹©å™¨å®šä¹‰
  private selectors = {
    usernameInput: 'input[name="username"]',
    passwordInput: 'input[name="password"]',
    submitButton: 'button[type="submit"]',
    errorMessage: '.error-message'
  };

  constructor(page: Page) {
    this.page = page;
  }

  async navigate() {
    await this.page.goto('/login');
  }

  async login(username: string, password: string) {
    await this.page.fill(this.selectors.usernameInput, username);
    await this.page.fill(this.selectors.passwordInput, password);
    await this.page.click(this.selectors.submitButton);
  }

  async getErrorMessage(): Promise<string> {
    const element = await this.page.locator(this.selectors.errorMessage);
    return await element.textContent() || '';
  }
}

// ä½¿ç”¨
const loginPage = new LoginPage(page);
await loginPage.navigate();
await loginPage.login('testuser', 'testpass');
```

#### **4. é”™è¯¯å¤„ç†å’Œé‡è¯•**

```typescript
/**
 * å¸¦é‡è¯•çš„æ“ä½œ
 */
async function clickWithRetry(
  page: Page,
  selector: string,
  maxRetries = 3
): Promise<void> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await page.click(selector, { timeout: 5000 });
      return;
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      console.error(`Click failed, retrying (${i + 1}/${maxRetries})...`);
      await page.waitForTimeout(1000);
    }
  }
}
```

#### **5. æ¸…ç†èµ„æº**

```typescript
/**
 * ç¡®ä¿æµè§ˆå™¨å…³é—­
 */
class BrowserSession {
  private browser: Browser | null = null;

  async start() {
    this.browser = await chromium.launch();
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  async execute<T>(fn: (page: Page) => Promise<T>): Promise<T> {
    await this.start();

    try {
      const page = await this.browser!.newPage();
      return await fn(page);
    } finally {
      await this.close();
    }
  }
}

// ä½¿ç”¨
const session = new BrowserSession();
await session.execute(async (page) => {
  await page.goto('https://example.com');
  // æ‰§è¡Œæ“ä½œ...
});
// è‡ªåŠ¨æ¸…ç†
```

### 5.2 å¸¸è§é—®é¢˜ FAQ

#### **Q1: å…ƒç´ æ‰¾ä¸åˆ°æ€ä¹ˆåŠï¼Ÿ**

**æ’æŸ¥æ­¥éª¤**ï¼š
1. æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨ iframe ä¸­
2. æ£€æŸ¥å…ƒç´ æ˜¯å¦éœ€è¦ç­‰å¾…åŠ è½½
3. ä½¿ç”¨ Playwright Inspector è°ƒè¯•
4. æ£€æŸ¥é€‰æ‹©å™¨æ˜¯å¦æ­£ç¡®

```typescript
// è°ƒè¯•æŠ€å·§
await page.pause();  // æš‚åœå¹¶æ‰“å¼€ Playwright Inspector

// æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
const exists = await page.locator(selector).count() > 0;
console.log(`Element exists: ${exists}`);

// ç­‰å¾…æ›´é•¿æ—¶é—´
await page.waitForSelector(selector, { timeout: 30000 });
```

#### **Q2: å¦‚ä½•å¤„ç† iframeï¼Ÿ**

```typescript
// è·å– iframe
const frame = page.frameLocator('iframe[name="myframe"]');

// åœ¨ iframe ä¸­æ“ä½œ
await frame.locator('button').click();

// æˆ–è€…ä½¿ç”¨ frame å¯¹è±¡
const frameElement = await page.frame({ name: 'myframe' });
await frameElement?.click('button');
```

#### **Q3: å¦‚ä½•å¤„ç†å¼¹çª—ï¼Ÿ**

```typescript
// ç›‘å¬å¹¶è‡ªåŠ¨å¤„ç†
page.on('dialog', async (dialog) => {
  console.log(`Dialog message: ${dialog.message()}`);
  await dialog.accept();  // æˆ– dialog.dismiss()
});

// æ‰‹åŠ¨å¤„ç†
const [dialog] = await Promise.all([
  page.waitForEvent('dialog'),
  page.click('.trigger-dialog')
]);

await dialog.accept('input text');
```

#### **Q4: å¦‚ä½•æ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡ï¼Ÿ**

```typescript
const { devices } = require('playwright');

// ä½¿ç”¨é¢„å®šä¹‰è®¾å¤‡
const iPhone = devices['iPhone 12'];
const context = await browser.newContext({
  ...iPhone,
  locale: 'en-US',
  geolocation: { latitude: 37.7749, longitude: -122.4194 },
  permissions: ['geolocation']
});

const page = await context.newPage();
```

#### **Q5: å¦‚ä½•å¤„ç†æ–‡ä»¶ä¸‹è½½ï¼Ÿ**

```typescript
// ç­‰å¾…ä¸‹è½½
const [download] = await Promise.all([
  page.waitForEvent('download'),
  page.click('a[download]')
]);

// ä¿å­˜æ–‡ä»¶
const path = await download.path();
console.log(`Downloaded to: ${path}`);

// æˆ–è€…ä¿å­˜åˆ°æŒ‡å®šä½ç½®
await download.saveAs('/path/to/save/file.pdf');
```


## å…­ã€æ€»ç»“

æµè§ˆå™¨è‡ªåŠ¨åŒ–æ˜¯ Claude Code çš„å¼ºå¤§èƒ½åŠ›ä¹‹ä¸€ï¼Œé€šè¿‡ Playwright MCP Serverï¼ŒAI èƒ½å¤Ÿåƒäººç±»ä¸€æ ·æ“ä½œæµè§ˆå™¨ï¼Œæ‰§è¡Œå¤æ‚çš„ Web è‡ªåŠ¨åŒ–ä»»åŠ¡ã€‚

### å…³é”®è¦ç‚¹

âœ… **Playwright å¼ºå¤§è€Œçµæ´»**ï¼šæ”¯æŒå¤šæµè§ˆå™¨ã€è‡ªåŠ¨ç­‰å¾…ã€ç½‘ç»œæ‹¦æˆªç­‰é«˜çº§åŠŸèƒ½
âœ… **Accessibility Tree æ˜¯æ ¸å¿ƒ**ï¼šæä¾›ç®€æ´çš„é¡µé¢ç»“æ„ï¼Œä¾¿äº AI ç†è§£å’Œæ“ä½œ
âœ… **MCP åè®®æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€çš„æ¥å£ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
âœ… **å®æˆ˜åº”ç”¨å¹¿æ³›**ï¼šæµ‹è¯•ã€çˆ¬è™«ã€ç›‘æ§ã€è‡ªåŠ¨åŒ–è¿ç»´ç­‰

### æ ¸å¿ƒæµç¨‹

```mermaid
graph LR
    A[å¯åŠ¨æµè§ˆå™¨] --> B[å¯¼èˆªåˆ°é¡µé¢]
    B --> C[è·å–é¡µé¢å¿«ç…§]
    C --> D[AIåˆ†æé¡µé¢]
    D --> E[å®šä½å…ƒç´ ]
    E --> F[æ‰§è¡Œæ“ä½œ]
    F --> G[éªŒè¯ç»“æœ]
    G --> H[ç”ŸæˆæŠ¥å‘Š]

    style A fill:#e1f5ff
    style D fill:#ffe1f5
    style H fill:#e1ffe1
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

1. é˜…è¯»ä¸‹ä¸€ç¯‡æ–‡ç« ï¼Œæ·±å…¥äº†è§£å…¶ä»– MCP å·¥å…·
2. å°è¯•ç¼–å†™è‡ªå·±çš„è‡ªåŠ¨åŒ–è„šæœ¬
3. å°†æµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆåˆ° CI/CD æµç¨‹

---

**æµè§ˆå™¨è‡ªåŠ¨åŒ–è®© AI èƒ½å¤ŸçœŸæ­£ä¸ Web ä¸–ç•Œäº¤äº’ï¼Œå¼€å¯æ— é™å¯èƒ½ï¼** ğŸš€
