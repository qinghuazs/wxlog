---
title: é›†æˆç¬¬ä¸‰æ–¹æœåŠ¡
date: 2025-01-13
permalink: /claudecode/architecture/third-party-integration.html
tags:
  - Claude Code
  - ç¬¬ä¸‰æ–¹æœåŠ¡
  - APIé›†æˆ
categories:
  - AI
  - Claude Code
  - æ¶æ„è¯¦è§£
---

# é›†æˆç¬¬ä¸‰æ–¹æœåŠ¡

## 1. å¼•è¨€ï¼šç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆçš„ä»·å€¼

åœ¨ç°ä»£è½¯ä»¶å¼€å‘ä¸­ï¼Œç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆå·²æˆä¸ºæå‡å¼€å‘æ•ˆç‡çš„å…³é”®èƒ½åŠ›ã€‚Claude Code é€šè¿‡ MCPï¼ˆModel Context Protocolï¼‰æœºåˆ¶ï¼Œæä¾›äº†å¼ºå¤§çš„ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆèƒ½åŠ›ï¼Œä½¿ AI åŠ©æ‰‹èƒ½å¤Ÿæ— ç¼å¯¹æ¥å„ç±»å¼€å‘å·¥å…·å’Œäº‘æœåŠ¡ã€‚

### 1.1 é›†æˆæœåŠ¡çš„ä»·å€¼

ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆä¸º Claude Code å¸¦æ¥äº†ä»¥ä¸‹æ ¸å¿ƒä»·å€¼ï¼š

**å¼€å‘æ•ˆç‡æå‡**ï¼šé€šè¿‡é›†æˆ GitHubã€Jira ç­‰é¡¹ç›®ç®¡ç†å·¥å…·ï¼ŒAI åŠ©æ‰‹å¯ä»¥ç›´æ¥åˆ›å»º Issueã€æäº¤ PRã€æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼Œå¤§å¹…å‡å°‘å¼€å‘è€…åœ¨å·¥å…·é—´åˆ‡æ¢çš„æ—¶é—´æˆæœ¬ã€‚

**å·¥ä½œæµè‡ªåŠ¨åŒ–**ï¼šé›†æˆ Slackã€Discord ç­‰é€šè®¯å·¥å…·ï¼Œå®ç°ä»£ç è¯„å®¡é€šçŸ¥ã€æ„å»ºçŠ¶æ€æ¨é€ç­‰è‡ªåŠ¨åŒ–æµç¨‹ï¼Œè®©å›¢é˜Ÿåä½œæ›´åŠ é«˜æ•ˆã€‚

**æ•°æ®è®¿é—®èƒ½åŠ›**ï¼šé€šè¿‡æ•°æ®åº“è¿æ¥ï¼ŒAI åŠ©æ‰‹å¯ä»¥æŸ¥è¯¢ç”Ÿäº§æ•°æ®ã€åˆ†ææ•°æ®æ¨¡å¼ã€ç”Ÿæˆæ•°æ®è¿ç§»è„šæœ¬ï¼Œæä¾›æ›´ç²¾å‡†çš„æŠ€æœ¯å»ºè®®ã€‚

**äº‘èµ„æºç®¡ç†**ï¼šé›†æˆ AWSã€Azure ç­‰äº‘æœåŠ¡ï¼Œæ”¯æŒæ–‡ä»¶ä¸Šä¼ ä¸‹è½½ã€èµ„æºé…ç½®æŸ¥è¯¢ç­‰æ“ä½œï¼Œå®ç°åŸºç¡€è®¾æ–½å³ä»£ç çš„æ™ºèƒ½åŒ–ç®¡ç†ã€‚

### 1.2 MCP é›†æˆæ¶æ„

Claude Code çš„ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆåŸºäº MCP åè®®å®ç°ï¼Œé‡‡ç”¨æ ‡å‡†åŒ–çš„å·¥å…·è°ƒç”¨æ¥å£ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Claude Model   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
    â”‚   MCP    â”‚
    â”‚ Protocol â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Service Providers          â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ GitHub â”‚ Jira â”‚ Slack â”‚ AWS  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

é€šè¿‡ç»Ÿä¸€çš„ MCP æ¥å£ï¼Œå„ç±»æœåŠ¡ä»¥æ’ä»¶å½¢å¼æ¥å…¥ï¼Œä¿è¯äº†æ¶æ„çš„å¯æ‰©å±•æ€§å’Œç»´æŠ¤æ€§ã€‚

## 2. GitHub API é›†æˆ

GitHub æ˜¯å¼€å‘è€…æœ€å¸¸ç”¨çš„ä»£ç æ‰˜ç®¡å¹³å°ï¼ŒClaude Code æä¾›äº†å…¨é¢çš„ GitHub API é›†æˆèƒ½åŠ›ã€‚

### 2.1 GitHub REST API ä½¿ç”¨

GitHub API é›†æˆçš„æ ¸å¿ƒæ˜¯é€šè¿‡ Personal Access Token è¿›è¡Œèº«ä»½è®¤è¯ï¼Œç„¶åè°ƒç”¨ REST API å®Œæˆå„ç±»æ“ä½œã€‚

#### 2.1.1 è®¤è¯é…ç½®

```typescript
// github-service.ts
import { Octokit } from '@octokit/rest';

export class GitHubService {
  private octokit: Octokit;

  constructor(token: string) {
    this.octokit = new Octokit({
      auth: token,
      userAgent: 'claude-code-mcp/1.0.0',
      baseUrl: 'https://api.github.com',
      // è¯·æ±‚è¶…æ—¶é…ç½®
      request: {
        timeout: 10000
      }
    });
  }

  /**
   * éªŒè¯ Token æœ‰æ•ˆæ€§
   */
  async validateToken(): Promise<boolean> {
    try {
      await this.octokit.users.getAuthenticated();
      return true;
    } catch (error) {
      console.error('Token validation failed:', error);
      return false;
    }
  }
}
```

#### 2.1.2 ä»“åº“æ“ä½œ

```typescript
export class GitHubService {
  /**
   * è·å–ä»“åº“ä¿¡æ¯
   */
  async getRepository(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.get({
        owner,
        repo
      });

      return {
        id: data.id,
        name: data.name,
        fullName: data.full_name,
        description: data.description,
        defaultBranch: data.default_branch,
        language: data.language,
        stars: data.stargazers_count,
        forks: data.forks_count,
        openIssues: data.open_issues_count,
        createdAt: data.created_at,
        updatedAt: data.updated_at
      };
    } catch (error) {
      throw new Error(`Failed to get repository: ${error.message}`);
    }
  }

  /**
   * åˆ—å‡ºä»“åº“åˆ†æ”¯
   */
  async listBranches(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.listBranches({
        owner,
        repo,
        per_page: 100
      });

      return data.map(branch => ({
        name: branch.name,
        commit: {
          sha: branch.commit.sha,
          url: branch.commit.url
        },
        protected: branch.protected
      }));
    } catch (error) {
      throw new Error(`Failed to list branches: ${error.message}`);
    }
  }

  /**
   * åˆ›å»ºåˆ†æ”¯
   */
  async createBranch(
    owner: string,
    repo: string,
    branchName: string,
    fromBranch: string
  ) {
    try {
      // è·å–æºåˆ†æ”¯çš„ SHA
      const { data: refData } = await this.octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${fromBranch}`
      });

      // åˆ›å»ºæ–°åˆ†æ”¯
      const { data } = await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${branchName}`,
        sha: refData.object.sha
      });

      return {
        ref: data.ref,
        sha: data.object.sha
      };
    } catch (error) {
      throw new Error(`Failed to create branch: ${error.message}`);
    }
  }
}
```

### 2.2 Issuesã€PRsã€Actions ç®¡ç†

#### 2.2.1 Issue ç®¡ç†

```typescript
export class GitHubService {
  /**
   * åˆ›å»º Issue
   */
  async createIssue(
    owner: string,
    repo: string,
    options: {
      title: string;
      body?: string;
      assignees?: string[];
      labels?: string[];
      milestone?: number;
    }
  ) {
    try {
      const { data } = await this.octokit.issues.create({
        owner,
        repo,
        ...options
      });

      return {
        number: data.number,
        id: data.id,
        title: data.title,
        state: data.state,
        url: data.html_url,
        createdAt: data.created_at
      };
    } catch (error) {
      throw new Error(`Failed to create issue: ${error.message}`);
    }
  }

  /**
   * åˆ—å‡º Issues
   */
  async listIssues(
    owner: string,
    repo: string,
    options?: {
      state?: 'open' | 'closed' | 'all';
      labels?: string[];
      assignee?: string;
      since?: string;
    }
  ) {
    try {
      const { data } = await this.octokit.issues.listForRepo({
        owner,
        repo,
        state: options?.state || 'open',
        labels: options?.labels?.join(','),
        assignee: options?.assignee,
        since: options?.since,
        per_page: 100
      });

      return data.map(issue => ({
        number: issue.number,
        title: issue.title,
        state: issue.state,
        labels: issue.labels.map(l =>
          typeof l === 'string' ? l : l.name
        ),
        assignees: issue.assignees?.map(a => a.login) || [],
        createdAt: issue.created_at,
        updatedAt: issue.updated_at,
        url: issue.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list issues: ${error.message}`);
    }
  }

  /**
   * æ›´æ–° Issue
   */
  async updateIssue(
    owner: string,
    repo: string,
    issueNumber: number,
    options: {
      title?: string;
      body?: string;
      state?: 'open' | 'closed';
      labels?: string[];
      assignees?: string[];
    }
  ) {
    try {
      const { data } = await this.octokit.issues.update({
        owner,
        repo,
        issue_number: issueNumber,
        ...options
      });

      return {
        number: data.number,
        title: data.title,
        state: data.state,
        url: data.html_url
      };
    } catch (error) {
      throw new Error(`Failed to update issue: ${error.message}`);
    }
  }

  /**
   * æ·»åŠ  Issue è¯„è®º
   */
  async addIssueComment(
    owner: string,
    repo: string,
    issueNumber: number,
    body: string
  ) {
    try {
      const { data } = await this.octokit.issues.createComment({
        owner,
        repo,
        issue_number: issueNumber,
        body
      });

      return {
        id: data.id,
        body: data.body,
        createdAt: data.created_at,
        url: data.html_url
      };
    } catch (error) {
      throw new Error(`Failed to add comment: ${error.message}`);
    }
  }
}
```

#### 2.2.2 Pull Request ç®¡ç†

```typescript
export class GitHubService {
  /**
   * åˆ›å»º Pull Request
   */
  async createPullRequest(
    owner: string,
    repo: string,
    options: {
      title: string;
      head: string;
      base: string;
      body?: string;
      draft?: boolean;
      maintainerCanModify?: boolean;
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.create({
        owner,
        repo,
        ...options,
        maintainer_can_modify: options.maintainerCanModify
      });

      return {
        number: data.number,
        id: data.id,
        title: data.title,
        state: data.state,
        draft: data.draft,
        url: data.html_url,
        diffUrl: data.diff_url,
        patchUrl: data.patch_url
      };
    } catch (error) {
      throw new Error(`Failed to create PR: ${error.message}`);
    }
  }

  /**
   * åˆ—å‡º Pull Requests
   */
  async listPullRequests(
    owner: string,
    repo: string,
    options?: {
      state?: 'open' | 'closed' | 'all';
      head?: string;
      base?: string;
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.list({
        owner,
        repo,
        state: options?.state || 'open',
        head: options?.head,
        base: options?.base,
        per_page: 100
      });

      return data.map(pr => ({
        number: pr.number,
        title: pr.title,
        state: pr.state,
        draft: pr.draft,
        head: pr.head.ref,
        base: pr.base.ref,
        createdAt: pr.created_at,
        updatedAt: pr.updated_at,
        url: pr.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list PRs: ${error.message}`);
    }
  }

  /**
   * åˆå¹¶ Pull Request
   */
  async mergePullRequest(
    owner: string,
    repo: string,
    pullNumber: number,
    options?: {
      commitTitle?: string;
      commitMessage?: string;
      mergeMethod?: 'merge' | 'squash' | 'rebase';
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number: pullNumber,
        commit_title: options?.commitTitle,
        commit_message: options?.commitMessage,
        merge_method: options?.mergeMethod || 'merge'
      });

      return {
        merged: data.merged,
        sha: data.sha,
        message: data.message
      };
    } catch (error) {
      throw new Error(`Failed to merge PR: ${error.message}`);
    }
  }

  /**
   * è¯·æ±‚ PR è¯„å®¡
   */
  async requestReviewers(
    owner: string,
    repo: string,
    pullNumber: number,
    reviewers: string[],
    teamReviewers?: string[]
  ) {
    try {
      const { data } = await this.octokit.pulls.requestReviewers({
        owner,
        repo,
        pull_number: pullNumber,
        reviewers,
        team_reviewers: teamReviewers
      });

      return {
        requestedReviewers: data.requested_reviewers?.map(r => r.login) || [],
        requestedTeams: data.requested_teams?.map(t => t.name) || []
      };
    } catch (error) {
      throw new Error(`Failed to request reviewers: ${error.message}`);
    }
  }
}
```

#### 2.2.3 GitHub Actions ç®¡ç†

```typescript
export class GitHubService {
  /**
   * åˆ—å‡º Workflow Runs
   */
  async listWorkflowRuns(
    owner: string,
    repo: string,
    workflowId?: string | number
  ) {
    try {
      const params = workflowId
        ? { owner, repo, workflow_id: workflowId, per_page: 100 }
        : { owner, repo, per_page: 100 };

      const { data } = workflowId
        ? await this.octokit.actions.listWorkflowRuns(params)
        : await this.octokit.actions.listWorkflowRunsForRepo(params);

      return data.workflow_runs.map(run => ({
        id: run.id,
        name: run.name,
        headBranch: run.head_branch,
        status: run.status,
        conclusion: run.conclusion,
        createdAt: run.created_at,
        updatedAt: run.updated_at,
        url: run.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list workflow runs: ${error.message}`);
    }
  }

  /**
   * è§¦å‘ Workflow
   */
  async triggerWorkflow(
    owner: string,
    repo: string,
    workflowId: string | number,
    ref: string,
    inputs?: Record<string, any>
  ) {
    try {
      await this.octokit.actions.createWorkflowDispatch({
        owner,
        repo,
        workflow_id: workflowId,
        ref,
        inputs
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to trigger workflow: ${error.message}`);
    }
  }

  /**
   * å–æ¶ˆ Workflow Run
   */
  async cancelWorkflowRun(
    owner: string,
    repo: string,
    runId: number
  ) {
    try {
      await this.octokit.actions.cancelWorkflowRun({
        owner,
        repo,
        run_id: runId
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to cancel workflow: ${error.message}`);
    }
  }
}
```

### 2.3 MCP å·¥å…·å°è£…

```typescript
// github-mcp-tools.ts
import { GitHubService } from './github-service';

export const githubTools = {
  github_create_issue: {
    description: 'Create a new GitHub issue',
    parameters: {
      type: 'object',
      properties: {
        owner: { type: 'string', description: 'Repository owner' },
        repo: { type: 'string', description: 'Repository name' },
        title: { type: 'string', description: 'Issue title' },
        body: { type: 'string', description: 'Issue body' },
        labels: {
          type: 'array',
          items: { type: 'string' },
          description: 'Issue labels'
        }
      },
      required: ['owner', 'repo', 'title']
    },
    handler: async (params: any) => {
      const service = new GitHubService(process.env.GITHUB_TOKEN!);
      return await service.createIssue(
        params.owner,
        params.repo,
        {
          title: params.title,
          body: params.body,
          labels: params.labels
        }
      );
    }
  },

  github_create_pr: {
    description: 'Create a new pull request',
    parameters: {
      type: 'object',
      properties: {
        owner: { type: 'string', description: 'Repository owner' },
        repo: { type: 'string', description: 'Repository name' },
        title: { type: 'string', description: 'PR title' },
        head: { type: 'string', description: 'Head branch' },
        base: { type: 'string', description: 'Base branch' },
        body: { type: 'string', description: 'PR body' },
        draft: { type: 'boolean', description: 'Create as draft' }
      },
      required: ['owner', 'repo', 'title', 'head', 'base']
    },
    handler: async (params: any) => {
      const service = new GitHubService(process.env.GITHUB_TOKEN!);
      return await service.createPullRequest(
        params.owner,
        params.repo,
        {
          title: params.title,
          head: params.head,
          base: params.base,
          body: params.body,
          draft: params.draft
        }
      );
    }
  }
};
```

## 3. Jira/Linear é›†æˆ

é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆæ˜¯å›¢é˜Ÿåä½œçš„å…³é”®ï¼ŒClaude Code æ”¯æŒä¸»æµçš„ Jira å’Œ Linear å¹³å°ã€‚

### 3.1 Jira API é›†æˆ

```typescript
// jira-service.ts
import axios, { AxiosInstance } from 'axios';

export class JiraService {
  private client: AxiosInstance;

  constructor(
    domain: string,
    email: string,
    apiToken: string
  ) {
    this.client = axios.create({
      baseURL: `https://${domain}/rest/api/3`,
      auth: {
        username: email,
        password: apiToken
      },
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      timeout: 10000
    });
  }

  /**
   * åˆ›å»º Issue
   */
  async createIssue(options: {
    projectKey: string;
    summary: string;
    description?: string;
    issueType: string;
    priority?: string;
    assignee?: string;
    labels?: string[];
  }) {
    try {
      const payload = {
        fields: {
          project: {
            key: options.projectKey
          },
          summary: options.summary,
          description: options.description ? {
            type: 'doc',
            version: 1,
            content: [
              {
                type: 'paragraph',
                content: [
                  {
                    type: 'text',
                    text: options.description
                  }
                ]
              }
            ]
          } : undefined,
          issuetype: {
            name: options.issueType
          },
          priority: options.priority ? {
            name: options.priority
          } : undefined,
          assignee: options.assignee ? {
            accountId: options.assignee
          } : undefined,
          labels: options.labels
        }
      };

      const response = await this.client.post('/issue', payload);

      return {
        id: response.data.id,
        key: response.data.key,
        url: `${this.client.defaults.baseURL?.replace('/rest/api/3', '')}/browse/${response.data.key}`
      };
    } catch (error) {
      throw new Error(`Failed to create Jira issue: ${error.message}`);
    }
  }

  /**
   * æœç´¢ Issues
   */
  async searchIssues(jql: string, fields?: string[]) {
    try {
      const response = await this.client.post('/search', {
        jql,
        fields: fields || ['summary', 'status', 'assignee', 'created', 'updated'],
        maxResults: 100
      });

      return response.data.issues.map((issue: any) => ({
        id: issue.id,
        key: issue.key,
        summary: issue.fields.summary,
        status: issue.fields.status.name,
        assignee: issue.fields.assignee?.displayName,
        created: issue.fields.created,
        updated: issue.fields.updated
      }));
    } catch (error) {
      throw new Error(`Failed to search Jira issues: ${error.message}`);
    }
  }

  /**
   * æ›´æ–° Issue çŠ¶æ€
   */
  async transitionIssue(issueKey: string, transitionId: string) {
    try {
      await this.client.post(`/issue/${issueKey}/transitions`, {
        transition: {
          id: transitionId
        }
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to transition issue: ${error.message}`);
    }
  }

  /**
   * æ·»åŠ è¯„è®º
   */
  async addComment(issueKey: string, body: string) {
    try {
      const response = await this.client.post(
        `/issue/${issueKey}/comment`,
        {
          body: {
            type: 'doc',
            version: 1,
            content: [
              {
                type: 'paragraph',
                content: [
                  {
                    type: 'text',
                    text: body
                  }
                ]
              }
            ]
          }
        }
      );

      return {
        id: response.data.id,
        created: response.data.created
      };
    } catch (error) {
      throw new Error(`Failed to add comment: ${error.message}`);
    }
  }
}
```

### 3.2 Linear API é›†æˆ

```typescript
// linear-service.ts
import { LinearClient } from '@linear/sdk';

export class LinearService {
  private client: LinearClient;

  constructor(apiKey: string) {
    this.client = new LinearClient({
      apiKey
    });
  }

  /**
   * åˆ›å»º Issue
   */
  async createIssue(options: {
    teamId: string;
    title: string;
    description?: string;
    priority?: number;
    assigneeId?: string;
    labelIds?: string[];
  }) {
    try {
      const issue = await this.client.createIssue({
        teamId: options.teamId,
        title: options.title,
        description: options.description,
        priority: options.priority,
        assigneeId: options.assigneeId,
        labelIds: options.labelIds
      });

      return {
        id: issue.issue?.id,
        identifier: issue.issue?.identifier,
        url: issue.issue?.url
      };
    } catch (error) {
      throw new Error(`Failed to create Linear issue: ${error.message}`);
    }
  }

  /**
   * æœç´¢ Issues
   */
  async searchIssues(filter: {
    teamId?: string;
    assigneeId?: string;
    state?: string;
  }) {
    try {
      const issues = await this.client.issues({
        filter: {
          team: filter.teamId ? { id: { eq: filter.teamId } } : undefined,
          assignee: filter.assigneeId ? { id: { eq: filter.assigneeId } } : undefined,
          state: filter.state ? { name: { eq: filter.state } } : undefined
        }
      });

      const nodes = await issues.nodes;

      return nodes.map(issue => ({
        id: issue.id,
        identifier: issue.identifier,
        title: issue.title,
        state: issue.state?.name,
        assignee: issue.assignee?.name,
        priority: issue.priority,
        url: issue.url
      }));
    } catch (error) {
      throw new Error(`Failed to search Linear issues: ${error.message}`);
    }
  }

  /**
   * æ›´æ–° Issue
   */
  async updateIssue(
    issueId: string,
    updates: {
      title?: string;
      description?: string;
      stateId?: string;
      assigneeId?: string;
      priority?: number;
    }
  ) {
    try {
      const result = await this.client.updateIssue(issueId, updates);

      return {
        success: result.success,
        issue: result.issue
      };
    } catch (error) {
      throw new Error(`Failed to update Linear issue: ${error.message}`);
    }
  }
}
```

### 3.3 å·¥ä½œæµè‡ªåŠ¨åŒ–ç¤ºä¾‹

```typescript
// workflow-automation.ts
import { GitHubService } from './github-service';
import { JiraService } from './jira-service';

export class WorkflowAutomation {
  constructor(
    private github: GitHubService,
    private jira: JiraService
  ) {}

  /**
   * PR åˆ›å»ºæ—¶è‡ªåŠ¨åˆ›å»º Jira Issue
   */
  async onPullRequestCreated(
    owner: string,
    repo: string,
    prNumber: number
  ) {
    try {
      // è·å– PR ä¿¡æ¯
      const pr = await this.github.octokit.pulls.get({
        owner,
        repo,
        pull_number: prNumber
      });

      // åˆ›å»º Jira Issue
      const issue = await this.jira.createIssue({
        projectKey: 'DEV',
        summary: `[PR-${prNumber}] ${pr.data.title}`,
        description: pr.data.body || '',
        issueType: 'Task',
        labels: ['code-review']
      });

      // åœ¨ PR ä¸­æ·»åŠ è¯„è®ºï¼Œé“¾æ¥ Jira Issue
      await this.github.addIssueComment(
        owner,
        repo,
        prNumber,
        `Jira Issue created: ${issue.url}`
      );

      return issue;
    } catch (error) {
      console.error('Workflow automation failed:', error);
      throw error;
    }
  }

  /**
   * PR åˆå¹¶åè‡ªåŠ¨æ›´æ–° Jira Issue çŠ¶æ€
   */
  async onPullRequestMerged(
    owner: string,
    repo: string,
    prNumber: number,
    jiraIssueKey: string
  ) {
    try {
      // æ·»åŠ  Jira è¯„è®º
      await this.jira.addComment(
        jiraIssueKey,
        `Pull Request #${prNumber} has been merged into ${repo}`
      );

      // è½¬æ¢ Issue çŠ¶æ€åˆ° "Done"
      await this.jira.transitionIssue(jiraIssueKey, '31'); // 31 = Done

      return { success: true };
    } catch (error) {
      console.error('Failed to update Jira issue:', error);
      throw error;
    }
  }
}
```

## 4. Slack/Discord é›†æˆ

é€šè®¯å·¥å…·é›†æˆæ˜¯å›¢é˜Ÿåä½œé€šçŸ¥çš„é‡è¦æ¸ é“ã€‚

### 4.1 Slack Webhook é›†æˆ

```typescript
// slack-service.ts
import axios from 'axios';

export class SlackService {
  constructor(private webhookUrl: string) {}

  /**
   * å‘é€ç®€å•æ¶ˆæ¯
   */
  async sendMessage(text: string) {
    try {
      await axios.post(this.webhookUrl, {
        text
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send Slack message: ${error.message}`);
    }
  }

  /**
   * å‘é€æ ¼å¼åŒ–æ¶ˆæ¯
   */
  async sendFormattedMessage(options: {
    text: string;
    blocks?: any[];
    attachments?: any[];
  }) {
    try {
      await axios.post(this.webhookUrl, {
        text: options.text,
        blocks: options.blocks,
        attachments: options.attachments
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send formatted message: ${error.message}`);
    }
  }

  /**
   * å‘é€ä»£ç è¯„å®¡é€šçŸ¥
   */
  async sendCodeReviewNotification(options: {
    prTitle: string;
    prUrl: string;
    author: string;
    reviewers: string[];
  }) {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'æ–°çš„ä»£ç è¯„å®¡è¯·æ±‚'
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*PR æ ‡é¢˜:*\n${options.prTitle}`
          },
          {
            type: 'mrkdwn',
            text: `*ä½œè€…:*\n${options.author}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*è¯„å®¡äºº:*\n${options.reviewers.join(', ')}`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'æŸ¥çœ‹ PR'
            },
            url: options.prUrl,
            style: 'primary'
          }
        ]
      }
    ];

    return this.sendFormattedMessage({
      text: `æ–°çš„ä»£ç è¯„å®¡: ${options.prTitle}`,
      blocks
    });
  }

  /**
   * å‘é€æ„å»ºçŠ¶æ€é€šçŸ¥
   */
  async sendBuildNotification(options: {
    repo: string;
    branch: string;
    status: 'success' | 'failure' | 'cancelled';
    buildUrl: string;
  }) {
    const statusEmoji = {
      success: 'âœ…',
      failure: 'âŒ',
      cancelled: 'â¸ï¸'
    };

    const statusColor = {
      success: 'good',
      failure: 'danger',
      cancelled: 'warning'
    };

    const attachments = [
      {
        color: statusColor[options.status],
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `${statusEmoji[options.status]} *æ„å»º ${options.status}*`
            }
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*ä»“åº“:*\n${options.repo}`
              },
              {
                type: 'mrkdwn',
                text: `*åˆ†æ”¯:*\n${options.branch}`
              }
            ]
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'æŸ¥çœ‹æ„å»º'
                },
                url: options.buildUrl
              }
            ]
          }
        ]
      }
    ];

    return this.sendFormattedMessage({
      text: `æ„å»º ${options.status}: ${options.repo}`,
      attachments
    });
  }
}
```

### 4.2 Slack Bot å¼€å‘

```typescript
// slack-bot.ts
import { App } from '@slack/bolt';

export class SlackBot {
  private app: App;

  constructor(token: string, signingSecret: string) {
    this.app = new App({
      token,
      signingSecret
    });

    this.setupHandlers();
  }

  private setupHandlers() {
    // ç›‘å¬ /deploy å‘½ä»¤
    this.app.command('/deploy', async ({ command, ack, say }) => {
      await ack();

      try {
        const [env, branch] = command.text.split(' ');

        await say({
          text: `æ­£åœ¨éƒ¨ç½² ${branch} åˆ° ${env} ç¯å¢ƒ...`,
          thread_ts: command.ts
        });

        // è§¦å‘éƒ¨ç½²æµç¨‹
        // await deployService.deploy(env, branch);

        await say({
          text: `âœ… éƒ¨ç½²æˆåŠŸï¼`,
          thread_ts: command.ts
        });
      } catch (error) {
        await say({
          text: `âŒ éƒ¨ç½²å¤±è´¥: ${error.message}`,
          thread_ts: command.ts
        });
      }
    });

    // ç›‘å¬æ¶ˆæ¯äº‹ä»¶
    this.app.message(/code review/i, async ({ message, say }) => {
      await say({
        text: 'éœ€è¦ä»£ç è¯„å®¡å—ï¼Ÿè¯·ä½¿ç”¨ `/review <pr-url>` å‘½ä»¤ã€‚',
        thread_ts: (message as any).ts
      });
    });

    // ç›‘å¬å¿«æ·æ–¹å¼
    this.app.shortcut('approve_pr', async ({ shortcut, ack, client }) => {
      await ack();

      // å¤„ç† PR æ‰¹å‡†é€»è¾‘
      await client.views.open({
        trigger_id: shortcut.trigger_id,
        view: {
          type: 'modal',
          title: {
            type: 'plain_text',
            text: 'æ‰¹å‡† PR'
          },
          blocks: [
            {
              type: 'input',
              block_id: 'comment_block',
              label: {
                type: 'plain_text',
                text: 'è¯„è®º'
              },
              element: {
                type: 'plain_text_input',
                action_id: 'comment',
                multiline: true
              }
            }
          ],
          submit: {
            type: 'plain_text',
            text: 'æäº¤'
          }
        }
      });
    });
  }

  async start(port: number = 3000) {
    await this.app.start(port);
    console.log(`âš¡ï¸ Slack bot is running on port ${port}`);
  }
}
```

### 4.3 Discord Webhook é›†æˆ

```typescript
// discord-service.ts
import axios from 'axios';

export class DiscordService {
  constructor(private webhookUrl: string) {}

  /**
   * å‘é€æ¶ˆæ¯
   */
  async sendMessage(options: {
    content?: string;
    embeds?: any[];
    username?: string;
    avatarUrl?: string;
  }) {
    try {
      await axios.post(this.webhookUrl, {
        content: options.content,
        embeds: options.embeds,
        username: options.username,
        avatar_url: options.avatarUrl
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send Discord message: ${error.message}`);
    }
  }

  /**
   * å‘é€ PR é€šçŸ¥
   */
  async sendPRNotification(options: {
    prTitle: string;
    prUrl: string;
    author: string;
    description: string;
  }) {
    const embed = {
      title: options.prTitle,
      url: options.prUrl,
      description: options.description,
      color: 0x0099ff,
      author: {
        name: options.author
      },
      fields: [
        {
          name: 'çŠ¶æ€',
          value: 'å¾…è¯„å®¡',
          inline: true
        }
      ],
      timestamp: new Date().toISOString()
    };

    return this.sendMessage({
      content: '@here æ–°çš„ PR éœ€è¦è¯„å®¡',
      embeds: [embed]
    });
  }

  /**
   * å‘é€éƒ¨ç½²é€šçŸ¥
   */
  async sendDeploymentNotification(options: {
    environment: string;
    version: string;
    status: 'started' | 'success' | 'failed';
    deployedBy: string;
  }) {
    const statusColors = {
      started: 0xffa500, // Orange
      success: 0x00ff00, // Green
      failed: 0xff0000   // Red
    };

    const statusEmojis = {
      started: 'ğŸš€',
      success: 'âœ…',
      failed: 'âŒ'
    };

    const embed = {
      title: `${statusEmojis[options.status]} éƒ¨ç½² ${options.status}`,
      color: statusColors[options.status],
      fields: [
        {
          name: 'ç¯å¢ƒ',
          value: options.environment,
          inline: true
        },
        {
          name: 'ç‰ˆæœ¬',
          value: options.version,
          inline: true
        },
        {
          name: 'éƒ¨ç½²äºº',
          value: options.deployedBy,
          inline: true
        }
      ],
      timestamp: new Date().toISOString()
    };

    return this.sendMessage({
      embeds: [embed]
    });
  }
}
```

## 5. æ•°æ®åº“è¿æ¥

æ•°æ®åº“é›†æˆä½¿ AI åŠ©æ‰‹èƒ½å¤ŸæŸ¥è¯¢å’Œåˆ†ææ•°æ®ã€‚

### 5.1 MySQL/PostgreSQL è¿æ¥

```typescript
// mysql-service.ts
import mysql from 'mysql2/promise';

export class MySQLService {
  private pool: mysql.Pool;

  constructor(config: {
    host: string;
    port?: number;
    user: string;
    password: string;
    database: string;
  }) {
    this.pool = mysql.createPool({
      ...config,
      port: config.port || 3306,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0
    });
  }

  /**
   * æ‰§è¡ŒæŸ¥è¯¢
   */
  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {
    try {
      const [rows] = await this.pool.execute(sql, params);
      return rows as T[];
    } catch (error) {
      throw new Error(`Query failed: ${error.message}`);
    }
  }

  /**
   * è·å–è¡¨ç»“æ„
   */
  async getTableSchema(tableName: string) {
    const columns = await this.query(`
      SELECT
        COLUMN_NAME as name,
        DATA_TYPE as type,
        IS_NULLABLE as nullable,
        COLUMN_KEY as key,
        COLUMN_DEFAULT as defaultValue,
        EXTRA as extra
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = ?
      ORDER BY ORDINAL_POSITION
    `, [tableName]);

    return columns;
  }

  /**
   * åˆ—å‡ºæ‰€æœ‰è¡¨
   */
  async listTables() {
    const tables = await this.query(`
      SELECT TABLE_NAME as name
      FROM INFORMATION_SCHEMA.TABLES
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_TYPE = 'BASE TABLE'
      ORDER BY TABLE_NAME
    `);

    return tables;
  }

  /**
   * è·å–è¡¨ç´¢å¼•
   */
  async getTableIndexes(tableName: string) {
    const indexes = await this.query(`
      SELECT
        INDEX_NAME as name,
        COLUMN_NAME as column,
        NON_UNIQUE as nonUnique,
        INDEX_TYPE as type
      FROM INFORMATION_SCHEMA.STATISTICS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = ?
      ORDER BY INDEX_NAME, SEQ_IN_INDEX
    `, [tableName]);

    return indexes;
  }

  /**
   * å…³é—­è¿æ¥æ± 
   */
  async close() {
    await this.pool.end();
  }
}
```

```typescript
// postgres-service.ts
import { Pool } from 'pg';

export class PostgresService {
  private pool: Pool;

  constructor(config: {
    host: string;
    port?: number;
    user: string;
    password: string;
    database: string;
  }) {
    this.pool = new Pool({
      ...config,
      port: config.port || 5432,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
  }

  /**
   * æ‰§è¡ŒæŸ¥è¯¢
   */
  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {
    try {
      const result = await this.pool.query(sql, params);
      return result.rows;
    } catch (error) {
      throw new Error(`Query failed: ${error.message}`);
    }
  }

  /**
   * è·å–è¡¨ç»“æ„
   */
  async getTableSchema(tableName: string) {
    const columns = await this.query(`
      SELECT
        column_name as name,
        data_type as type,
        is_nullable as nullable,
        column_default as "defaultValue"
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = $1
      ORDER BY ordinal_position
    `, [tableName]);

    return columns;
  }

  /**
   * åˆ—å‡ºæ‰€æœ‰è¡¨
   */
  async listTables() {
    const tables = await this.query(`
      SELECT tablename as name
      FROM pg_tables
      WHERE schemaname = 'public'
      ORDER BY tablename
    `);

    return tables;
  }

  /**
   * å…³é—­è¿æ¥æ± 
   */
  async close() {
    await this.pool.end();
  }
}
```

### 5.2 MongoDB é›†æˆ

```typescript
// mongodb-service.ts
import { MongoClient, Db, Collection } from 'mongodb';

export class MongoDBService {
  private client: MongoClient;
  private db: Db | null = null;

  constructor(private uri: string, private dbName: string) {
    this.client = new MongoClient(uri);
  }

  /**
   * è¿æ¥æ•°æ®åº“
   */
  async connect() {
    try {
      await this.client.connect();
      this.db = this.client.db(this.dbName);
      console.log(`Connected to MongoDB: ${this.dbName}`);
    } catch (error) {
      throw new Error(`MongoDB connection failed: ${error.message}`);
    }
  }

  /**
   * è·å–é›†åˆ
   */
  getCollection<T = any>(name: string): Collection<T> {
    if (!this.db) {
      throw new Error('Database not connected');
    }
    return this.db.collection<T>(name);
  }

  /**
   * æŸ¥è¯¢æ–‡æ¡£
   */
  async find<T = any>(
    collectionName: string,
    filter: any = {},
    options?: {
      limit?: number;
      skip?: number;
      sort?: any;
    }
  ): Promise<T[]> {
    const collection = this.getCollection<T>(collectionName);

    let cursor = collection.find(filter);

    if (options?.sort) {
      cursor = cursor.sort(options.sort);
    }
    if (options?.skip) {
      cursor = cursor.skip(options.skip);
    }
    if (options?.limit) {
      cursor = cursor.limit(options.limit);
    }

    return cursor.toArray();
  }

  /**
   * æ’å…¥æ–‡æ¡£
   */
  async insertOne<T = any>(
    collectionName: string,
    document: T
  ) {
    const collection = this.getCollection<T>(collectionName);
    const result = await collection.insertOne(document as any);

    return {
      insertedId: result.insertedId,
      acknowledged: result.acknowledged
    };
  }

  /**
   * æ›´æ–°æ–‡æ¡£
   */
  async updateOne<T = any>(
    collectionName: string,
    filter: any,
    update: any
  ) {
    const collection = this.getCollection<T>(collectionName);
    const result = await collection.updateOne(filter, update);

    return {
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
      acknowledged: result.acknowledged
    };
  }

  /**
   * åˆ é™¤æ–‡æ¡£
   */
  async deleteOne(
    collectionName: string,
    filter: any
  ) {
    const collection = this.getCollection(collectionName);
    const result = await collection.deleteOne(filter);

    return {
      deletedCount: result.deletedCount,
      acknowledged: result.acknowledged
    };
  }

  /**
   * åˆ—å‡ºæ‰€æœ‰é›†åˆ
   */
  async listCollections() {
    if (!this.db) {
      throw new Error('Database not connected');
    }

    const collections = await this.db.listCollections().toArray();
    return collections.map(col => col.name);
  }

  /**
   * è·å–é›†åˆç»Ÿè®¡
   */
  async getCollectionStats(collectionName: string) {
    if (!this.db) {
      throw new Error('Database not connected');
    }

    const stats = await this.db.command({ collStats: collectionName });

    return {
      count: stats.count,
      size: stats.size,
      avgObjSize: stats.avgObjSize,
      storageSize: stats.storageSize,
      indexes: stats.nindexes
    };
  }

  /**
   * å…³é—­è¿æ¥
   */
  async close() {
    await this.client.close();
  }
}
```

### 5.3 æŸ¥è¯¢å·¥å…·å®‰å…¨å°è£…

```typescript
// database-query-tool.ts
export class DatabaseQueryTool {
  private allowedOperations = ['SELECT', 'SHOW', 'DESCRIBE'];

  /**
   * éªŒè¯ SQL å®‰å…¨æ€§
   */
  validateSQL(sql: string): { valid: boolean; error?: string } {
    const upperSQL = sql.trim().toUpperCase();

    // æ£€æŸ¥æ˜¯å¦åŒ…å«å±é™©æ“ä½œ
    const dangerousKeywords = [
      'DROP', 'DELETE', 'UPDATE', 'INSERT',
      'TRUNCATE', 'ALTER', 'CREATE', 'GRANT', 'REVOKE'
    ];

    for (const keyword of dangerousKeywords) {
      if (upperSQL.includes(keyword)) {
        return {
          valid: false,
          error: `Dangerous operation detected: ${keyword}`
        };
      }
    }

    // æ£€æŸ¥æ˜¯å¦ä»¥å…è®¸çš„æ“ä½œå¼€å¤´
    const isAllowed = this.allowedOperations.some(
      op => upperSQL.startsWith(op)
    );

    if (!isAllowed) {
      return {
        valid: false,
        error: 'Only SELECT, SHOW, and DESCRIBE queries are allowed'
      };
    }

    return { valid: true };
  }

  /**
   * å®‰å…¨æ‰§è¡ŒæŸ¥è¯¢
   */
  async executeSafeQuery(
    service: MySQLService | PostgresService,
    sql: string,
    params?: any[]
  ) {
    // éªŒè¯ SQL
    const validation = this.validateSQL(sql);
    if (!validation.valid) {
      throw new Error(`Query validation failed: ${validation.error}`);
    }

    try {
      const results = await service.query(sql, params);

      // é™åˆ¶è¿”å›ç»“æœæ•°é‡
      const maxRows = 1000;
      if (results.length > maxRows) {
        return {
          rows: results.slice(0, maxRows),
          truncated: true,
          totalRows: results.length
        };
      }

      return {
        rows: results,
        truncated: false,
        totalRows: results.length
      };
    } catch (error) {
      throw new Error(`Query execution failed: ${error.message}`);
    }
  }
}
```

## 6. äº‘æœåŠ¡é›†æˆ

äº‘å­˜å‚¨æœåŠ¡é›†æˆä½¿ AI èƒ½å¤Ÿç®¡ç†æ–‡ä»¶å’Œèµ„æºã€‚

### 6.1 AWS S3 æ“ä½œ

```typescript
// s3-service.ts
import { S3Client, PutObjectCommand, GetObjectCommand,
         ListObjectsV2Command, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { Readable } from 'stream';

export class S3Service {
  private client: S3Client;

  constructor(
    region: string,
    accessKeyId: string,
    secretAccessKey: string
  ) {
    this.client = new S3Client({
      region,
      credentials: {
        accessKeyId,
        secretAccessKey
      }
    });
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶
   */
  async uploadFile(
    bucket: string,
    key: string,
    body: Buffer | Readable | string,
    options?: {
      contentType?: string;
      metadata?: Record<string, string>;
    }
  ) {
    try {
      const command = new PutObjectCommand({
        Bucket: bucket,
        Key: key,
        Body: body,
        ContentType: options?.contentType,
        Metadata: options?.metadata
      });

      await this.client.send(command);

      return {
        bucket,
        key,
        url: `https://${bucket}.s3.amazonaws.com/${key}`
      };
    } catch (error) {
      throw new Error(`S3 upload failed: ${error.message}`);
    }
  }

  /**
   * ä¸‹è½½æ–‡ä»¶
   */
  async downloadFile(bucket: string, key: string): Promise<Buffer> {
    try {
      const command = new GetObjectCommand({
        Bucket: bucket,
        Key: key
      });

      const response = await this.client.send(command);

      // å°† Stream è½¬æ¢ä¸º Buffer
      const chunks: Uint8Array[] = [];
      for await (const chunk of response.Body as Readable) {
        chunks.push(chunk);
      }

      return Buffer.concat(chunks);
    } catch (error) {
      throw new Error(`S3 download failed: ${error.message}`);
    }
  }

  /**
   * åˆ—å‡ºå¯¹è±¡
   */
  async listObjects(
    bucket: string,
    prefix?: string,
    maxKeys?: number
  ) {
    try {
      const command = new ListObjectsV2Command({
        Bucket: bucket,
        Prefix: prefix,
        MaxKeys: maxKeys || 1000
      });

      const response = await this.client.send(command);

      return {
        objects: response.Contents?.map(obj => ({
          key: obj.Key,
          size: obj.Size,
          lastModified: obj.LastModified,
          etag: obj.ETag
        })) || [],
        isTruncated: response.IsTruncated,
        nextContinuationToken: response.NextContinuationToken
      };
    } catch (error) {
      throw new Error(`S3 list failed: ${error.message}`);
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   */
  async deleteFile(bucket: string, key: string) {
    try {
      const command = new DeleteObjectCommand({
        Bucket: bucket,
        Key: key
      });

      await this.client.send(command);

      return { success: true };
    } catch (error) {
      throw new Error(`S3 delete failed: ${error.message}`);
    }
  }

  /**
   * ç”Ÿæˆé¢„ç­¾å URL
   */
  async getPresignedUrl(
    bucket: string,
    key: string,
    expiresIn: number = 3600
  ): Promise<string> {
    try {
      const command = new GetObjectCommand({
        Bucket: bucket,
        Key: key
      });

      const url = await getSignedUrl(this.client, command, { expiresIn });

      return url;
    } catch (error) {
      throw new Error(`Failed to generate presigned URL: ${error.message}`);
    }
  }
}
```

### 6.2 Azure Blob Storage

```typescript
// azure-blob-service.ts
import { BlobServiceClient, ContainerClient } from '@azure/storage-blob';

export class AzureBlobService {
  private blobServiceClient: BlobServiceClient;

  constructor(connectionString: string) {
    this.blobServiceClient = BlobServiceClient.fromConnectionString(
      connectionString
    );
  }

  /**
   * è·å–å®¹å™¨å®¢æˆ·ç«¯
   */
  private getContainerClient(containerName: string): ContainerClient {
    return this.blobServiceClient.getContainerClient(containerName);
  }

  /**
   * ä¸Šä¼  Blob
   */
  async uploadBlob(
    containerName: string,
    blobName: string,
    content: Buffer | Readable | string,
    options?: {
      contentType?: string;
      metadata?: Record<string, string>;
    }
  ) {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blockBlobClient = containerClient.getBlockBlobClient(blobName);

      const uploadOptions = {
        blobHTTPHeaders: {
          blobContentType: options?.contentType
        },
        metadata: options?.metadata
      };

      if (typeof content === 'string') {
        await blockBlobClient.upload(content, content.length, uploadOptions);
      } else if (Buffer.isBuffer(content)) {
        await blockBlobClient.upload(content, content.length, uploadOptions);
      } else {
        await blockBlobClient.uploadStream(content, undefined, undefined, uploadOptions);
      }

      return {
        container: containerName,
        blob: blobName,
        url: blockBlobClient.url
      };
    } catch (error) {
      throw new Error(`Azure Blob upload failed: ${error.message}`);
    }
  }

  /**
   * ä¸‹è½½ Blob
   */
  async downloadBlob(
    containerName: string,
    blobName: string
  ): Promise<Buffer> {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blobClient = containerClient.getBlobClient(blobName);

      const downloadResponse = await blobClient.download();

      if (!downloadResponse.readableStreamBody) {
        throw new Error('No readable stream in response');
      }

      const chunks: Uint8Array[] = [];
      for await (const chunk of downloadResponse.readableStreamBody) {
        chunks.push(chunk);
      }

      return Buffer.concat(chunks);
    } catch (error) {
      throw new Error(`Azure Blob download failed: ${error.message}`);
    }
  }

  /**
   * åˆ—å‡º Blobs
   */
  async listBlobs(containerName: string, prefix?: string) {
    try {
      const containerClient = this.getContainerClient(containerName);

      const blobs = [];
      for await (const blob of containerClient.listBlobsFlat({ prefix })) {
        blobs.push({
          name: blob.name,
          size: blob.properties.contentLength,
          lastModified: blob.properties.lastModified,
          contentType: blob.properties.contentType
        });
      }

      return blobs;
    } catch (error) {
      throw new Error(`Azure Blob list failed: ${error.message}`);
    }
  }

  /**
   * åˆ é™¤ Blob
   */
  async deleteBlob(containerName: string, blobName: string) {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blobClient = containerClient.getBlobClient(blobName);

      await blobClient.delete();

      return { success: true };
    } catch (error) {
      throw new Error(`Azure Blob delete failed: ${error.message}`);
    }
  }
}
```

### 6.3 æ–‡ä»¶ä¸Šä¼ ä¸‹è½½å·¥å…·

```typescript
// file-upload-tool.ts
import * as fs from 'fs';
import * as path from 'path';
import { S3Service } from './s3-service';
import { AzureBlobService } from './azure-blob-service';

export class FileUploadTool {
  constructor(
    private s3Service?: S3Service,
    private azureService?: AzureBlobService
  ) {}

  /**
   * ä¸Šä¼ æœ¬åœ°æ–‡ä»¶åˆ° S3
   */
  async uploadToS3(
    localPath: string,
    bucket: string,
    key?: string
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      // è¯»å–æ–‡ä»¶
      const fileBuffer = await fs.promises.readFile(localPath);
      const fileName = key || path.basename(localPath);

      // è·å– MIME ç±»å‹
      const contentType = this.getContentType(localPath);

      // ä¸Šä¼ åˆ° S3
      const result = await this.s3Service.uploadFile(
        bucket,
        fileName,
        fileBuffer,
        { contentType }
      );

      console.log(`File uploaded to S3: ${result.url}`);

      return result;
    } catch (error) {
      throw new Error(`Failed to upload file to S3: ${error.message}`);
    }
  }

  /**
   * ä» S3 ä¸‹è½½æ–‡ä»¶åˆ°æœ¬åœ°
   */
  async downloadFromS3(
    bucket: string,
    key: string,
    localPath: string
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      // ä» S3 ä¸‹è½½
      const fileBuffer = await this.s3Service.downloadFile(bucket, key);

      // ç¡®ä¿ç›®å½•å­˜åœ¨
      const dir = path.dirname(localPath);
      await fs.promises.mkdir(dir, { recursive: true });

      // å†™å…¥æ–‡ä»¶
      await fs.promises.writeFile(localPath, fileBuffer);

      console.log(`File downloaded from S3 to: ${localPath}`);

      return { localPath, size: fileBuffer.length };
    } catch (error) {
      throw new Error(`Failed to download file from S3: ${error.message}`);
    }
  }

  /**
   * ä¸Šä¼ ç›®å½•åˆ° S3
   */
  async uploadDirectoryToS3(
    localDir: string,
    bucket: string,
    prefix: string = ''
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      const results = [];
      const files = await this.getAllFiles(localDir);

      for (const file of files) {
        const relativePath = path.relative(localDir, file);
        const s3Key = path.join(prefix, relativePath).replace(/\\/g, '/');

        const result = await this.uploadToS3(file, bucket, s3Key);
        results.push(result);
      }

      return {
        uploadedFiles: results.length,
        files: results
      };
    } catch (error) {
      throw new Error(`Failed to upload directory: ${error.message}`);
    }
  }

  /**
   * é€’å½’è·å–æ‰€æœ‰æ–‡ä»¶
   */
  private async getAllFiles(dir: string): Promise<string[]> {
    const files: string[] = [];
    const entries = await fs.promises.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        const subFiles = await this.getAllFiles(fullPath);
        files.push(...subFiles);
      } else {
        files.push(fullPath);
      }
    }

    return files;
  }

  /**
   * è·å–æ–‡ä»¶ MIME ç±»å‹
   */
  private getContentType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      '.html': 'text/html',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.json': 'application/json',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.svg': 'image/svg+xml',
      '.pdf': 'application/pdf',
      '.txt': 'text/plain'
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }
}
```

## 7. æœ€ä½³å®è·µ

### 7.1 è®¤è¯å’Œå¯†é’¥ç®¡ç†

```typescript
// credential-manager.ts
import * as crypto from 'crypto';

export class CredentialManager {
  private encryptionKey: Buffer;

  constructor(masterPassword: string) {
    // ä»ä¸»å¯†ç ç”ŸæˆåŠ å¯†å¯†é’¥
    this.encryptionKey = crypto.scryptSync(masterPassword, 'salt', 32);
  }

  /**
   * åŠ å¯†å‡­è¯
   */
  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return iv.toString('hex') + ':' + encrypted;
  }

  /**
   * è§£å¯†å‡­è¯
   */
  decrypt(encrypted: string): string {
    const parts = encrypted.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encryptedText = parts[1];

    const decipher = crypto.createDecipheriv('aes-256-cbc', this.encryptionKey, iv);

    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  /**
   * å­˜å‚¨å‡­è¯
   */
  async storeCredential(
    service: string,
    credential: Record<string, any>
  ) {
    const encrypted = this.encrypt(JSON.stringify(credential));
    // å­˜å‚¨åˆ°å®‰å…¨å­˜å‚¨ï¼ˆå¦‚ç³»ç»Ÿå¯†é’¥é“¾ï¼‰
    // è¿™é‡Œç®€åŒ–ä¸ºç¯å¢ƒå˜é‡ç¤ºä¾‹
    process.env[`CREDENTIAL_${service.toUpperCase()}`] = encrypted;
  }

  /**
   * è·å–å‡­è¯
   */
  async getCredential(service: string): Promise<Record<string, any> | null> {
    const encrypted = process.env[`CREDENTIAL_${service.toUpperCase()}`];

    if (!encrypted) {
      return null;
    }

    const decrypted = this.decrypt(encrypted);
    return JSON.parse(decrypted);
  }
}
```

### 7.2 é”™è¯¯å¤„ç†å’Œé‡è¯•

```typescript
// retry-handler.ts
export class RetryHandler {
  /**
   * å¸¦é‡è¯•çš„è¯·æ±‚æ‰§è¡Œ
   */
  async executeWithRetry<T>(
    fn: () => Promise<T>,
    options: {
      maxRetries?: number;
      retryDelay?: number;
      backoff?: 'linear' | 'exponential';
      shouldRetry?: (error: any) => boolean;
    } = {}
  ): Promise<T> {
    const {
      maxRetries = 3,
      retryDelay = 1000,
      backoff = 'exponential',
      shouldRetry = () => true
    } = options;

    let lastError: any;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¯•
        if (attempt === maxRetries || !shouldRetry(error)) {
          throw error;
        }

        // è®¡ç®—å»¶è¿Ÿæ—¶é—´
        const delay = backoff === 'exponential'
          ? retryDelay * Math.pow(2, attempt)
          : retryDelay * (attempt + 1);

        console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);

        // ç­‰å¾…åé‡è¯•
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }
}
```

### 7.3 è¯·æ±‚é™æµ

```typescript
// rate-limiter.ts
export class RateLimiter {
  private tokens: number;
  private lastRefill: number;

  constructor(
    private maxTokens: number,
    private refillRate: number // tokens per second
  ) {
    this.tokens = maxTokens;
    this.lastRefill = Date.now();
  }

  /**
   * è¡¥å……ä»¤ç‰Œ
   */
  private refill() {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;

    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  /**
   * å°è¯•è·å–ä»¤ç‰Œ
   */
  async acquire(tokens: number = 1): Promise<void> {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return;
    }

    // è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´
    const tokensNeeded = tokens - this.tokens;
    const waitTime = (tokensNeeded / this.refillRate) * 1000;

    await new Promise(resolve => setTimeout(resolve, waitTime));

    this.tokens = 0;
  }
}
```

## 8. FAQ

### Q1: å¦‚ä½•é€‰æ‹©åˆé€‚çš„ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆæ–¹å¼ï¼Ÿ

**A**: é€‰æ‹©é›†æˆæ–¹å¼æ—¶éœ€è¦è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š

- **å®˜æ–¹ SDK vs REST API**: ä¼˜å…ˆä½¿ç”¨å®˜æ–¹ SDKï¼Œå¯ä»¥è·å¾—æ›´å¥½çš„ç±»å‹å®‰å…¨å’Œé”™è¯¯å¤„ç†
- **è®¤è¯æ–¹å¼**: è¯„ä¼° OAuthã€API Tokenã€Service Account ç­‰è®¤è¯æ–¹å¼çš„å®‰å…¨æ€§
- **æ€§èƒ½éœ€æ±‚**: è€ƒè™‘è¯·æ±‚é¢‘ç‡ã€æ•°æ®é‡ï¼Œé€‰æ‹©åˆé€‚çš„å®¢æˆ·ç«¯é…ç½®
- **ç»´æŠ¤æˆæœ¬**: SDK é€šå¸¸æœ‰æ›´å¥½çš„å‘åå…¼å®¹æ€§ï¼ŒREST API æ›´çµæ´»ä½†éœ€è¦æ‰‹åŠ¨å¤„ç†ç‰ˆæœ¬å˜æ›´

### Q2: å¦‚ä½•å¤„ç† API é™æµé—®é¢˜ï¼Ÿ

**A**: å»ºè®®é‡‡ç”¨ä»¥ä¸‹ç­–ç•¥ï¼š

```typescript
// å®ç°ä»¤ç‰Œæ¡¶ç®—æ³•
const limiter = new RateLimiter(100, 10); // 100ä¸ªä»¤ç‰Œï¼Œæ¯ç§’è¡¥å……10ä¸ª

// åœ¨è¯·æ±‚å‰è·å–ä»¤ç‰Œ
await limiter.acquire(1);
await apiService.makeRequest();
```

åŒæ—¶å»ºè®®ï¼š
- ç›‘æ§ API å“åº”å¤´ä¸­çš„é™æµä¿¡æ¯
- å®ç°æŒ‡æ•°é€€é¿é‡è¯•
- ä½¿ç”¨é˜Ÿåˆ—ç®¡ç†å¹¶å‘è¯·æ±‚

### Q3: å¦‚ä½•å®‰å…¨åœ°å­˜å‚¨ç¬¬ä¸‰æ–¹æœåŠ¡çš„å¯†é’¥ï¼Ÿ

**A**: æ¨èä»¥ä¸‹å®è·µï¼š

- **å¼€å‘ç¯å¢ƒ**: ä½¿ç”¨ `.env` æ–‡ä»¶ï¼Œä¸æäº¤åˆ°ä»£ç åº“
- **ç”Ÿäº§ç¯å¢ƒ**: ä½¿ç”¨äº‘æœåŠ¡çš„å¯†é’¥ç®¡ç†æœåŠ¡ï¼ˆAWS Secrets Managerã€Azure Key Vaultï¼‰
- **æœ¬åœ°å­˜å‚¨**: ä½¿ç”¨ç³»ç»Ÿå¯†é’¥é“¾ï¼ˆmacOS Keychainã€Windows Credential Managerï¼‰
- **åŠ å¯†å­˜å‚¨**: å¯¹å¯†é’¥è¿›è¡ŒåŠ å¯†åå†å­˜å‚¨ï¼Œä½¿ç”¨ä¸»å¯†ç è§£å¯†

### Q4: å¦‚ä½•å¤„ç†è·¨æœåŠ¡çš„äº‹åŠ¡ä¸€è‡´æ€§ï¼Ÿ

**A**: å¯¹äºéœ€è¦è·¨å¤šä¸ªæœåŠ¡çš„æ“ä½œï¼Œå»ºè®®ï¼š

```typescript
// å®ç°è¡¥å¿æœºåˆ¶
async function createIssueWithPR(options: any) {
  let prCreated = false;
  let issueCreated = false;

  try {
    // åˆ›å»º PR
    const pr = await github.createPullRequest(options.pr);
    prCreated = true;

    // åˆ›å»º Jira Issue
    const issue = await jira.createIssue(options.issue);
    issueCreated = true;

    return { pr, issue };
  } catch (error) {
    // å›æ»šå·²å®Œæˆçš„æ“ä½œ
    if (prCreated) {
      await github.closePullRequest(pr.number);
    }
    throw error;
  }
}
```

### Q5: å¦‚ä½•æµ‹è¯•ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆï¼Ÿ

**A**: å»ºè®®çš„æµ‹è¯•ç­–ç•¥ï¼š

- **å•å…ƒæµ‹è¯•**: ä½¿ç”¨ Mock å¯¹è±¡æ¨¡æ‹Ÿ API å“åº”
- **é›†æˆæµ‹è¯•**: ä½¿ç”¨æµ‹è¯•è´¦å·å’Œæ²™ç®±ç¯å¢ƒ
- **å¥‘çº¦æµ‹è¯•**: ä½¿ç”¨ Pact ç­‰å·¥å…·éªŒè¯ API å¥‘çº¦
- **ç«¯åˆ°ç«¯æµ‹è¯•**: åœ¨ staging ç¯å¢ƒè¿›è¡Œå®Œæ•´æµç¨‹æµ‹è¯•

## 9. æ€»ç»“

ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆæ˜¯ Claude Code æä¾›æ™ºèƒ½åŒ–å¼€å‘ä½“éªŒçš„é‡è¦åŸºç¡€ã€‚é€šè¿‡æœ¬æ–‡ï¼Œæˆ‘ä»¬æ·±å…¥äº†è§£äº†ï¼š

**æ ¸å¿ƒé›†æˆèƒ½åŠ›**ï¼šGitHub API æä¾›äº†å®Œæ•´çš„ä»£ç æ‰˜ç®¡æœåŠ¡é›†æˆï¼ŒåŒ…æ‹¬ä»“åº“ç®¡ç†ã€Issue/PR æ“ä½œã€Actions æ§åˆ¶ç­‰åŠŸèƒ½ï¼›Jira å’Œ Linear é›†æˆæ”¯æŒé¡¹ç›®ç®¡ç†è‡ªåŠ¨åŒ–ï¼›Slack å’Œ Discord é›†æˆå®ç°å›¢é˜Ÿé€šçŸ¥å’Œåä½œã€‚

**æ•°æ®è®¿é—®èƒ½åŠ›**ï¼šMySQLã€PostgreSQL å’Œ MongoDB é›†æˆä½¿ AI åŠ©æ‰‹èƒ½å¤ŸæŸ¥è¯¢æ•°æ®åº“ã€åˆ†ææ•°æ®æ¨¡å¼ï¼Œä¸ºå¼€å‘è€…æä¾›åŸºäºå®é™…æ•°æ®çš„å»ºè®®ã€‚å®‰å…¨æŸ¥è¯¢å°è£…ç¡®ä¿äº†åªè¯»æ“ä½œçš„å®‰å…¨æ€§ã€‚

**äº‘æœåŠ¡ç®¡ç†**ï¼šAWS S3 å’Œ Azure Blob Storage é›†æˆæ”¯æŒæ–‡ä»¶ä¸Šä¼ ä¸‹è½½ã€æ‰¹é‡æ“ä½œï¼Œå®ç°äº†äº‘èµ„æºçš„æ™ºèƒ½åŒ–ç®¡ç†ã€‚

**å®‰å…¨å’Œå¯é æ€§**ï¼šé€šè¿‡å‡­è¯åŠ å¯†å­˜å‚¨ã€è¯·æ±‚é‡è¯•æœºåˆ¶ã€é™æµæ§åˆ¶ç­‰æœ€ä½³å®è·µï¼Œç¡®ä¿äº†ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆçš„å®‰å…¨æ€§å’Œç¨³å®šæ€§ã€‚

æŒæ¡è¿™äº›é›†æˆæŠ€æœ¯ï¼Œèƒ½å¤Ÿè®©ä½ åœ¨ä½¿ç”¨ Claude Code æ—¶å……åˆ†å‘æŒ¥å…¶è‡ªåŠ¨åŒ–å’Œæ™ºèƒ½åŒ–ä¼˜åŠ¿ï¼Œæ˜¾è‘—æå‡å¼€å‘æ•ˆç‡ã€‚ä¸‹ä¸€ç¯‡æ–‡ç« å°†æ¢è®¨ã€Šæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‹ï¼Œåˆ†æ Claude Code å¦‚ä½•åœ¨ä¿è¯åŠŸèƒ½å®Œæ•´æ€§çš„åŒæ—¶å®ç°é«˜æ€§èƒ½ã€‚
