---
title: Claude Code æµ‹è¯•ä¸è´¨é‡ä¿è¯
date: 2025-01-13
permalink: /ai/claude-code/architecture/testing-quality-assurance.html
tags:
  - Claude Code
  - æµ‹è¯•
  - è´¨é‡ä¿è¯
  - CI/CD
categories:
  - AI
  - Claude Code
  - æ¶æ„è¯¦è§£
---

# Claude Code æµ‹è¯•ä¸è´¨é‡ä¿è¯

## 1. å¼•è¨€

åœ¨ Claude Code è¿™æ ·çš„å¤æ‚ AI ä»£ç åŠ©æ‰‹ç³»ç»Ÿä¸­ï¼Œæµ‹è¯•ä¸è´¨é‡ä¿è¯æ˜¯ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§ã€å¯é æ€§å’Œç”¨æˆ·ä½“éªŒçš„å…³é”®ç¯èŠ‚ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨ Claude Code çš„æµ‹è¯•ä½“ç³»æ¶æ„ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2E æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ä»¥åŠæŒç»­é›†æˆæµç¨‹ã€‚

### 1.1 æµ‹è¯•çš„é‡è¦æ€§

```mermaid
graph TD
    A[æµ‹è¯•é‡è¦æ€§] --> B[ä»£ç è´¨é‡ä¿éšœ]
    A --> C[å¿«é€Ÿé—®é¢˜å‘ç°]
    A --> D[é‡æ„ä¿¡å¿ƒ]
    A --> E[æ–‡æ¡£åŒ–è¡Œä¸º]

    B --> B1[å‡å°‘Bug]
    B --> B2[æé«˜å¯ç»´æŠ¤æ€§]

    C --> C1[æ—©æœŸå‘ç°é—®é¢˜]
    C --> C2[é™ä½ä¿®å¤æˆæœ¬]

    D --> D1[å®‰å…¨é‡æ„]
    D --> D2[åŠŸèƒ½æ‰©å±•]

    E --> E1[æµ‹è¯•å³æ–‡æ¡£]
    E --> E2[è¡Œä¸ºè§„èŒƒ]

    style A fill:#f9f,stroke:#333,stroke-width:4px
```

### 1.2 æµ‹è¯•é‡‘å­—å¡”

```mermaid
graph TB
    subgraph æµ‹è¯•é‡‘å­—å¡”
    A[E2Eæµ‹è¯• 10%]
    B[é›†æˆæµ‹è¯• 30%]
    C[å•å…ƒæµ‹è¯• 60%]
    end

    C --> C1[å¿«é€Ÿæ‰§è¡Œ]
    C --> C2[ç²¾ç¡®å®šä½]
    C --> C3[ä½æˆæœ¬ç»´æŠ¤]

    B --> B1[ç»„ä»¶åä½œ]
    B --> B2[æ¥å£éªŒè¯]

    A --> A1[ç”¨æˆ·åœºæ™¯]
    A --> A2[ç«¯åˆ°ç«¯éªŒè¯]

    style A fill:#ff9999
    style B fill:#ffcc99
    style C fill:#99ff99
```

## 2. å•å…ƒæµ‹è¯•æ¡†æ¶

### 2.1 TypeScript/Node.js å•å…ƒæµ‹è¯•ï¼ˆJestï¼‰

#### 2.1.1 Jest é…ç½®

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  transform: {
    '^.+\\.ts$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@tests/(.*)$': '<rootDir>/tests/$1'
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 10000,
  verbose: true
};
```

#### 2.1.2 å·¥å…·ç®¡ç†å™¨å•å…ƒæµ‹è¯•

```typescript
// tests/unit/tool-manager.test.ts
import { ToolManager } from '@/tools/ToolManager';
import { BashTool } from '@/tools/BashTool';
import { ReadTool } from '@/tools/ReadTool';
import { ToolExecutionContext } from '@/tools/types';

describe('ToolManager', () => {
  let toolManager: ToolManager;
  let mockContext: ToolExecutionContext;

  beforeEach(() => {
    toolManager = new ToolManager();
    mockContext = {
      workingDirectory: '/test/dir',
      user: 'test-user',
      timestamp: Date.now()
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('å·¥å…·æ³¨å†Œ', () => {
    it('åº”è¯¥æˆåŠŸæ³¨å†Œå·¥å…·', () => {
      const bashTool = new BashTool();

      toolManager.registerTool('bash', bashTool);

      expect(toolManager.getTool('bash')).toBe(bashTool);
      expect(toolManager.getToolNames()).toContain('bash');
    });

    it('åº”è¯¥æ‹’ç»é‡å¤æ³¨å†ŒåŒåå·¥å…·', () => {
      const bashTool = new BashTool();

      toolManager.registerTool('bash', bashTool);

      expect(() => {
        toolManager.registerTool('bash', new BashTool());
      }).toThrow('Tool "bash" already registered');
    });

    it('åº”è¯¥æ”¯æŒæ‰¹é‡æ³¨å†Œå·¥å…·', () => {
      const tools = {
        bash: new BashTool(),
        read: new ReadTool()
      };

      toolManager.registerTools(tools);

      expect(toolManager.getToolNames()).toEqual(['bash', 'read']);
    });
  });

  describe('å·¥å…·æ‰§è¡Œ', () => {
    it('åº”è¯¥æˆåŠŸæ‰§è¡Œå·²æ³¨å†Œçš„å·¥å…·', async () => {
      const mockTool = {
        name: 'mock',
        execute: jest.fn().mockResolvedValue({ success: true, data: 'result' })
      };

      toolManager.registerTool('mock', mockTool);

      const result = await toolManager.executeTool('mock', { arg: 'value' }, mockContext);

      expect(mockTool.execute).toHaveBeenCalledWith({ arg: 'value' }, mockContext);
      expect(result).toEqual({ success: true, data: 'result' });
    });

    it('åº”è¯¥å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯', async () => {
      const mockTool = {
        name: 'mock',
        execute: jest.fn().mockRejectedValue(new Error('Execution failed'))
      };

      toolManager.registerTool('mock', mockTool);

      await expect(
        toolManager.executeTool('mock', {}, mockContext)
      ).rejects.toThrow('Execution failed');
    });

    it('åº”è¯¥æ‹’ç»æ‰§è¡Œæœªæ³¨å†Œçš„å·¥å…·', async () => {
      await expect(
        toolManager.executeTool('nonexistent', {}, mockContext)
      ).rejects.toThrow('Tool "nonexistent" not found');
    });
  });

  describe('å·¥å…·éªŒè¯', () => {
    it('åº”è¯¥éªŒè¯å·¥å…·å‚æ•°', () => {
      const bashTool = new BashTool();
      toolManager.registerTool('bash', bashTool);

      const validParams = { command: 'ls -la' };
      const invalidParams = {};

      expect(toolManager.validateParams('bash', validParams)).toBe(true);
      expect(toolManager.validateParams('bash', invalidParams)).toBe(false);
    });

    it('åº”è¯¥æ£€æŸ¥å·¥å…·æƒé™', () => {
      const bashTool = new BashTool();
      toolManager.registerTool('bash', bashTool);

      const safeCommand = { command: 'ls' };
      const dangerousCommand = { command: 'rm -rf /' };

      expect(toolManager.checkPermissions('bash', safeCommand)).toBe(true);
      expect(toolManager.checkPermissions('bash', dangerousCommand)).toBe(false);
    });
  });
});
```

#### 2.1.3 æ–‡ä»¶æ“ä½œå·¥å…·æµ‹è¯•

```typescript
// tests/unit/file-tools.test.ts
import { ReadTool } from '@/tools/ReadTool';
import { WriteTool } from '@/tools/WriteTool';
import { EditTool } from '@/tools/EditTool';
import * as fs from 'fs/promises';

jest.mock('fs/promises');

describe('æ–‡ä»¶æ“ä½œå·¥å…·', () => {
  const mockFs = fs as jest.Mocked<typeof fs>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('ReadTool', () => {
    let readTool: ReadTool;

    beforeEach(() => {
      readTool = new ReadTool();
    });

    it('åº”è¯¥è¯»å–æ–‡ä»¶å†…å®¹', async () => {
      const mockContent = 'file content\nline 2\nline 3';
      mockFs.readFile.mockResolvedValue(mockContent);

      const result = await readTool.execute({
        file_path: '/test/file.txt'
      });

      expect(result.success).toBe(true);
      expect(result.data).toContain('file content');
      expect(mockFs.readFile).toHaveBeenCalledWith(
        '/test/file.txt',
        'utf-8'
      );
    });

    it('åº”è¯¥æ”¯æŒè¡ŒèŒƒå›´è¯»å–', async () => {
      const mockContent = Array.from({ length: 100 }, (_, i) => `line ${i + 1}`).join('\n');
      mockFs.readFile.mockResolvedValue(mockContent);

      const result = await readTool.execute({
        file_path: '/test/file.txt',
        offset: 10,
        limit: 20
      });

      expect(result.success).toBe(true);
      const lines = result.data.split('\n');
      expect(lines.length).toBeLessThanOrEqual(20);
    });

    it('åº”è¯¥å¤„ç†æ–‡ä»¶ä¸å­˜åœ¨é”™è¯¯', async () => {
      mockFs.readFile.mockRejectedValue(new Error('ENOENT: no such file'));

      const result = await readTool.execute({
        file_path: '/nonexistent/file.txt'
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('file not found');
    });

    it('åº”è¯¥å¤„ç†æƒé™é”™è¯¯', async () => {
      mockFs.readFile.mockRejectedValue(new Error('EACCES: permission denied'));

      const result = await readTool.execute({
        file_path: '/protected/file.txt'
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('permission denied');
    });
  });

  describe('WriteTool', () => {
    let writeTool: WriteTool;

    beforeEach(() => {
      writeTool = new WriteTool();
    });

    it('åº”è¯¥å†™å…¥æ–‡ä»¶å†…å®¹', async () => {
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await writeTool.execute({
        file_path: '/test/new-file.txt',
        content: 'new content'
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/new-file.txt',
        'new content',
        'utf-8'
      );
    });

    it('åº”è¯¥åœ¨å†™å…¥å‰åˆ›å»ºç›®å½•', async () => {
      mockFs.mkdir.mockResolvedValue(undefined);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await writeTool.execute({
        file_path: '/test/new/dir/file.txt',
        content: 'content'
      });

      expect(result.success).toBe(true);
      expect(mockFs.mkdir).toHaveBeenCalledWith(
        '/test/new/dir',
        { recursive: true }
      );
    });
  });

  describe('EditTool', () => {
    let editTool: EditTool;

    beforeEach(() => {
      editTool = new EditTool();
    });

    it('åº”è¯¥æ›¿æ¢æ–‡ä»¶ä¸­çš„å†…å®¹', async () => {
      const originalContent = 'Hello World\nThis is a test\nGoodbye';
      const expectedContent = 'Hello Universe\nThis is a test\nGoodbye';

      mockFs.readFile.mockResolvedValue(originalContent);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'World',
        new_string: 'Universe'
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/file.txt',
        expectedContent,
        'utf-8'
      );
    });

    it('åº”è¯¥æ”¯æŒå…¨å±€æ›¿æ¢', async () => {
      const originalContent = 'foo bar foo baz foo';
      const expectedContent = 'qux bar qux baz qux';

      mockFs.readFile.mockResolvedValue(originalContent);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'foo',
        new_string: 'qux',
        replace_all: true
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/file.txt',
        expectedContent,
        'utf-8'
      );
    });

    it('åº”è¯¥æ‹’ç»éå”¯ä¸€åŒ¹é…ï¼ˆéå…¨å±€æ¨¡å¼ï¼‰', async () => {
      const originalContent = 'foo bar foo baz';

      mockFs.readFile.mockResolvedValue(originalContent);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'foo',
        new_string: 'qux',
        replace_all: false
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not unique');
    });
  });
});
```

### 2.2 Java å•å…ƒæµ‹è¯•ï¼ˆJUnit 5ï¼‰

#### 2.2.1 JUnit é…ç½®

```xml
<!-- pom.xml -->
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>

    <!-- Mockito -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>5.5.0</version>
        <scope>test</scope>
    </dependency>

    <!-- AssertJ -->
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <version>3.24.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.1.2</version>
            <configuration>
                <includes>
                    <include>**/*Test.java</include>
                    <include>**/*Tests.java</include>
                </includes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 2.2.2 å·¥å…·æ‰§è¡Œå™¨æµ‹è¯•

```java
package com.anthropic.claudecode.tools;

import org.junit.jupiter.api.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

@DisplayName("ToolExecutor æµ‹è¯•")
class ToolExecutorTest {

    private ToolExecutor toolExecutor;

    @Mock
    private ToolRegistry toolRegistry;

    @Mock
    private SecurityManager securityManager;

    private AutoCloseable mocks;

    @BeforeEach
    void setUp() {
        mocks = MockitoAnnotations.openMocks(this);
        toolExecutor = new ToolExecutor(toolRegistry, securityManager);
    }

    @AfterEach
    void tearDown() throws Exception {
        mocks.close();
    }

    @Nested
    @DisplayName("å·¥å…·æ‰§è¡Œæµ‹è¯•")
    class ExecutionTests {

        @Test
        @DisplayName("åº”è¯¥æˆåŠŸæ‰§è¡Œå·¥å…·")
        void shouldExecuteToolSuccessfully() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "ls");
            ExecutionContext context = new ExecutionContext("/test");
            ToolResult expectedResult = ToolResult.success("output");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenReturn(expectedResult);

            // When
            ToolResult result = toolExecutor.execute("bash", params, context);

            // Then
            assertThat(result).isNotNull();
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getOutput()).isEqualTo("output");

            verify(toolRegistry).getTool("bash");
            verify(securityManager).checkPermission("bash", params);
            verify(mockTool).execute(params, context);
        }

        @Test
        @DisplayName("åº”è¯¥å¤„ç†å·¥å…·æ‰§è¡Œå¼‚å¸¸")
        void shouldHandleExecutionException() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "invalid");
            ExecutionContext context = new ExecutionContext("/test");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context))
                .thenThrow(new RuntimeException("Execution failed"));

            // When & Then
            assertThatThrownBy(() -> toolExecutor.execute("bash", params, context))
                .isInstanceOf(ToolExecutionException.class)
                .hasMessageContaining("Execution failed");
        }

        @Test
        @DisplayName("åº”è¯¥æ‹’ç»æ— æƒé™çš„å·¥å…·è°ƒç”¨")
        void shouldRejectUnauthorizedExecution() {
            // Given
            Map<String, Object> params = Map.of("command", "rm -rf /");
            ExecutionContext context = new ExecutionContext("/test");

            when(securityManager.checkPermission("bash", params)).thenReturn(false);

            // When & Then
            assertThatThrownBy(() -> toolExecutor.execute("bash", params, context))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("Permission denied");

            verify(toolRegistry, never()).getTool(anyString());
        }
    }

    @Nested
    @DisplayName("å¼‚æ­¥æ‰§è¡Œæµ‹è¯•")
    class AsyncExecutionTests {

        @Test
        @DisplayName("åº”è¯¥æ”¯æŒå¼‚æ­¥æ‰§è¡Œ")
        void shouldSupportAsyncExecution() throws Exception {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "long-running");
            ExecutionContext context = new ExecutionContext("/test");
            ToolResult expectedResult = ToolResult.success("completed");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenReturn(expectedResult);

            // When
            CompletableFuture<ToolResult> future =
                toolExecutor.executeAsync("bash", params, context);
            ToolResult result = future.get();

            // Then
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getOutput()).isEqualTo("completed");
        }

        @Test
        @DisplayName("åº”è¯¥æ”¯æŒè¶…æ—¶æ§åˆ¶")
        void shouldSupportTimeout() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "sleep 100");
            ExecutionContext context = new ExecutionContext("/test");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenAnswer(invocation -> {
                Thread.sleep(5000);
                return ToolResult.success("done");
            });

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.executeWithTimeout("bash", params, context, 1000)
            ).isInstanceOf(TimeoutException.class);
        }
    }

    @Nested
    @DisplayName("å‚æ•°éªŒè¯æµ‹è¯•")
    class ValidationTests {

        @Test
        @DisplayName("åº”è¯¥éªŒè¯å¿…éœ€å‚æ•°")
        void shouldValidateRequiredParameters() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of(); // ç¼ºå°‘ command å‚æ•°

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(mockTool.getRequiredParams()).thenReturn(Set.of("command"));

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.validateAndExecute("bash", params, null)
            ).isInstanceOf(ValidationException.class)
              .hasMessageContaining("Missing required parameter: command");
        }

        @Test
        @DisplayName("åº”è¯¥éªŒè¯å‚æ•°ç±»å‹")
        void shouldValidateParameterTypes() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("timeout", "not-a-number");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(mockTool.getParameterSchema()).thenReturn(
                Map.of("timeout", ParameterType.NUMBER)
            );

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.validateAndExecute("bash", params, null)
            ).isInstanceOf(ValidationException.class)
              .hasMessageContaining("Invalid type for parameter: timeout");
        }
    }
}
```

## 3. é›†æˆæµ‹è¯•ç­–ç•¥

### 3.1 é›†æˆæµ‹è¯•æ¶æ„

```mermaid
graph TB
    subgraph é›†æˆæµ‹è¯•å±‚æ¬¡
    A[APIé›†æˆæµ‹è¯•] --> B[å·¥å…·é›†æˆæµ‹è¯•]
    B --> C[æ•°æ®åº“é›†æˆæµ‹è¯•]
    C --> D[å¤–éƒ¨æœåŠ¡é›†æˆæµ‹è¯•]
    end

    A --> A1[HTTPæ¥å£æµ‹è¯•]
    A --> A2[WebSocketæµ‹è¯•]

    B --> B1[å·¥å…·é“¾åä½œ]
    B --> B2[å·¥å…·ä¾èµ–æµ‹è¯•]

    C --> C1[æ•°æ®æŒä¹…åŒ–]
    C --> C2[äº‹åŠ¡æµ‹è¯•]

    D --> D1[Claude API Mock]
    D --> D2[æ–‡ä»¶ç³»ç»ŸMock]

    style A fill:#e1f5ff
    style B fill:#fff9e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
```

### 3.2 API é›†æˆæµ‹è¯•

```typescript
// tests/integration/api.test.ts
import request from 'supertest';
import { app } from '@/app';
import { setupTestDatabase, cleanupTestDatabase } from '@tests/helpers/database';

describe('Claude Code API é›†æˆæµ‹è¯•', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/tools/execute', () => {
    it('åº”è¯¥æ‰§è¡Œå·¥å…·å¹¶è¿”å›ç»“æœ', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash',
          parameters: {
            command: 'echo "Hello World"',
            description: 'Test command'
          },
          context: {
            workingDirectory: '/tmp'
          }
        })
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        result: expect.objectContaining({
          stdout: expect.stringContaining('Hello World'),
          exitCode: 0
        })
      });
    });

    it('åº”è¯¥å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash',
          parameters: {
            command: 'nonexistent-command'
          }
        })
        .expect(500);

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('command not found')
      });
    });

    it('åº”è¯¥éªŒè¯è¯·æ±‚å‚æ•°', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash'
          // ç¼ºå°‘ parameters
        })
        .expect(400);

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('parameters are required')
      });
    });

    it('åº”è¯¥å®æ–½é€Ÿç‡é™åˆ¶', async () => {
      const promises = Array.from({ length: 100 }, () =>
        request(app)
          .post('/api/tools/execute')
          .send({
            tool: 'bash',
            parameters: { command: 'echo test' }
          })
      );

      const responses = await Promise.all(promises);
      const rateLimited = responses.filter(r => r.status === 429);

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  describe('GET /api/tools', () => {
    it('åº”è¯¥è¿”å›å¯ç”¨å·¥å…·åˆ—è¡¨', async () => {
      const response = await request(app)
        .get('/api/tools')
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        tools: expect.arrayContaining([
          expect.objectContaining({
            name: 'bash',
            description: expect.any(String),
            parameters: expect.any(Object)
          })
        ])
      });
    });
  });

  describe('WebSocket /ws/execute', () => {
    it('åº”è¯¥æ”¯æŒå®æ—¶å·¥å…·æ‰§è¡Œ', async () => {
      const ws = new WebSocket('ws://localhost:3000/ws/execute');
      const messages: any[] = [];

      ws.on('message', (data) => {
        messages.push(JSON.parse(data.toString()));
      });

      await new Promise((resolve) => {
        ws.on('open', () => {
          ws.send(JSON.stringify({
            tool: 'bash',
            parameters: {
              command: 'for i in 1 2 3; do echo $i; sleep 1; done',
              run_in_background: true
            }
          }));

          setTimeout(resolve, 4000);
        });
      });

      ws.close();

      expect(messages.length).toBeGreaterThan(1);
      expect(messages[0]).toMatchObject({
        type: 'started',
        shellId: expect.any(String)
      });
      expect(messages.some(m => m.type === 'output')).toBe(true);
    });
  });
});
```

### 3.3 æ•°æ®åº“é›†æˆæµ‹è¯•

```typescript
// tests/integration/database.test.ts
import { SessionRepository } from '@/repositories/SessionRepository';
import { ToolExecutionRepository } from '@/repositories/ToolExecutionRepository';
import { setupTestDatabase, cleanupTestDatabase } from '@tests/helpers/database';

describe('æ•°æ®åº“é›†æˆæµ‹è¯•', () => {
  let sessionRepo: SessionRepository;
  let executionRepo: ToolExecutionRepository;

  beforeAll(async () => {
    await setupTestDatabase();
    sessionRepo = new SessionRepository();
    executionRepo = new ToolExecutionRepository();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  beforeEach(async () => {
    await sessionRepo.clear();
    await executionRepo.clear();
  });

  describe('ä¼šè¯ç®¡ç†', () => {
    it('åº”è¯¥åˆ›å»ºå’Œæ£€ç´¢ä¼šè¯', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/home/user/project',
        metadata: {
          platform: 'linux',
          nodeVersion: '18.0.0'
        }
      });

      expect(session.id).toBeDefined();
      expect(session.createdAt).toBeInstanceOf(Date);

      const retrieved = await sessionRepo.findById(session.id);
      expect(retrieved).toMatchObject({
        userId: 'user-123',
        workingDirectory: '/home/user/project'
      });
    });

    it('åº”è¯¥æ›´æ–°ä¼šè¯çŠ¶æ€', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await sessionRepo.update(session.id, {
        status: 'active',
        lastActivityAt: new Date()
      });

      const updated = await sessionRepo.findById(session.id);
      expect(updated.status).toBe('active');
      expect(updated.lastActivityAt).toBeInstanceOf(Date);
    });

    it('åº”è¯¥æŸ¥è¯¢ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯', async () => {
      await sessionRepo.create({ userId: 'user-1', workingDirectory: '/a' });
      await sessionRepo.create({ userId: 'user-1', workingDirectory: '/b' });
      await sessionRepo.create({ userId: 'user-2', workingDirectory: '/c' });

      const user1Sessions = await sessionRepo.findByUserId('user-1');
      expect(user1Sessions).toHaveLength(2);
    });
  });

  describe('å·¥å…·æ‰§è¡Œè®°å½•', () => {
    it('åº”è¯¥è®°å½•å·¥å…·æ‰§è¡Œå†å²', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      const execution = await executionRepo.create({
        sessionId: session.id,
        toolName: 'bash',
        parameters: { command: 'ls' },
        startedAt: new Date()
      });

      expect(execution.id).toBeDefined();

      await executionRepo.complete(execution.id, {
        success: true,
        result: { stdout: 'file1\nfile2', exitCode: 0 },
        completedAt: new Date()
      });

      const completed = await executionRepo.findById(execution.id);
      expect(completed.success).toBe(true);
      expect(completed.result.stdout).toContain('file1');
    });

    it('åº”è¯¥æŸ¥è¯¢ä¼šè¯çš„æ‰§è¡Œå†å²', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await executionRepo.create({
        sessionId: session.id,
        toolName: 'bash',
        parameters: { command: 'ls' },
        startedAt: new Date()
      });

      await executionRepo.create({
        sessionId: session.id,
        toolName: 'read',
        parameters: { file_path: '/test/file.txt' },
        startedAt: new Date()
      });

      const history = await executionRepo.findBySessionId(session.id);
      expect(history).toHaveLength(2);
      expect(history.map(h => h.toolName)).toContain('bash');
      expect(history.map(h => h.toolName)).toContain('read');
    });

    it('åº”è¯¥æ”¯æŒäº‹åŠ¡å›æ»š', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await expect(async () => {
        await sessionRepo.transaction(async (trx) => {
          await executionRepo.create({
            sessionId: session.id,
            toolName: 'bash',
            parameters: { command: 'test' },
            startedAt: new Date()
          }, trx);

          throw new Error('Rollback test');
        });
      }).rejects.toThrow('Rollback test');

      const executions = await executionRepo.findBySessionId(session.id);
      expect(executions).toHaveLength(0);
    });
  });
});
```

## 4. E2E æµ‹è¯•å®è·µ

### 4.1 Playwright E2E æµ‹è¯•é…ç½®

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit.xml' }]
  ],
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    }
  ],
  webServer: {
    command: 'npm run start:test',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120000
  }
});
```

### 4.2 E2E æµ‹è¯•ç”¨ä¾‹

```typescript
// tests/e2e/tool-execution.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Claude Code å·¥å…·æ‰§è¡Œ E2E æµ‹è¯•', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('åº”è¯¥æ‰§è¡Œ Bash å‘½ä»¤å¹¶æ˜¾ç¤ºè¾“å‡º', async ({ page }) => {
    // è¾“å…¥å‘½ä»¤
    await page.fill('[data-testid="command-input"]', 'ls -la');

    // é€‰æ‹©å·¥å…·
    await page.selectOption('[data-testid="tool-selector"]', 'bash');

    // æ‰§è¡Œ
    await page.click('[data-testid="execute-button"]');

    // ç­‰å¾…ç»“æœ
    await page.waitForSelector('[data-testid="output-container"]');

    // éªŒè¯è¾“å‡º
    const output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('total');
    expect(output).toMatch(/^[drwx-]{10}/m); // Unix file permissions

    // éªŒè¯çŠ¶æ€
    const status = await page.textContent('[data-testid="execution-status"]');
    expect(status).toBe('Success');
  });

  test('åº”è¯¥å¤„ç†å¤šæ­¥éª¤å·¥å…·é“¾', async ({ page }) => {
    // æ­¥éª¤ 1: è¯»å–æ–‡ä»¶
    await page.fill('[data-testid="command-input"]', '/test/sample.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    await page.waitForSelector('[data-testid="output-container"]');
    let output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('Sample content');

    // æ­¥éª¤ 2: ç¼–è¾‘æ–‡ä»¶
    await page.fill('[data-testid="old-string-input"]', 'old text');
    await page.fill('[data-testid="new-string-input"]', 'new text');
    await page.selectOption('[data-testid="tool-selector"]', 'edit');
    await page.click('[data-testid="execute-button"]');

    await page.waitForSelector('[data-testid="success-message"]');

    // æ­¥éª¤ 3: éªŒè¯ç¼–è¾‘
    await page.fill('[data-testid="command-input"]', '/test/sample.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('new text');
    expect(output).not.toContain('old text');
  });

  test('åº”è¯¥æ˜¾ç¤ºå®æ—¶å‘½ä»¤è¾“å‡º', async ({ page }) => {
    // æ‰§è¡Œé•¿æ—¶é—´è¿è¡Œçš„å‘½ä»¤
    await page.fill(
      '[data-testid="command-input"]',
      'for i in 1 2 3; do echo "Line $i"; sleep 1; done'
    );
    await page.selectOption('[data-testid="tool-selector"]', 'bash');
    await page.check('[data-testid="background-checkbox"]');
    await page.click('[data-testid="execute-button"]');

    // éªŒè¯å®æ—¶è¾“å‡º
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 1")');
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 2")');
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 3")');

    // éªŒè¯å®ŒæˆçŠ¶æ€
    await page.waitForSelector('[data-testid="execution-complete"]');
  });

  test('åº”è¯¥å¤„ç†é”™è¯¯æƒ…å†µ', async ({ page }) => {
    // æ‰§è¡Œæ— æ•ˆå‘½ä»¤
    await page.fill('[data-testid="command-input"]', 'invalid-command-xyz');
    await page.selectOption('[data-testid="tool-selector"]', 'bash');
    await page.click('[data-testid="execute-button"]');

    // éªŒè¯é”™è¯¯æ¶ˆæ¯
    await page.waitForSelector('[data-testid="error-container"]');
    const error = await page.textContent('[data-testid="error-container"]');
    expect(error).toContain('command not found');

    // éªŒè¯çŠ¶æ€
    const status = await page.textContent('[data-testid="execution-status"]');
    expect(status).toBe('Failed');
  });

  test('åº”è¯¥æ”¯æŒæ–‡ä»¶ä¸Šä¼ ', async ({ page }) => {
    // å‡†å¤‡æµ‹è¯•æ–‡ä»¶
    const testFile = {
      name: 'test-upload.txt',
      mimeType: 'text/plain',
      buffer: Buffer.from('Test file content')
    };

    // ä¸Šä¼ æ–‡ä»¶
    await page.setInputFiles('[data-testid="file-input"]', testFile);
    await page.click('[data-testid="upload-button"]');

    // éªŒè¯ä¸Šä¼ æˆåŠŸ
    await page.waitForSelector('[data-testid="upload-success"]');

    // éªŒè¯æ–‡ä»¶å¯è¯»
    await page.fill('[data-testid="command-input"]', '/uploads/test-upload.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    const output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('Test file content');
  });

  test('åº”è¯¥ä¿å­˜æ‰§è¡Œå†å²', async ({ page }) => {
    // æ‰§è¡Œå¤šä¸ªå‘½ä»¤
    const commands = ['echo "cmd1"', 'echo "cmd2"', 'echo "cmd3"'];

    for (const cmd of commands) {
      await page.fill('[data-testid="command-input"]', cmd);
      await page.selectOption('[data-testid="tool-selector"]', 'bash');
      await page.click('[data-testid="execute-button"]');
      await page.waitForSelector('[data-testid="success-message"]');
    }

    // æ‰“å¼€å†å²é¢æ¿
    await page.click('[data-testid="history-button"]');
    await page.waitForSelector('[data-testid="history-panel"]');

    // éªŒè¯å†å²è®°å½•
    const historyItems = await page.locator('[data-testid="history-item"]').count();
    expect(historyItems).toBe(3);

    // éªŒè¯å¯ä»¥é‡æ–°æ‰§è¡Œå†å²å‘½ä»¤
    await page.click('[data-testid="history-item"]:nth-child(1)');
    const commandInput = await page.inputValue('[data-testid="command-input"]');
    expect(commandInput).toBe('echo "cmd1"');
  });
});
```

### 4.3 Page Object æ¨¡å¼

```typescript
// tests/e2e/pages/ToolExecutionPage.ts
import { Page, Locator } from '@playwright/test';

export class ToolExecutionPage {
  readonly page: Page;
  readonly commandInput: Locator;
  readonly toolSelector: Locator;
  readonly executeButton: Locator;
  readonly outputContainer: Locator;
  readonly errorContainer: Locator;
  readonly statusLabel: Locator;

  constructor(page: Page) {
    this.page = page;
    this.commandInput = page.locator('[data-testid="command-input"]');
    this.toolSelector = page.locator('[data-testid="tool-selector"]');
    this.executeButton = page.locator('[data-testid="execute-button"]');
    this.outputContainer = page.locator('[data-testid="output-container"]');
    this.errorContainer = page.locator('[data-testid="error-container"]');
    this.statusLabel = page.locator('[data-testid="execution-status"]');
  }

  async goto() {
    await this.page.goto('/');
    await this.page.waitForLoadState('networkidle');
  }

  async executeTool(tool: string, command: string) {
    await this.commandInput.fill(command);
    await this.toolSelector.selectOption(tool);
    await this.executeButton.click();
  }

  async waitForSuccess() {
    await this.page.waitForSelector('[data-testid="success-message"]');
  }

  async waitForError() {
    await this.errorContainer.waitFor({ state: 'visible' });
  }

  async getOutput(): Promise<string> {
    return await this.outputContainer.textContent() || '';
  }

  async getError(): Promise<string> {
    return await this.errorContainer.textContent() || '';
  }

  async getStatus(): Promise<string> {
    return await this.statusLabel.textContent() || '';
  }
}

// ä½¿ç”¨ Page Object
import { test, expect } from '@playwright/test';
import { ToolExecutionPage } from './pages/ToolExecutionPage';

test('ä½¿ç”¨ Page Object æ‰§è¡Œå·¥å…·', async ({ page }) => {
  const toolPage = new ToolExecutionPage(page);

  await toolPage.goto();
  await toolPage.executeTool('bash', 'echo "Hello"');
  await toolPage.waitForSuccess();

  const output = await toolPage.getOutput();
  expect(output).toContain('Hello');

  const status = await toolPage.getStatus();
  expect(status).toBe('Success');
});
```

## 5. Mock å’Œ Stub æŠ€æœ¯

### 5.1 å·¥å…· Mock

```typescript
// tests/mocks/MockToolRegistry.ts
import { Tool, ToolResult } from '@/tools/types';

export class MockToolRegistry {
  private tools: Map<string, MockTool> = new Map();

  registerMockTool(name: string, behavior: Partial<MockTool>) {
    this.tools.set(name, new MockTool(name, behavior));
  }

  getTool(name: string): MockTool {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool "${name}" not found`);
    }
    return tool;
  }

  reset() {
    this.tools.forEach(tool => tool.reset());
  }
}

export class MockTool implements Tool {
  name: string;
  executionCount: number = 0;
  lastParams: any = null;
  lastContext: any = null;

  private mockResult: ToolResult;
  private mockError: Error | null = null;
  private executionDelay: number = 0;

  constructor(name: string, behavior: Partial<MockTool> = {}) {
    this.name = name;
    this.mockResult = behavior.mockResult || ToolResult.success('mock result');
    this.mockError = behavior.mockError || null;
    this.executionDelay = behavior.executionDelay || 0;
  }

  async execute(params: any, context: any): Promise<ToolResult> {
    this.executionCount++;
    this.lastParams = params;
    this.lastContext = context;

    if (this.executionDelay > 0) {
      await new Promise(resolve => setTimeout(resolve, this.executionDelay));
    }

    if (this.mockError) {
      throw this.mockError;
    }

    return this.mockResult;
  }

  setResult(result: ToolResult) {
    this.mockResult = result;
  }

  setError(error: Error) {
    this.mockError = error;
  }

  setDelay(ms: number) {
    this.executionDelay = ms;
  }

  reset() {
    this.executionCount = 0;
    this.lastParams = null;
    this.lastContext = null;
  }

  wasCalledWith(params: any): boolean {
    return JSON.stringify(this.lastParams) === JSON.stringify(params);
  }
}
```

### 5.2 Claude API Mock

```typescript
// tests/mocks/MockClaudeAPI.ts
import { ClaudeAPIClient, Message, ToolUse } from '@/api/ClaudeAPIClient';

export class MockClaudeAPI implements ClaudeAPIClient {
  private responses: Message[] = [];
  private currentResponseIndex: number = 0;
  private requestHistory: any[] = [];

  constructor() {}

  // é…ç½®é¢„å®šä¹‰å“åº”
  addResponse(content: string, toolUses: ToolUse[] = []) {
    this.responses.push({
      role: 'assistant',
      content: [
        { type: 'text', text: content },
        ...toolUses.map(tu => ({ type: 'tool_use', ...tu }))
      ]
    });
  }

  // æ¨¡æ‹Ÿ API è°ƒç”¨
  async sendMessage(messages: Message[]): Promise<Message> {
    this.requestHistory.push({
      timestamp: Date.now(),
      messages: JSON.parse(JSON.stringify(messages))
    });

    if (this.currentResponseIndex >= this.responses.length) {
      throw new Error('No more mock responses available');
    }

    const response = this.responses[this.currentResponseIndex++];

    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 100));

    return response;
  }

  // æµå¼å“åº”æ¨¡æ‹Ÿ
  async *streamMessage(messages: Message[]): AsyncGenerator<StreamEvent> {
    this.requestHistory.push({
      timestamp: Date.now(),
      messages: JSON.parse(JSON.stringify(messages)),
      streaming: true
    });

    const response = this.responses[this.currentResponseIndex++];

    // æ¨¡æ‹Ÿæµå¼è¾“å‡º
    for (const block of response.content) {
      if (block.type === 'text') {
        const words = block.text.split(' ');
        for (const word of words) {
          yield {
            type: 'content_block_delta',
            delta: { type: 'text_delta', text: word + ' ' }
          };
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } else if (block.type === 'tool_use') {
        yield {
          type: 'content_block_start',
          content_block: block
        };
      }
    }

    yield {
      type: 'message_stop'
    };
  }

  // æ£€æŸ¥æ–¹æ³•
  getRequestHistory() {
    return this.requestHistory;
  }

  getLastRequest() {
    return this.requestHistory[this.requestHistory.length - 1];
  }

  wasCalledWithTool(toolName: string): boolean {
    return this.requestHistory.some(req =>
      req.messages.some((msg: Message) =>
        msg.content.some((block: any) =>
          block.type === 'tool_result' && block.tool_use_id.includes(toolName)
        )
      )
    );
  }

  reset() {
    this.responses = [];
    this.currentResponseIndex = 0;
    this.requestHistory = [];
  }
}

// ä½¿ç”¨ç¤ºä¾‹
describe('Agent ä¸ Claude API äº¤äº’', () => {
  let mockAPI: MockClaudeAPI;
  let agent: Agent;

  beforeEach(() => {
    mockAPI = new MockClaudeAPI();
    agent = new Agent({ apiClient: mockAPI });
  });

  it('åº”è¯¥æ­£ç¡®å¤„ç†å·¥å…·è°ƒç”¨', async () => {
    // é…ç½® Claude å“åº”åŒ…å«å·¥å…·è°ƒç”¨
    mockAPI.addResponse(
      'I will list the files for you.',
      [{
        id: 'tool_1',
        name: 'bash',
        input: { command: 'ls -la' }
      }]
    );

    // é…ç½®ç¬¬äºŒä¸ªå“åº”ï¼ˆå·¥å…·ç»“æœåï¼‰
    mockAPI.addResponse('Here are the files in the directory.');

    await agent.processUserMessage('List files in the current directory');

    expect(mockAPI.wasCalledWithTool('bash')).toBe(true);
    expect(mockAPI.getRequestHistory()).toHaveLength(2);
  });
});
```

### 5.3 æ–‡ä»¶ç³»ç»Ÿ Mock

```typescript
// tests/mocks/MockFileSystem.ts
import * as path from 'path';

export class MockFileSystem {
  private files: Map<string, string> = new Map();
  private directories: Set<string> = new Set(['/']);

  writeFile(filePath: string, content: string): void {
    const normalizedPath = path.normalize(filePath);
    const dir = path.dirname(normalizedPath);

    if (!this.directories.has(dir)) {
      throw new Error(`ENOENT: directory does not exist: ${dir}`);
    }

    this.files.set(normalizedPath, content);
  }

  readFile(filePath: string): string {
    const normalizedPath = path.normalize(filePath);

    if (!this.files.has(normalizedPath)) {
      throw new Error(`ENOENT: no such file: ${normalizedPath}`);
    }

    return this.files.get(normalizedPath)!;
  }

  mkdir(dirPath: string, options?: { recursive?: boolean }): void {
    const normalizedPath = path.normalize(dirPath);

    if (options?.recursive) {
      const parts = normalizedPath.split(path.sep).filter(p => p);
      let currentPath = '/';

      for (const part of parts) {
        currentPath = path.join(currentPath, part);
        this.directories.add(currentPath);
      }
    } else {
      const parent = path.dirname(normalizedPath);
      if (!this.directories.has(parent)) {
        throw new Error(`ENOENT: parent directory does not exist: ${parent}`);
      }
      this.directories.add(normalizedPath);
    }
  }

  exists(filePath: string): boolean {
    const normalizedPath = path.normalize(filePath);
    return this.files.has(normalizedPath) || this.directories.has(normalizedPath);
  }

  readdir(dirPath: string): string[] {
    const normalizedPath = path.normalize(dirPath);

    if (!this.directories.has(normalizedPath)) {
      throw new Error(`ENOENT: directory does not exist: ${normalizedPath}`);
    }

    const items: string[] = [];

    // æŸ¥æ‰¾æ–‡ä»¶
    for (const [filePath] of this.files) {
      if (path.dirname(filePath) === normalizedPath) {
        items.push(path.basename(filePath));
      }
    }

    // æŸ¥æ‰¾å­ç›®å½•
    for (const dir of this.directories) {
      if (path.dirname(dir) === normalizedPath && dir !== normalizedPath) {
        items.push(path.basename(dir));
      }
    }

    return items;
  }

  unlink(filePath: string): void {
    const normalizedPath = path.normalize(filePath);

    if (!this.files.has(normalizedPath)) {
      throw new Error(`ENOENT: no such file: ${normalizedPath}`);
    }

    this.files.delete(normalizedPath);
  }

  reset(): void {
    this.files.clear();
    this.directories.clear();
    this.directories.add('/');
  }

  // è¾…åŠ©æ–¹æ³•ï¼šåˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„
  createStructure(structure: any, basePath: string = '/'): void {
    for (const [name, content] of Object.entries(structure)) {
      const fullPath = path.join(basePath, name);

      if (typeof content === 'string') {
        // æ–‡ä»¶
        this.mkdir(path.dirname(fullPath), { recursive: true });
        this.writeFile(fullPath, content);
      } else {
        // ç›®å½•
        this.mkdir(fullPath, { recursive: true });
        this.createStructure(content, fullPath);
      }
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
describe('æ–‡ä»¶å·¥å…·ä¸ MockFileSystem', () => {
  let mockFs: MockFileSystem;
  let readTool: ReadTool;

  beforeEach(() => {
    mockFs = new MockFileSystem();
    readTool = new ReadTool({ fs: mockFs });

    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„
    mockFs.createStructure({
      'project': {
        'src': {
          'index.ts': 'console.log("Hello");',
          'utils.ts': 'export const add = (a, b) => a + b;'
        },
        'package.json': JSON.stringify({ name: 'test-project' })
      }
    });
  });

  it('åº”è¯¥è¯»å–æ–‡ä»¶', async () => {
    const result = await readTool.execute({
      file_path: '/project/src/index.ts'
    });

    expect(result.success).toBe(true);
    expect(result.data).toContain('console.log');
  });

  it('åº”è¯¥åˆ—å‡ºç›®å½•å†…å®¹', async () => {
    const files = mockFs.readdir('/project/src');

    expect(files).toContain('index.ts');
    expect(files).toContain('utils.ts');
  });
});
```

## 6. æµ‹è¯•è¦†ç›–ç‡åˆ†æ

### 6.1 è¦†ç›–ç‡é…ç½®

```javascript
// jest.config.js (è¦†ç›–ç‡éƒ¨åˆ†)
module.exports = {
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html', 'json-summary'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/**/*.types.ts',
    '!src/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/tools/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    },
    './src/security/': {
      branches: 95,
      functions: 95,
      lines: 95,
      statements: 95
    }
  },
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/dist/'
  ]
};
```

### 6.2 è¦†ç›–ç‡æŠ¥å‘Šåˆ†æ

```mermaid
graph LR
    A[æµ‹è¯•è¦†ç›–ç‡] --> B[è¯­å¥è¦†ç›–ç‡]
    A --> C[åˆ†æ”¯è¦†ç›–ç‡]
    A --> D[å‡½æ•°è¦†ç›–ç‡]
    A --> E[è¡Œè¦†ç›–ç‡]

    B --> B1[å·²æ‰§è¡Œè¯­å¥/æ€»è¯­å¥]
    C --> C1[å·²æµ‹è¯•åˆ†æ”¯/æ€»åˆ†æ”¯]
    D --> D1[å·²è°ƒç”¨å‡½æ•°/æ€»å‡½æ•°]
    E --> E1[å·²è¦†ç›–è¡Œ/æ€»è¡Œæ•°]

    style A fill:#e1f5ff
    style B fill:#d4edda
    style C fill:#fff3cd
    style D fill:#f8d7da
    style E fill:#d1ecf1
```

### 6.3 è¦†ç›–ç‡ç›‘æ§è„šæœ¬

```typescript
// scripts/check-coverage.ts
import * as fs from 'fs';
import * as path from 'path';

interface CoverageSummary {
  total: {
    lines: { pct: number };
    statements: { pct: number };
    functions: { pct: number };
    branches: { pct: number };
  };
  [key: string]: any;
}

const COVERAGE_FILE = path.join(__dirname, '../coverage/coverage-summary.json');
const THRESHOLD = {
  lines: 80,
  statements: 80,
  functions: 80,
  branches: 80
};

function checkCoverage() {
  if (!fs.existsSync(COVERAGE_FILE)) {
    console.error('Coverage file not found. Run tests with coverage first.');
    process.exit(1);
  }

  const coverage: CoverageSummary = JSON.parse(
    fs.readFileSync(COVERAGE_FILE, 'utf-8')
  );

  const { total } = coverage;
  const failures: string[] = [];

  console.log('\nğŸ“Š Coverage Report:\n');
  console.log(`Lines:      ${total.lines.pct.toFixed(2)}%`);
  console.log(`Statements: ${total.statements.pct.toFixed(2)}%`);
  console.log(`Functions:  ${total.functions.pct.toFixed(2)}%`);
  console.log(`Branches:   ${total.branches.pct.toFixed(2)}%\n`);

  if (total.lines.pct < THRESHOLD.lines) {
    failures.push(`Lines coverage ${total.lines.pct}% is below threshold ${THRESHOLD.lines}%`);
  }
  if (total.statements.pct < THRESHOLD.statements) {
    failures.push(`Statements coverage ${total.statements.pct}% is below threshold ${THRESHOLD.statements}%`);
  }
  if (total.functions.pct < THRESHOLD.functions) {
    failures.push(`Functions coverage ${total.functions.pct}% is below threshold ${THRESHOLD.functions}%`);
  }
  if (total.branches.pct < THRESHOLD.branches) {
    failures.push(`Branches coverage ${total.branches.pct}% is below threshold ${THRESHOLD.branches}%`);
  }

  if (failures.length > 0) {
    console.error('âŒ Coverage check failed:\n');
    failures.forEach(f => console.error(`  - ${f}`));
    process.exit(1);
  }

  console.log('âœ… All coverage thresholds met!');
}

checkCoverage();
```

## 7. æ€§èƒ½æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•

### 7.1 æ€§èƒ½æµ‹è¯•æ¡†æ¶

```typescript
// tests/performance/tool-execution.perf.ts
import { performance } from 'perf_hooks';
import { ToolExecutor } from '@/tools/ToolExecutor';
import { BashTool } from '@/tools/BashTool';

interface PerformanceMetrics {
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
}

class PerformanceTest {
  private measurements: number[] = [];

  async measure(fn: () => Promise<void>): Promise<number> {
    const start = performance.now();
    await fn();
    const duration = performance.now() - start;
    this.measurements.push(duration);
    return duration;
  }

  async run(fn: () => Promise<void>, iterations: number): Promise<void> {
    console.log(`Running ${iterations} iterations...`);

    for (let i = 0; i < iterations; i++) {
      await this.measure(fn);

      if ((i + 1) % 100 === 0) {
        console.log(`  Completed ${i + 1}/${iterations}`);
      }
    }
  }

  getMetrics(): PerformanceMetrics {
    const sorted = [...this.measurements].sort((a, b) => a - b);
    const sum = sorted.reduce((a, b) => a + b, 0);

    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sum / sorted.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }

  printResults(testName: string): void {
    const metrics = this.getMetrics();

    console.log(`\nğŸ“ˆ Performance Results: ${testName}`);
    console.log(`  Iterations: ${this.measurements.length}`);
    console.log(`  Min:        ${metrics.min.toFixed(2)}ms`);
    console.log(`  Max:        ${metrics.max.toFixed(2)}ms`);
    console.log(`  Avg:        ${metrics.avg.toFixed(2)}ms`);
    console.log(`  P50:        ${metrics.p50.toFixed(2)}ms`);
    console.log(`  P95:        ${metrics.p95.toFixed(2)}ms`);
    console.log(`  P99:        ${metrics.p99.toFixed(2)}ms\n`);
  }

  reset(): void {
    this.measurements = [];
  }
}

describe('å·¥å…·æ‰§è¡Œæ€§èƒ½æµ‹è¯•', () => {
  let perfTest: PerformanceTest;
  let toolExecutor: ToolExecutor;

  beforeEach(() => {
    perfTest = new PerformanceTest();
    toolExecutor = new ToolExecutor();
    toolExecutor.registerTool('bash', new BashTool());
  });

  it('åº”è¯¥å¿«é€Ÿæ‰§è¡Œç®€å•å‘½ä»¤', async () => {
    await perfTest.run(async () => {
      await toolExecutor.execute('bash', {
        command: 'echo "test"'
      });
    }, 1000);

    perfTest.printResults('Simple Command Execution');

    const metrics = perfTest.getMetrics();
    expect(metrics.p95).toBeLessThan(50); // P95 < 50ms
  });

  it('åº”è¯¥å¤„ç†å¹¶å‘è¯·æ±‚', async () => {
    const concurrency = 50;

    const start = performance.now();

    await Promise.all(
      Array.from({ length: concurrency }, () =>
        toolExecutor.execute('bash', {
          command: 'echo "concurrent"'
        })
      )
    );

    const duration = performance.now() - start;

    console.log(`\nâš¡ Concurrent Execution (${concurrency} requests)`);
    console.log(`  Total time: ${duration.toFixed(2)}ms`);
    console.log(`  Avg per request: ${(duration / concurrency).toFixed(2)}ms\n`);

    expect(duration).toBeLessThan(5000); // 50 requests < 5s
  });
});
```

### 7.2 å‹åŠ›æµ‹è¯•

```typescript
// tests/stress/api-stress.test.ts
import request from 'supertest';
import { app } from '@/app';
import * as os from 'os';

interface StressTestResult {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  duration: number;
  requestsPerSecond: number;
  avgResponseTime: number;
  errors: Map<string, number>;
}

class StressTest {
  private results: {
    status: number;
    duration: number;
    error?: string;
  }[] = [];

  async sendRequest(url: string, body: any): Promise<void> {
    const start = Date.now();

    try {
      const response = await request(app)
        .post(url)
        .send(body);

      this.results.push({
        status: response.status,
        duration: Date.now() - start
      });
    } catch (error) {
      this.results.push({
        status: 500,
        duration: Date.now() - start,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  async run(url: string, body: any, options: {
    duration: number;      // æµ‹è¯•æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
    rps: number;          // æ¯ç§’è¯·æ±‚æ•°
  }): Promise<void> {
    const { duration, rps } = options;
    const interval = 1000 / rps;
    const endTime = Date.now() + (duration * 1000);

    console.log(`\nğŸ”¥ Starting stress test:`);
    console.log(`  Duration: ${duration}s`);
    console.log(`  Target RPS: ${rps}`);
    console.log(`  Total requests: ~${duration * rps}\n`);

    while (Date.now() < endTime) {
      const requestStart = Date.now();

      this.sendRequest(url, body).catch(() => {
        // é”™è¯¯å·²åœ¨ sendRequest ä¸­å¤„ç†
      });

      const elapsed = Date.now() - requestStart;
      const sleep = Math.max(0, interval - elapsed);

      if (sleep > 0) {
        await new Promise(resolve => setTimeout(resolve, sleep));
      }
    }

    // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    await new Promise(resolve => setTimeout(resolve, 5000));
  }

  getResults(): StressTestResult {
    const successful = this.results.filter(r => r.status === 200);
    const failed = this.results.filter(r => r.status !== 200);

    const errors = new Map<string, number>();
    failed.forEach(r => {
      const key = r.error || `HTTP ${r.status}`;
      errors.set(key, (errors.get(key) || 0) + 1);
    });

    const totalDuration = this.results.reduce((sum, r) => sum + r.duration, 0);
    const testDuration = this.results.length > 0
      ? this.results[this.results.length - 1].duration
      : 0;

    return {
      totalRequests: this.results.length,
      successfulRequests: successful.length,
      failedRequests: failed.length,
      duration: testDuration,
      requestsPerSecond: this.results.length / (testDuration / 1000),
      avgResponseTime: totalDuration / this.results.length,
      errors
    };
  }

  printResults(): void {
    const results = this.getResults();

    console.log(`\nğŸ“Š Stress Test Results:`);
    console.log(`  Total requests:     ${results.totalRequests}`);
    console.log(`  Successful:         ${results.successfulRequests}`);
    console.log(`  Failed:             ${results.failedRequests}`);
    console.log(`  Success rate:       ${((results.successfulRequests / results.totalRequests) * 100).toFixed(2)}%`);
    console.log(`  Requests/sec:       ${results.requestsPerSecond.toFixed(2)}`);
    console.log(`  Avg response time:  ${results.avgResponseTime.toFixed(2)}ms`);

    if (results.errors.size > 0) {
      console.log(`\n  Errors:`);
      results.errors.forEach((count, error) => {
        console.log(`    ${error}: ${count}`);
      });
    }
    console.log();
  }

  reset(): void {
    this.results = [];
  }
}

describe('API å‹åŠ›æµ‹è¯•', () => {
  let stressTest: StressTest;

  beforeEach(() => {
    stressTest = new StressTest();
  });

  it('åº”è¯¥æ‰¿å—ä¸­ç­‰è´Ÿè½½', async () => {
    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "stress test"' }
    }, {
      duration: 30,  // 30ç§’
      rps: 50        // 50 requests/sec
    });

    stressTest.printResults();

    const results = stressTest.getResults();
    expect(results.successfulRequests / results.totalRequests).toBeGreaterThan(0.95);
  }, 60000);

  it('åº”è¯¥æ‰¿å—é«˜è´Ÿè½½', async () => {
    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "high load"' }
    }, {
      duration: 60,   // 60ç§’
      rps: 200        // 200 requests/sec
    });

    stressTest.printResults();

    const results = stressTest.getResults();
    expect(results.successfulRequests / results.totalRequests).toBeGreaterThan(0.90);
  }, 120000);

  it('åº”è¯¥æŠ¥å‘Šç³»ç»Ÿèµ„æºä½¿ç”¨', async () => {
    const initialMemory = process.memoryUsage();
    const initialCPU = process.cpuUsage();

    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "resource test"' }
    }, {
      duration: 30,
      rps: 100
    });

    const finalMemory = process.memoryUsage();
    const finalCPU = process.cpuUsage(initialCPU);

    console.log(`\nğŸ’» Resource Usage:`);
    console.log(`  Memory:`);
    console.log(`    Heap Used: ${((finalMemory.heapUsed - initialMemory.heapUsed) / 1024 / 1024).toFixed(2)} MB`);
    console.log(`    External: ${((finalMemory.external - initialMemory.external) / 1024 / 1024).toFixed(2)} MB`);
    console.log(`  CPU:`);
    console.log(`    User: ${(finalCPU.user / 1000000).toFixed(2)}s`);
    console.log(`    System: ${(finalCPU.system / 1000000).toFixed(2)}s`);
    console.log();
  }, 60000);
});
```

## 8. CI/CD æµç¨‹

### 8.1 GitHub Actions é…ç½®

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  NODE_VERSION: '18.x'
  JAVA_VERSION: '17'

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check formatting
        run: npm run format:check

      - name: Type check
        run: npm run type-check

  # å•å…ƒæµ‹è¯•
  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-unit

      - name: Check coverage thresholds
        run: npm run test:coverage-check

  # é›†æˆæµ‹è¯•
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: claudecode_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run database migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/claudecode_test

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/claudecode_test
          REDIS_URL: redis://localhost:6379

  # E2E æµ‹è¯•
  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

  # æ€§èƒ½æµ‹è¯•
  performance-test:
    name: Performance Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run performance tests
        run: npm run test:performance

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: performance-results/

  # å®‰å…¨æ‰«æ
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Run npm audit
        run: npm audit --audit-level=moderate

      - name: Run Snyk scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

      - name: Run SAST scan
        uses: github/codeql-action/analyze@v2

  # æ„å»º
  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, unit-test, integration-test]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/

  # éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, e2e-test]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.claudecode.example.com

    steps:
      - uses: actions/checkout@v3

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist
          path: dist/

      - name: Deploy to staging
        run: |
          # éƒ¨ç½²é€»è¾‘
          echo "Deploying to staging..."

      - name: Run smoke tests
        run: npm run test:smoke -- --env=staging

  # éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, e2e-test, security-scan]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://claudecode.example.com

    steps:
      - uses: actions/checkout@v3

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist
          path: dist/

      - name: Deploy to production
        run: |
          # éƒ¨ç½²é€»è¾‘
          echo "Deploying to production..."

      - name: Run smoke tests
        run: npm run test:smoke -- --env=production

      - name: Create release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          draft: false
          prerelease: false
```

### 8.2 CI/CD æµç¨‹å›¾

```mermaid
graph TB
    A[ä»£ç æäº¤] --> B[Lintæ£€æŸ¥]
    B --> C[å•å…ƒæµ‹è¯•]
    C --> D[é›†æˆæµ‹è¯•]
    D --> E[E2Eæµ‹è¯•]
    E --> F[å®‰å…¨æ‰«æ]
    F --> G[æ„å»º]

    G --> H{åˆ†æ”¯åˆ¤æ–­}

    H -->|develop| I[éƒ¨ç½²åˆ°Staging]
    H -->|main| J[éƒ¨ç½²åˆ°Production]

    I --> K[Stagingå†’çƒŸæµ‹è¯•]
    J --> L[Productionå†’çƒŸæµ‹è¯•]

    K --> M[æµ‹è¯•é€šè¿‡]
    L --> N[å‘å¸ƒå®Œæˆ]

    B -.å¤±è´¥.-> O[åœæ­¢æµç¨‹]
    C -.å¤±è´¥.-> O
    D -.å¤±è´¥.-> O
    E -.å¤±è´¥.-> O
    F -.å¤±è´¥.-> O

    style A fill:#e1f5ff
    style G fill:#d4edda
    style N fill:#d4edda
    style O fill:#f8d7da
```

## 9. ä»£ç è´¨é‡å·¥å…·

### 9.1 ESLint é…ç½®

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint',
    'import',
    'jest',
    'security'
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
    'plugin:import/errors',
    'plugin:import/warnings',
    'plugin:import/typescript',
    'plugin:jest/recommended',
    'plugin:security/recommended',
    'prettier'
  ],
  rules: {
    // TypeScript è§„åˆ™
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_'
    }],
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/await-thenable': 'error',

    // Import è§„åˆ™
    'import/order': ['error', {
      'groups': [
        'builtin',
        'external',
        'internal',
        'parent',
        'sibling',
        'index'
      ],
      'newlines-between': 'always',
      'alphabetize': {
        'order': 'asc',
        'caseInsensitive': true
      }
    }],
    'import/no-unresolved': 'error',
    'import/no-cycle': 'error',

    // å®‰å…¨è§„åˆ™
    'security/detect-object-injection': 'warn',
    'security/detect-non-literal-regexp': 'warn',
    'security/detect-unsafe-regex': 'error',

    // é€šç”¨è§„åˆ™
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'no-debugger': 'error',
    'prefer-const': 'error',
    'no-var': 'error'
  },
  overrides: [
    {
      files: ['*.test.ts', '*.spec.ts'],
      env: {
        jest: true
      },
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
        'security/detect-object-injection': 'off'
      }
    }
  ]
};
```

### 9.2 SonarQube é…ç½®

```properties
# sonar-project.properties
sonar.projectKey=claude-code
sonar.projectName=Claude Code
sonar.projectVersion=1.0.0

sonar.sources=src
sonar.tests=tests
sonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**

# TypeScript é…ç½®
sonar.typescript.lcov.reportPaths=coverage/lcov.info
sonar.typescript.tsconfigPath=tsconfig.json

# æµ‹è¯•è¦†ç›–ç‡
sonar.coverage.exclusions=**/*.test.ts,**/*.spec.ts,**/tests/**

# ä»£ç é‡å¤
sonar.cpd.exclusions=**/*.test.ts,**/*.spec.ts

# è´¨é‡é—¨
sonar.qualitygate.wait=true

# ä»£ç è´¨é‡è§„åˆ™
sonar.javascript.coveragePlugin=lcov
sonar.testExecutionReportPaths=test-results/sonar-report.xml
```

### 9.3 ä»£ç è´¨é‡ç›‘æ§

```typescript
// scripts/quality-check.ts
import { execSync } from 'child_process';
import * as fs from 'fs';

interface QualityMetrics {
  coverage: {
    lines: number;
    statements: number;
    functions: number;
    branches: number;
  };
  lintIssues: {
    errors: number;
    warnings: number;
  };
  complexity: {
    average: number;
    max: number;
  };
  duplications: number;
}

function runQualityChecks(): QualityMetrics {
  console.log('ğŸ” Running quality checks...\n');

  // è¿è¡Œæµ‹è¯•è¦†ç›–ç‡
  console.log('1. Checking test coverage...');
  execSync('npm run test:coverage', { stdio: 'inherit' });
  const coverage = JSON.parse(
    fs.readFileSync('coverage/coverage-summary.json', 'utf-8')
  ).total;

  // è¿è¡Œ ESLint
  console.log('\n2. Running ESLint...');
  const lintOutput = execSync('npm run lint -- --format json', {
    encoding: 'utf-8'
  });
  const lintResults = JSON.parse(lintOutput);
  const lintIssues = {
    errors: lintResults.reduce((sum: number, r: any) => sum + r.errorCount, 0),
    warnings: lintResults.reduce((sum: number, r: any) => sum + r.warningCount, 0)
  };

  // è®¡ç®—å¤æ‚åº¦
  console.log('\n3. Analyzing code complexity...');
  const complexityOutput = execSync('npm run complexity -- --format json', {
    encoding: 'utf-8'
  });
  const complexityResults = JSON.parse(complexityOutput);
  const complexity = {
    average: complexityResults.average,
    max: complexityResults.max
  };

  // æ£€æŸ¥ä»£ç é‡å¤
  console.log('\n4. Checking for duplications...');
  const duplicationOutput = execSync('npm run duplications -- --format json', {
    encoding: 'utf-8'
  });
  const duplications = JSON.parse(duplicationOutput).percentage;

  return {
    coverage: {
      lines: coverage.lines.pct,
      statements: coverage.statements.pct,
      functions: coverage.functions.pct,
      branches: coverage.branches.pct
    },
    lintIssues,
    complexity,
    duplications
  };
}

function generateReport(metrics: QualityMetrics): void {
  console.log('\nğŸ“Š Quality Report:\n');

  console.log('Coverage:');
  console.log(`  Lines:      ${metrics.coverage.lines.toFixed(2)}%`);
  console.log(`  Statements: ${metrics.coverage.statements.toFixed(2)}%`);
  console.log(`  Functions:  ${metrics.coverage.functions.toFixed(2)}%`);
  console.log(`  Branches:   ${metrics.coverage.branches.toFixed(2)}%`);

  console.log('\nLint Issues:');
  console.log(`  Errors:   ${metrics.lintIssues.errors}`);
  console.log(`  Warnings: ${metrics.lintIssues.warnings}`);

  console.log('\nComplexity:');
  console.log(`  Average: ${metrics.complexity.average.toFixed(2)}`);
  console.log(`  Max:     ${metrics.complexity.max}`);

  console.log(`\nCode Duplication: ${metrics.duplications.toFixed(2)}%`);

  // è´¨é‡è¯„åˆ†
  const score = calculateQualityScore(metrics);
  console.log(`\nğŸ¯ Quality Score: ${score}/100`);

  if (score < 80) {
    console.error('\nâŒ Quality score is below threshold (80)');
    process.exit(1);
  } else {
    console.log('\nâœ… Quality checks passed!');
  }
}

function calculateQualityScore(metrics: QualityMetrics): number {
  const coverageScore = (
    metrics.coverage.lines +
    metrics.coverage.statements +
    metrics.coverage.functions +
    metrics.coverage.branches
  ) / 4;

  const lintScore = Math.max(0, 100 - (
    metrics.lintIssues.errors * 5 +
    metrics.lintIssues.warnings * 1
  ));

  const complexityScore = Math.max(0, 100 - (
    (metrics.complexity.average - 10) * 2 +
    (metrics.complexity.max - 20)
  ));

  const duplicationScore = Math.max(0, 100 - metrics.duplications * 10);

  return (coverageScore * 0.4 + lintScore * 0.3 + complexityScore * 0.2 + duplicationScore * 0.1);
}

// è¿è¡Œè´¨é‡æ£€æŸ¥
const metrics = runQualityChecks();
generateReport(metrics);
```

## 10. å®æˆ˜æ¡ˆä¾‹å’Œæœ€ä½³å®è·µ

### 10.1 æµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTDDï¼‰ç¤ºä¾‹

```typescript
// æ­¥éª¤ 1: ç¼–å†™å¤±è´¥çš„æµ‹è¯•
describe('FileSearch Tool', () => {
  it('åº”è¯¥åœ¨ç›®å½•ä¸­æœç´¢æ–‡ä»¶', async () => {
    const searchTool = new FileSearchTool();

    const result = await searchTool.execute({
      pattern: '*.ts',
      directory: '/project/src'
    });

    expect(result.success).toBe(true);
    expect(result.files).toContain('/project/src/index.ts');
  });
});

// æ­¥éª¤ 2: ç¼–å†™æœ€å°å®ç°
class FileSearchTool implements Tool {
  async execute(params: { pattern: string; directory: string }): Promise<ToolResult> {
    // æœ€å°å®ç°è®©æµ‹è¯•é€šè¿‡
    return {
      success: true,
      files: ['/project/src/index.ts']
    };
  }
}

// æ­¥éª¤ 3: é‡æ„å®ç°
class FileSearchTool implements Tool {
  async execute(params: { pattern: string; directory: string }): Promise<ToolResult> {
    const { pattern, directory } = params;

    try {
      const files = await this.searchFiles(directory, pattern);
      return {
        success: true,
        files
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  private async searchFiles(dir: string, pattern: string): Promise<string[]> {
    // å®é™…å®ç°
    const glob = require('glob');
    return new Promise((resolve, reject) => {
      glob(pattern, { cwd: dir, absolute: true }, (err, files) => {
        if (err) reject(err);
        else resolve(files);
      });
    });
  }
}
```

### 10.2 æµ‹è¯•æœ€ä½³å®è·µ

```typescript
// âœ… å¥½çš„æµ‹è¯•å®è·µ

describe('ToolExecutor', () => {
  // 1. æ¸…æ™°çš„æµ‹è¯•æè¿°
  it('åº”è¯¥åœ¨å·¥å…·æ‰§è¡Œå¤±è´¥æ—¶æŠ›å‡º ToolExecutionException', async () => {
    // 2. AAA æ¨¡å¼: Arrange, Act, Assert

    // Arrange
    const executor = new ToolExecutor();
    const mockTool = createMockTool({ shouldFail: true });
    executor.registerTool('mock', mockTool);

    // Act & Assert
    await expect(
      executor.execute('mock', {})
    ).rejects.toThrow(ToolExecutionException);
  });

  // 3. æ¯ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä»¶äº‹
  it('åº”è¯¥è®°å½•å·¥å…·æ‰§è¡Œæ—¶é—´', async () => {
    const executor = new ToolExecutor();
    const logger = createMockLogger();
    executor.setLogger(logger);

    await executor.execute('bash', { command: 'echo test' });

    expect(logger.info).toHaveBeenCalledWith(
      expect.stringContaining('execution time')
    );
  });

  // 4. ä½¿ç”¨æµ‹è¯•æ•°æ®æ„å»ºå™¨
  it('åº”è¯¥éªŒè¯å·¥å…·å‚æ•°', async () => {
    const executor = new ToolExecutor();
    const params = new ToolParamsBuilder()
      .withCommand('ls')
      .withTimeout(5000)
      .build();

    const result = await executor.execute('bash', params);

    expect(result.success).toBe(true);
  });

  // 5. æ­£ç¡®æ¸…ç†æµ‹è¯•èµ„æº
  afterEach(() => {
    executor.cleanup();
    jest.clearAllMocks();
  });
});

// âŒ ä¸å¥½çš„æµ‹è¯•å®è·µ

describe('Bad Tests', () => {
  // 1. æ¨¡ç³Šçš„æµ‹è¯•æè¿°
  it('test1', () => {
    // ...
  });

  // 2. æµ‹è¯•è¿‡å¤šçš„å†…å®¹
  it('should do everything', async () => {
    // éªŒè¯å¤šä¸ªä¸ç›¸å…³çš„åŠŸèƒ½
    expect(toolA.execute()).toBeTruthy();
    expect(toolB.execute()).toBeTruthy();
    expect(toolC.execute()).toBeTruthy();
  });

  // 3. ä¾èµ–æµ‹è¯•æ‰§è¡Œé¡ºåº
  it('step 1', () => {
    globalState.value = 'test';
  });

  it('step 2', () => {
    expect(globalState.value).toBe('test'); // ä¾èµ–å‰ä¸€ä¸ªæµ‹è¯•
  });

  // 4. ç¡¬ç¼–ç çš„é­”æ³•å€¼
  it('should work', () => {
    const result = tool.execute({ timeout: 12345 });
    expect(result.data.length).toBe(42);
  });
});
```

### 10.3 æµ‹è¯•é‡‘å­—å¡”å®è·µ

```typescript
// å•å…ƒæµ‹è¯• (60%) - å¿«é€Ÿã€éš”ç¦»ã€ç²¾ç¡®
describe('BashTool Unit Tests', () => {
  it('åº”è¯¥æ„å»ºæ­£ç¡®çš„å‘½ä»¤å‚æ•°', () => {
    const bashTool = new BashTool();
    const args = bashTool.buildCommandArgs({
      command: 'ls -la',
      timeout: 5000
    });

    expect(args).toEqual(['bash', '-c', 'ls -la']);
  });
});

// é›†æˆæµ‹è¯• (30%) - éªŒè¯ç»„ä»¶åä½œ
describe('BashTool Integration Tests', () => {
  it('åº”è¯¥æ­£ç¡®æ‰§è¡Œç³»ç»Ÿå‘½ä»¤', async () => {
    const bashTool = new BashTool();

    const result = await bashTool.execute({
      command: 'echo "test"'
    });

    expect(result.stdout).toContain('test');
    expect(result.exitCode).toBe(0);
  });
});

// E2E æµ‹è¯• (10%) - éªŒè¯å®Œæ•´ç”¨æˆ·æµç¨‹
describe('Complete Tool Execution Flow E2E', () => {
  it('åº”è¯¥ä»ç”¨æˆ·è¯·æ±‚åˆ°ç»“æœè¿”å›å®Œæ•´å·¥ä½œ', async ({ page }) => {
    await page.goto('/');
    await page.fill('[data-testid="input"]', 'List files');
    await page.click('[data-testid="submit"]');

    await expect(page.locator('[data-testid="result"]'))
      .toContainText('Files in directory');
  });
});
```

## 11. FAQ

**Q: å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

A: å•å…ƒæµ‹è¯•å…³æ³¨å•ä¸ªå‡½æ•°æˆ–ç±»çš„è¡Œä¸ºï¼Œå®Œå…¨éš”ç¦»å¤–éƒ¨ä¾èµ–ï¼ˆä½¿ç”¨ Mockï¼‰ã€‚é›†æˆæµ‹è¯•éªŒè¯å¤šä¸ªç»„ä»¶åä½œæ—¶çš„è¡Œä¸ºï¼Œé€šå¸¸åŒ…å«çœŸå®çš„ä¾èµ–ï¼ˆå¦‚æ•°æ®åº“ã€æ–‡ä»¶ç³»ç»Ÿï¼‰ã€‚

**Q: æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°å¤šå°‘åˆé€‚ï¼Ÿ**

A: ä¸€èˆ¬å»ºè®®ï¼š
- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š90%+
- å·¥å…·å’Œå®‰å…¨æ¨¡å—ï¼š85%+
- æ•´ä½“é¡¹ç›®ï¼š80%+

ä½†è¦†ç›–ç‡ä¸æ˜¯å”¯ä¸€æŒ‡æ ‡ï¼Œæµ‹è¯•è´¨é‡æ›´é‡è¦ã€‚

**Q: å¦‚ä½•æµ‹è¯•å¼‚æ­¥ä»£ç ï¼Ÿ**

A: ä½¿ç”¨ `async/await` æˆ–è¿”å› Promiseï¼Œç¡®ä¿æµ‹è¯•ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆï¼š

```typescript
it('should handle async operation', async () => {
  const result = await asyncFunction();
  expect(result).toBe(expected);
});
```

**Q: Mock å’Œ Stub æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ**

A: Mock ç”¨äºéªŒè¯è¡Œä¸ºï¼ˆæ˜¯å¦è¢«è°ƒç”¨ã€å¦‚ä½•è¢«è°ƒç”¨ï¼‰ï¼ŒStub ç”¨äºæä¾›é¢„å®šä¹‰çš„å“åº”ã€‚Mock æ›´å…³æ³¨äº¤äº’ï¼ŒStub æ›´å…³æ³¨çŠ¶æ€ã€‚

**Q: å¦‚ä½•å¤„ç†æµ‹è¯•ä¸­çš„æ—¶é—´ä¾èµ–ï¼Ÿ**

A: ä½¿ç”¨ Jest çš„å®šæ—¶å™¨ Mockï¼š

```typescript
jest.useFakeTimers();
functionThatUsesTimer();
jest.advanceTimersByTime(1000);
expect(callback).toHaveBeenCalled();
jest.useRealTimers();
```

**Q: E2E æµ‹è¯•æ‰§è¡Œç¼“æ…¢æ€ä¹ˆåŠï¼Ÿ**

A:
1. å¹¶è¡Œæ‰§è¡Œæµ‹è¯•
2. åªåœ¨å…³é”®åœºæ™¯ä½¿ç”¨ E2E æµ‹è¯•
3. ä½¿ç”¨æµ‹è¯•æ•°æ®å¿«ç…§
4. ä¼˜åŒ–æµ‹è¯•ç¯å¢ƒé…ç½®

**Q: å¦‚ä½•æµ‹è¯•é”™è¯¯åœºæ™¯ï¼Ÿ**

A: ä½¿ç”¨ `expect().toThrow()` æˆ– `expect().rejects.toThrow()`ï¼š

```typescript
expect(() => {
  dangerousFunction();
}).toThrow('Expected error message');

await expect(asyncDangerousFunction())
  .rejects.toThrow(CustomError);
```

**Q: CI/CD ä¸­æµ‹è¯•å¤±è´¥å¦‚ä½•è°ƒè¯•ï¼Ÿ**

A:
1. æŸ¥çœ‹è¯¦ç»†çš„æµ‹è¯•æ—¥å¿—
2. ä¸‹è½½æµ‹è¯•æˆªå›¾/è§†é¢‘ï¼ˆE2Eï¼‰
3. åœ¨æœ¬åœ°å¤ç° CI ç¯å¢ƒ
4. ä½¿ç”¨ `--verbose` å’Œ `--no-coverage` è·å–æ›´å¤šä¿¡æ¯

**Q: å¦‚ä½•ç»„ç»‡å¤§å‹é¡¹ç›®çš„æµ‹è¯•ä»£ç ï¼Ÿ**

A:
1. æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡æµ‹è¯•ç›®å½•
2. ä½¿ç”¨å…±äº«çš„æµ‹è¯•å·¥å…·å’Œè¾…åŠ©å‡½æ•°
3. åˆ›å»ºæµ‹è¯•æ•°æ®å·¥å‚
4. ç»´æŠ¤æ¸…æ™°çš„å‘½åçº¦å®š

**Q: æ€§èƒ½æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•çš„åŒºåˆ«ï¼Ÿ**

A: æ€§èƒ½æµ‹è¯•æµ‹é‡ç³»ç»Ÿåœ¨æ­£å¸¸è´Ÿè½½ä¸‹çš„å“åº”æ—¶é—´ã€ååé‡ç­‰æŒ‡æ ‡ã€‚å‹åŠ›æµ‹è¯•åœ¨æç«¯è´Ÿè½½ä¸‹æµ‹è¯•ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œæ¢å¤èƒ½åŠ›ã€‚

---

é€šè¿‡å®Œå–„çš„æµ‹è¯•ä¸è´¨é‡ä¿è¯ä½“ç³»ï¼ŒClaude Code ç¡®ä¿äº†ç³»ç»Ÿçš„ç¨³å®šæ€§ã€å¯é æ€§å’Œé«˜è´¨é‡çš„ç”¨æˆ·ä½“éªŒã€‚æµ‹è¯•ä¸ä»…æ˜¯è´¨é‡ä¿è¯æ‰‹æ®µï¼Œæ›´æ˜¯å¼€å‘è¿‡ç¨‹ä¸­çš„é‡è¦æ–‡æ¡£å’Œè®¾è®¡å·¥å…·ã€‚
