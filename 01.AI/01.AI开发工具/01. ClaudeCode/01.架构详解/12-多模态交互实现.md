---
title: Claude Codeæ¶æ„è¯¦è§£(åäºŒ):å¤šæ¨¡æ€äº¤äº’å®ç°
date: 2025-01-14
permalink: /ai/claude-code/architecture/12-multimodal-interaction.html
tags:
  - Claude Code
  - å¤šæ¨¡æ€
  - Vision API
  - PDFè§£æ
categories:
  - AI
  - Claude Code
---

# ç¬¬12ç¯‡:å¤šæ¨¡æ€äº¤äº’å®ç°

## å¼•è¨€

åœ¨ç°ä»£AIåº”ç”¨ä¸­,ä»…ä»…å¤„ç†æ–‡æœ¬å·²ç»è¿œè¿œä¸å¤Ÿã€‚å¼€å‘è€…ç»å¸¸éœ€è¦:
- åˆ†æUIæˆªå›¾å¹¶ç”Ÿæˆå¯¹åº”çš„ä»£ç 
- è§£æPDFæ–‡æ¡£æå–å…³é”®ä¿¡æ¯
- ç†è§£ä»£ç é«˜äº®åçš„æ˜¾ç¤ºæ•ˆæœ
- é¢„è§ˆMarkdownæ–‡æ¡£çš„æ¸²æŸ“ç»“æœ

Claude Codeé€šè¿‡å¼ºå¤§çš„å¤šæ¨¡æ€èƒ½åŠ›,æ”¯æŒå›¾åƒã€PDFã€ä»£ç æ¸²æŸ“ç­‰å¤šç§åª’ä½“ç±»å‹çš„å¤„ç†,è®©AIèƒ½å¤Ÿ"çœ‹åˆ°"å’Œ"ç†è§£"æ›´ä¸°å¯Œçš„ä¿¡æ¯ã€‚

### æœ¬æ–‡ç›®æ ‡

å­¦å®Œæœ¬æ–‡,ä½ å°†æŒæ¡:
- Claude Vision APIçš„ä½¿ç”¨æ–¹æ³•
- æˆªå›¾åˆ†æå’ŒOCRå®ç°
- PDFæ–‡æ¡£çš„æ™ºèƒ½è§£æ
- ä»£ç é«˜äº®å’ŒMarkdownæ¸²æŸ“
- å¤šæ¨¡æ€ä¸Šä¸‹æ–‡ç®¡ç†ç­–ç•¥

---

## ä¸€ã€å¤šæ¨¡æ€äº¤äº’æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯å¤šæ¨¡æ€

**å¤šæ¨¡æ€(Multimodal)**æ˜¯æŒ‡AIç³»ç»Ÿèƒ½å¤Ÿç†è§£å’Œå¤„ç†å¤šç§ç±»å‹çš„è¾“å…¥æ•°æ®:

```mermaid
graph TB
    A[å¤šæ¨¡æ€è¾“å…¥] --> B[æ–‡æœ¬]
    A --> C[å›¾åƒ]
    A --> D[PDF]
    A --> E[ä»£ç ]
    A --> F[éŸ³é¢‘]

    B --> G[AIå¤„ç†å¼•æ“]
    C --> G
    D --> G
    E --> G
    F --> G

    G --> H[ç»¼åˆç†è§£]
    H --> I[æ™ºèƒ½å“åº”]

    style A fill:#e1f5ff,stroke:#333,stroke-width:3px
    style G fill:#ffe1f5,stroke:#333,stroke-width:2px
```

### 1.2 Claude Codeæ”¯æŒçš„æ¨¡æ€ç±»å‹

| æ¨¡æ€ç±»å‹ | æ”¯æŒèƒ½åŠ› | å…¸å‹åœºæ™¯ |
|---------|---------|---------|
| **æ–‡æœ¬** | è‡ªç„¶è¯­è¨€ç†è§£ã€ä»£ç ç†è§£ | å¯¹è¯ã€ä»£ç åˆ†æ |
| **å›¾åƒ** | æˆªå›¾åˆ†æã€UIç†è§£ã€OCR | è®¾è®¡ç¨¿è½¬ä»£ç  |
| **PDF** | æ–‡æ¡£è§£æã€è¡¨æ ¼æå– | æŠ€æœ¯æ–‡æ¡£åˆ†æ |
| **ä»£ç ** | è¯­æ³•é«˜äº®ã€ç»“æ„åŒ–å±•ç¤º | ä»£ç å®¡æŸ¥ |
| **Markdown** | å®æ—¶æ¸²æŸ“é¢„è§ˆ | æ–‡æ¡£ç¼–å†™ |
| **Jupyter** | Notebookæ¸²æŸ“ | æ•°æ®åˆ†æ |

### 1.3 å¤šæ¨¡æ€å¤„ç†æ¶æ„

```mermaid
graph TB
    subgraph "è¾“å…¥å¤„ç†å±‚"
        A1[å›¾åƒè¾“å…¥]
        A2[PDFè¾“å…¥]
        A3[ä»£ç è¾“å…¥]
    end

    subgraph "é¢„å¤„ç†å±‚"
        B1[å›¾åƒç¼–ç ]
        B2[PDFè§£æ]
        B3[è¯­æ³•é«˜äº®]
    end

    subgraph "AIç†è§£å±‚"
        C[Claude Vision API]
    end

    subgraph "è¾“å‡ºæ¸²æŸ“å±‚"
        D1[æ–‡æœ¬è¾“å‡º]
        D2[ä»£ç å—æ¸²æŸ“]
        D3[Markdowné¢„è§ˆ]
    end

    A1 --> B1 --> C
    A2 --> B2 --> C
    A3 --> B3 --> C

    C --> D1
    C --> D2
    C --> D3

    style C fill:#ffe1f5,stroke:#333,stroke-width:2px
```

---

## äºŒã€å›¾åƒå¤„ç†èƒ½åŠ›(Claude Vision API)

### 2.1 Vision APIåŸºç¡€

Claude 3.5 Sonnetæ”¯æŒåŸç”Ÿçš„å›¾åƒç†è§£èƒ½åŠ›,å¯ä»¥:
- è¯†åˆ«å›¾åƒå†…å®¹
- æå–å›¾åƒä¸­çš„æ–‡æœ¬(OCR)
- ç†è§£UIå¸ƒå±€
- åˆ†æå›¾è¡¨å’Œæ•°æ®å¯è§†åŒ–

**APIè°ƒç”¨æ ¼å¼**:

```typescript
import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs';

// å›¾åƒå†…å®¹ç±»å‹å®šä¹‰
interface ImageContent {
  type: 'image';
  source: {
    type: 'base64';
    media_type: 'image/png' | 'image/jpeg' | 'image/gif' | 'image/webp';
    data: string; // Base64ç¼–ç çš„å›¾åƒæ•°æ®
  };
}

// Vision APIè°ƒç”¨
class VisionAPI {
  private client: Anthropic;

  constructor(apiKey: string) {
    this.client = new Anthropic({ apiKey });
  }

  /**
   * åˆ†æå›¾åƒ
   * @param imagePath å›¾åƒæ–‡ä»¶è·¯å¾„
   * @param prompt åˆ†ææç¤ºè¯
   */
  async analyzeImage(imagePath: string, prompt: string): Promise<string> {
    // è¯»å–å›¾åƒæ–‡ä»¶
    const imageBuffer = fs.readFileSync(imagePath);
    const base64Image = imageBuffer.toString('base64');

    // æ£€æµ‹å›¾åƒç±»å‹
    const mediaType = this.detectMediaType(imagePath);

    // æ„é€ æ¶ˆæ¯
    const response = await this.client.messages.create({
      model: 'claude-3-5-sonnet-20250929',
      max_tokens: 4096,
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: mediaType,
                data: base64Image
              }
            },
            {
              type: 'text',
              text: prompt
            }
          ]
        }
      ]
    });

    return response.content[0].type === 'text'
      ? response.content[0].text
      : '';
  }

  /**
   * æ£€æµ‹å›¾åƒMIMEç±»å‹
   */
  private detectMediaType(filePath: string):
    'image/png' | 'image/jpeg' | 'image/gif' | 'image/webp' {
    const ext = filePath.toLowerCase().split('.').pop();

    switch (ext) {
      case 'png': return 'image/png';
      case 'jpg':
      case 'jpeg': return 'image/jpeg';
      case 'gif': return 'image/gif';
      case 'webp': return 'image/webp';
      default: return 'image/png';
    }
  }

  /**
   * æ‰¹é‡åˆ†æå¤šå¼ å›¾åƒ
   */
  async analyzeMultipleImages(
    images: Array<{ path: string; description?: string }>,
    prompt: string
  ): Promise<string> {
    const imageContents: Array<ImageContent | { type: 'text'; text: string }> = [];

    // æ·»åŠ æ‰€æœ‰å›¾åƒ
    for (const img of images) {
      const imageBuffer = fs.readFileSync(img.path);
      const base64Image = imageBuffer.toString('base64');
      const mediaType = this.detectMediaType(img.path);

      imageContents.push({
        type: 'image',
        source: {
          type: 'base64',
          media_type: mediaType,
          data: base64Image
        }
      });

      // å¦‚æœæœ‰æè¿°,æ·»åŠ æ–‡æœ¬è¯´æ˜
      if (img.description) {
        imageContents.push({
          type: 'text',
          text: `[å›¾åƒè¯´æ˜: ${img.description}]`
        });
      }
    }

    // æ·»åŠ åˆ†ææç¤º
    imageContents.push({
      type: 'text',
      text: prompt
    });

    const response = await this.client.messages.create({
      model: 'claude-3-5-sonnet-20250929',
      max_tokens: 8000,
      messages: [
        {
          role: 'user',
          content: imageContents
        }
      ]
    });

    return response.content[0].type === 'text'
      ? response.content[0].text
      : '';
  }
}
```

### 2.2 å›¾åƒé¢„å¤„ç†

åœ¨æŸäº›æƒ…å†µä¸‹,éœ€è¦å¯¹å›¾åƒè¿›è¡Œé¢„å¤„ç†ä»¥æå‡è¯†åˆ«æ•ˆæœ:

```typescript
import sharp from 'sharp';

/**
 * å›¾åƒé¢„å¤„ç†å·¥å…·
 */
class ImagePreprocessor {
  /**
   * è°ƒæ•´å›¾åƒå¤§å°(ä¿æŒå®½é«˜æ¯”)
   */
  async resize(
    inputPath: string,
    outputPath: string,
    maxWidth: number = 1568,
    maxHeight: number = 1568
  ): Promise<void> {
    await sharp(inputPath)
      .resize(maxWidth, maxHeight, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .toFile(outputPath);
  }

  /**
   * è½¬æ¢å›¾åƒæ ¼å¼
   */
  async convert(
    inputPath: string,
    outputPath: string,
    format: 'png' | 'jpeg' | 'webp'
  ): Promise<void> {
    const image = sharp(inputPath);

    switch (format) {
      case 'png':
        await image.png().toFile(outputPath);
        break;
      case 'jpeg':
        await image.jpeg({ quality: 90 }).toFile(outputPath);
        break;
      case 'webp':
        await image.webp({ quality: 90 }).toFile(outputPath);
        break;
    }
  }

  /**
   * å¢å¼ºå¯¹æ¯”åº¦(æå‡OCRæ•ˆæœ)
   */
  async enhanceContrast(
    inputPath: string,
    outputPath: string
  ): Promise<void> {
    await sharp(inputPath)
      .normalize() // å½’ä¸€åŒ–
      .sharpen()   // é”åŒ–
      .toFile(outputPath);
  }

  /**
   * è½¬æ¢ä¸ºç°åº¦å›¾(å‡å°æ–‡ä»¶å¤§å°)
   */
  async toGrayscale(
    inputPath: string,
    outputPath: string
  ): Promise<void> {
    await sharp(inputPath)
      .grayscale()
      .toFile(outputPath);
  }

  /**
   * è·å–å›¾åƒå…ƒæ•°æ®
   */
  async getMetadata(imagePath: string): Promise<sharp.Metadata> {
    return await sharp(imagePath).metadata();
  }
}
```

---

## ä¸‰ã€æˆªå›¾åˆ†æå®ç°

### 3.1 UIæˆªå›¾è½¬ä»£ç 

è¿™æ˜¯æœ€å¸¸è§çš„å¤šæ¨¡æ€åº”ç”¨åœºæ™¯:ç”¨æˆ·æä¾›UIè®¾è®¡ç¨¿,AIç”Ÿæˆå¯¹åº”çš„å‰ç«¯ä»£ç ã€‚

```typescript
/**
 * UIæˆªå›¾åˆ†æå™¨
 */
class UIScreenshotAnalyzer {
  private vision: VisionAPI;
  private preprocessor: ImagePreprocessor;

  constructor(apiKey: string) {
    this.vision = new VisionAPI(apiKey);
    this.preprocessor = new ImagePreprocessor();
  }

  /**
   * åˆ†æUIæˆªå›¾å¹¶ç”Ÿæˆä»£ç 
   */
  async screenshotToCode(
    screenshotPath: string,
    options: {
      framework?: 'react' | 'vue' | 'html'; // ç›®æ ‡æ¡†æ¶
      styling?: 'css' | 'tailwind' | 'styled-components'; // æ ·å¼æ–¹æ¡ˆ
      responsive?: boolean; // æ˜¯å¦å“åº”å¼
      accessibility?: boolean; // æ˜¯å¦è€ƒè™‘æ— éšœç¢
    } = {}
  ): Promise<{
    code: string;
    analysis: string;
    suggestions: string[];
  }> {
    const {
      framework = 'react',
      styling = 'tailwind',
      responsive = true,
      accessibility = true
    } = options;

    // æ„é€ è¯¦ç»†çš„æç¤ºè¯
    const prompt = `
è¯·åˆ†æè¿™ä¸ªUIæˆªå›¾,å¹¶ç”Ÿæˆå¯¹åº”çš„${framework}ä»£ç ã€‚

è¦æ±‚:
1. æ¡†æ¶: ${framework}
2. æ ·å¼: ${styling}
3. å“åº”å¼: ${responsive ? 'æ˜¯' : 'å¦'}
4. æ— éšœç¢: ${accessibility ? 'æ˜¯' : 'å¦'}

è¯·æä¾›:
1. å®Œæ•´çš„å¯è¿è¡Œä»£ç 
2. UIç»“æ„åˆ†æ
3. æ”¹è¿›å»ºè®®

è¾“å‡ºæ ¼å¼:
\`\`\`${framework}
// ä»£ç 
\`\`\`

## åˆ†æ
[UIç»“æ„åˆ†æ]

## å»ºè®®
- [æ”¹è¿›å»ºè®®1]
- [æ”¹è¿›å»ºè®®2]
`;

    const result = await this.vision.analyzeImage(screenshotPath, prompt);

    // è§£æå“åº”
    return this.parseCodeResponse(result);
  }

  /**
   * è§£æAIå“åº”,æå–ä»£ç å’Œåˆ†æ
   */
  private parseCodeResponse(response: string): {
    code: string;
    analysis: string;
    suggestions: string[];
  } {
    // æå–ä»£ç å—
    const codeMatch = response.match(/```(?:\w+)?\n([\s\S]*?)```/);
    const code = codeMatch ? codeMatch[1].trim() : '';

    // æå–åˆ†æéƒ¨åˆ†
    const analysisMatch = response.match(/## åˆ†æ\n([\s\S]*?)(?=## |$)/);
    const analysis = analysisMatch ? analysisMatch[1].trim() : '';

    // æå–å»ºè®®
    const suggestionsMatch = response.match(/## å»ºè®®\n([\s\S]*?)$/);
    const suggestionsText = suggestionsMatch ? suggestionsMatch[1] : '';
    const suggestions = suggestionsText
      .split('\n')
      .filter(line => line.trim().startsWith('-'))
      .map(line => line.replace(/^-\s*/, '').trim());

    return { code, analysis, suggestions };
  }

  /**
   * å¯¹æ¯”ä¸¤ä¸ªUIæˆªå›¾çš„å·®å¼‚
   */
  async compareScreenshots(
    beforePath: string,
    afterPath: string
  ): Promise<{
    differences: string[];
    improvements: string[];
    regressions: string[];
  }> {
    const prompt = `
è¯·å¯¹æ¯”è¿™ä¸¤å¼ UIæˆªå›¾(ç¬¬ä¸€å¼ æ˜¯ä¿®æ”¹å‰,ç¬¬äºŒå¼ æ˜¯ä¿®æ”¹å):

1. åˆ—å‡ºæ‰€æœ‰å¯è§çš„å·®å¼‚
2. è¯†åˆ«æ”¹è¿›ä¹‹å¤„
3. è¯†åˆ«å¯èƒ½çš„é€€æ­¥

è¾“å‡ºæ ¼å¼:
## å·®å¼‚
- [å·®å¼‚1]
- [å·®å¼‚2]

## æ”¹è¿›
- [æ”¹è¿›1]

## é€€æ­¥
- [é€€æ­¥1]
`;

    const result = await this.vision.analyzeMultipleImages(
      [
        { path: beforePath, description: 'ä¿®æ”¹å‰' },
        { path: afterPath, description: 'ä¿®æ”¹å' }
      ],
      prompt
    );

    return this.parseComparisonResponse(result);
  }

  /**
   * è§£æå¯¹æ¯”å“åº”
   */
  private parseComparisonResponse(response: string): {
    differences: string[];
    improvements: string[];
    regressions: string[];
  } {
    const extractList = (section: string): string[] => {
      const match = response.match(
        new RegExp(`## ${section}\\n([\\s\\S]*?)(?=## |$)`)
      );
      if (!match) return [];

      return match[1]
        .split('\n')
        .filter(line => line.trim().startsWith('-'))
        .map(line => line.replace(/^-\s*/, '').trim());
    };

    return {
      differences: extractList('å·®å¼‚'),
      improvements: extractList('æ”¹è¿›'),
      regressions: extractList('é€€æ­¥')
    };
  }

  /**
   * æå–UIç»„ä»¶å±‚æ¬¡ç»“æ„
   */
  async extractComponentHierarchy(screenshotPath: string): Promise<{
    hierarchy: UIComponent;
    components: string[];
  }> {
    const prompt = `
è¯·åˆ†æè¿™ä¸ªUIæˆªå›¾,è¯†åˆ«å‡º:
1. é¡µé¢çš„ç»„ä»¶å±‚æ¬¡ç»“æ„
2. æ¯ä¸ªç»„ä»¶çš„ç±»å‹(Headerã€Buttonã€Cardç­‰)
3. æ¨èçš„ç»„ä»¶æ‹†åˆ†æ–¹æ¡ˆ

ä»¥JSONæ ¼å¼è¾“å‡º:
\`\`\`json
{
  "hierarchy": {
    "type": "Page",
    "children": [
      {
        "type": "Header",
        "children": []
      }
    ]
  },
  "components": ["Header", "Navigation", "Button"]
}
\`\`\`
`;

    const result = await this.vision.analyzeImage(screenshotPath, prompt);

    // æå–JSON
    const jsonMatch = result.match(/```json\n([\s\S]*?)```/);
    if (!jsonMatch) {
      throw new Error('Failed to extract component hierarchy');
    }

    return JSON.parse(jsonMatch[1]);
  }
}

// UIç»„ä»¶ç±»å‹å®šä¹‰
interface UIComponent {
  type: string;
  children: UIComponent[];
  props?: Record<string, any>;
}
```

### 3.2 OCRæ–‡å­—è¯†åˆ«

```typescript
/**
 * OCRæ–‡å­—è¯†åˆ«å·¥å…·
 */
class OCRTool {
  private vision: VisionAPI;

  constructor(apiKey: string) {
    this.vision = new VisionAPI(apiKey);
  }

  /**
   * æå–å›¾åƒä¸­çš„æ‰€æœ‰æ–‡å­—
   */
  async extractText(imagePath: string): Promise<{
    text: string;
    confidence: number;
  }> {
    const prompt = `
è¯·æå–è¿™å¼ å›¾ç‰‡ä¸­çš„æ‰€æœ‰æ–‡å­—ã€‚

è¦æ±‚:
1. ä¿æŒåŸæ–‡å¸ƒå±€å’Œæ ¼å¼
2. å¦‚æœæ˜¯å¤šåˆ—,æŒ‰ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹çš„é¡ºåº
3. ä¿ç•™æ®µè½ç»“æ„

è¾“å‡ºæ ¼å¼:
\`\`\`text
[æå–çš„æ–‡å­—]
\`\`\`

## ç½®ä¿¡åº¦
[high/medium/low]
`;

    const result = await this.vision.analyzeImage(imagePath, prompt);

    // æå–æ–‡å­—
    const textMatch = result.match(/```text\n([\s\S]*?)```/);
    const text = textMatch ? textMatch[1].trim() : '';

    // æå–ç½®ä¿¡åº¦
    const confidenceMatch = result.match(/## ç½®ä¿¡åº¦\n(\w+)/);
    const confidenceStr = confidenceMatch ? confidenceMatch[1] : 'medium';

    const confidence = {
      'high': 0.9,
      'medium': 0.7,
      'low': 0.5
    }[confidenceStr] || 0.7;

    return { text, confidence };
  }

  /**
   * æå–å›¾åƒä¸­çš„è¡¨æ ¼æ•°æ®
   */
  async extractTable(imagePath: string): Promise<{
    headers: string[];
    rows: string[][];
  }> {
    const prompt = `
è¯·è¯†åˆ«è¿™å¼ å›¾ç‰‡ä¸­çš„è¡¨æ ¼æ•°æ®ã€‚

ä»¥JSONæ ¼å¼è¾“å‡º:
\`\`\`json
{
  "headers": ["åˆ—1", "åˆ—2"],
  "rows": [
    ["æ•°æ®1", "æ•°æ®2"],
    ["æ•°æ®3", "æ•°æ®4"]
  ]
}
\`\`\`
`;

    const result = await this.vision.analyzeImage(imagePath, prompt);

    const jsonMatch = result.match(/```json\n([\s\S]*?)```/);
    if (!jsonMatch) {
      return { headers: [], rows: [] };
    }

    return JSON.parse(jsonMatch[1]);
  }

  /**
   * è¯†åˆ«ä»£ç æˆªå›¾
   */
  async extractCode(imagePath: string): Promise<{
    code: string;
    language: string;
  }> {
    const prompt = `
è¯·è¯†åˆ«è¿™å¼ ä»£ç æˆªå›¾ä¸­çš„ä»£ç ã€‚

è¦æ±‚:
1. ä¿æŒåŸä»£ç æ ¼å¼å’Œç¼©è¿›
2. è¯†åˆ«ç¼–ç¨‹è¯­è¨€
3. ä¿ç•™æ³¨é‡Š

è¾“å‡ºæ ¼å¼:
\`\`\`[è¯­è¨€]
[ä»£ç ]
\`\`\`

## è¯­è¨€
[ç¼–ç¨‹è¯­è¨€åç§°]
`;

    const result = await this.vision.analyzeImage(imagePath, prompt);

    // æå–ä»£ç 
    const codeMatch = result.match(/```(\w+)?\n([\s\S]*?)```/);
    const language = codeMatch ? codeMatch[1] || 'text' : 'text';
    const code = codeMatch ? codeMatch[2].trim() : '';

    return { code, language };
  }
}
```

---

## å››ã€PDFæ–‡æ¡£è§£æ

### 4.1 PDFå¤„ç†åŸºç¡€

Claudeå¯ä»¥ç›´æ¥å¤„ç†PDFæ–‡æ¡£,æå–æ–‡æœ¬å’Œç†è§£å¸ƒå±€:

```typescript
import pdf from 'pdf-parse';
import { PDFDocument } from 'pdf-lib';

/**
 * PDFæ–‡æ¡£å¤„ç†å™¨
 */
class PDFProcessor {
  private vision: VisionAPI;

  constructor(apiKey: string) {
    this.vision = new VisionAPI(apiKey);
  }

  /**
   * æå–PDFæ–‡æœ¬
   */
  async extractText(pdfPath: string): Promise<{
    text: string;
    pages: number;
    metadata: any;
  }> {
    const dataBuffer = fs.readFileSync(pdfPath);
    const data = await pdf(dataBuffer);

    return {
      text: data.text,
      pages: data.numpages,
      metadata: data.metadata
    };
  }

  /**
   * å°†PDFè½¬æ¢ä¸ºå›¾åƒè¿›è¡Œåˆ†æ
   */
  async analyzePDFPage(
    pdfPath: string,
    pageNumber: number,
    prompt: string
  ): Promise<string> {
    // 1. æå–PDFé¡µé¢ä¸ºå›¾åƒ
    const imagePath = await this.pdfPageToImage(pdfPath, pageNumber);

    // 2. ä½¿ç”¨Vision APIåˆ†æ
    const result = await this.vision.analyzeImage(imagePath, prompt);

    // 3. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    fs.unlinkSync(imagePath);

    return result;
  }

  /**
   * å°†PDFé¡µé¢è½¬æ¢ä¸ºå›¾åƒ
   */
  private async pdfPageToImage(
    pdfPath: string,
    pageNumber: number
  ): Promise<string> {
    // ä½¿ç”¨pdf-poppleræˆ–ghostscriptè½¬æ¢
    // è¿™é‡Œç®€åŒ–å¤„ç†,å®é™…éœ€è¦è°ƒç”¨å¤–éƒ¨å·¥å…·

    const outputPath = `/tmp/pdf-page-${Date.now()}.png`;

    // è°ƒç”¨pdftoppmæˆ–gså‘½ä»¤
    const { execSync } = require('child_process');
    execSync(
      `pdftoppm -f ${pageNumber} -l ${pageNumber} -png "${pdfPath}" "${outputPath.replace('.png', '')}"`
    );

    return outputPath;
  }

  /**
   * æ™ºèƒ½æå–PDFä¸­çš„è¡¨æ ¼
   */
  async extractTables(pdfPath: string): Promise<Array<{
    page: number;
    headers: string[];
    rows: string[][];
  }>> {
    const { numpages } = await this.extractText(pdfPath);
    const tables: Array<{
      page: number;
      headers: string[];
      rows: string[][];
    }> = [];

    // éå†æ¯ä¸€é¡µ
    for (let page = 1; page <= numpages; page++) {
      const prompt = `
è¯·è¯†åˆ«è¿™ä¸€é¡µä¸­çš„æ‰€æœ‰è¡¨æ ¼ã€‚

ä»¥JSONæ•°ç»„æ ¼å¼è¾“å‡º:
\`\`\`json
[
  {
    "headers": ["åˆ—1", "åˆ—2"],
    "rows": [["æ•°æ®1", "æ•°æ®2"]]
  }
]
\`\`\`
`;

      const result = await this.analyzePDFPage(pdfPath, page, prompt);

      try {
        const jsonMatch = result.match(/```json\n([\s\S]*?)```/);
        if (jsonMatch) {
          const pageTables = JSON.parse(jsonMatch[1]);
          pageTables.forEach((table: any) => {
            tables.push({ page, ...table });
          });
        }
      } catch (error) {
        console.error(`Failed to parse tables on page ${page}:`, error);
      }
    }

    return tables;
  }

  /**
   * æå–PDFæ–‡æ¡£ç»“æ„
   */
  async extractStructure(pdfPath: string): Promise<{
    title: string;
    sections: Array<{
      title: string;
      page: number;
      content: string;
    }>;
    references: string[];
  }> {
    // æå–å®Œæ•´æ–‡æœ¬
    const { text, pages } = await this.extractText(pdfPath);

    // ä½¿ç”¨Claudeåˆ†ææ–‡æ¡£ç»“æ„
    const client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY!
    });

    const response = await client.messages.create({
      model: 'claude-3-5-sonnet-20250929',
      max_tokens: 8000,
      messages: [
        {
          role: 'user',
          content: `
è¯·åˆ†æä»¥ä¸‹PDFæ–‡æ¡£çš„æ–‡æœ¬å†…å®¹,æå–:
1. æ–‡æ¡£æ ‡é¢˜
2. ç« èŠ‚ç»“æ„(æ ‡é¢˜å’Œé¡µç )
3. å‚è€ƒæ–‡çŒ®

æ–‡æ¡£å†…å®¹:
${text.slice(0, 50000)} // é™åˆ¶é•¿åº¦

ä»¥JSONæ ¼å¼è¾“å‡º:
\`\`\`json
{
  "title": "æ–‡æ¡£æ ‡é¢˜",
  "sections": [
    {
      "title": "ç« èŠ‚æ ‡é¢˜",
      "page": 1,
      "content": "ç« èŠ‚æ‘˜è¦"
    }
  ],
  "references": ["å‚è€ƒæ–‡çŒ®1"]
}
\`\`\`
`
        }
      ]
    });

    const resultText = response.content[0].type === 'text'
      ? response.content[0].text
      : '';

    const jsonMatch = resultText.match(/```json\n([\s\S]*?)```/);
    if (!jsonMatch) {
      throw new Error('Failed to extract document structure');
    }

    return JSON.parse(jsonMatch[1]);
  }
}
```

### 4.2 Readå·¥å…·çš„PDFæ”¯æŒ

Claude Codeçš„Readå·¥å…·åŸç”Ÿæ”¯æŒPDF:

```typescript
/**
 * å¢å¼ºçš„Readå·¥å…·,æ”¯æŒPDF
 */
class EnhancedReadTool {
  private pdfProcessor: PDFProcessor;

  constructor(apiKey: string) {
    this.pdfProcessor = new PDFProcessor(apiKey);
  }

  /**
   * è¯»å–æ–‡ä»¶(æ”¯æŒPDF)
   */
  async read(filePath: string, options?: {
    offset?: number;
    limit?: number;
  }): Promise<string> {
    const ext = filePath.toLowerCase().split('.').pop();

    if (ext === 'pdf') {
      return this.readPDF(filePath, options);
    } else {
      return this.readTextFile(filePath, options);
    }
  }

  /**
   * è¯»å–PDFæ–‡ä»¶
   */
  private async readPDF(
    filePath: string,
    options?: { offset?: number; limit?: number }
  ): Promise<string> {
    const { text, pages, metadata } = await this.pdfProcessor.extractText(filePath);

    // æŒ‰é¡µåˆ†å‰²
    const pageTexts = this.splitByPages(text, pages);

    // åº”ç”¨åç§»å’Œé™åˆ¶
    const offset = options?.offset || 0;
    const limit = options?.limit || pageTexts.length;
    const selectedPages = pageTexts.slice(offset, offset + limit);

    // æ ¼å¼åŒ–è¾“å‡º
    let result = `PDFæ–‡æ¡£: ${filePath}\n`;
    result += `æ€»é¡µæ•°: ${pages}\n`;
    result += `ä½œè€…: ${metadata?.Author || 'Unknown'}\n`;
    result += `åˆ›å»ºæ—¶é—´: ${metadata?.CreationDate || 'Unknown'}\n\n`;
    result += `æ˜¾ç¤ºé¡µé¢: ${offset + 1} - ${offset + selectedPages.length}\n`;
    result += '='.repeat(50) + '\n\n';

    selectedPages.forEach((pageText, idx) => {
      result += `[ç¬¬ ${offset + idx + 1} é¡µ]\n`;
      result += pageText;
      result += '\n\n' + '-'.repeat(50) + '\n\n';
    });

    return result;
  }

  /**
   * æŒ‰é¡µåˆ†å‰²PDFæ–‡æœ¬
   */
  private splitByPages(text: string, pages: number): string[] {
    // ç®€å•çš„é¡µé¢åˆ†å‰²ç­–ç•¥
    // å®é™…PDFåº“å¯èƒ½æä¾›æ›´ç²¾ç¡®çš„åˆ†é¡µä¿¡æ¯
    const lines = text.split('\n');
    const linesPerPage = Math.ceil(lines.length / pages);

    const pageTexts: string[] = [];
    for (let i = 0; i < pages; i++) {
      const start = i * linesPerPage;
      const end = Math.min((i + 1) * linesPerPage, lines.length);
      pageTexts.push(lines.slice(start, end).join('\n'));
    }

    return pageTexts;
  }

  /**
   * è¯»å–æ™®é€šæ–‡æœ¬æ–‡ä»¶
   */
  private async readTextFile(
    filePath: string,
    options?: { offset?: number; limit?: number }
  ): Promise<string> {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');

    const offset = options?.offset || 0;
    const limit = options?.limit || lines.length;
    const selectedLines = lines.slice(offset, offset + limit);

    return selectedLines
      .map((line, idx) => `${offset + idx + 1}\t${line}`)
      .join('\n');
  }
}
```

---

## äº”ã€ä»£ç é«˜äº®æ¸²æŸ“

### 5.1 è¯­æ³•é«˜äº®å®ç°

```typescript
import Prism from 'prismjs';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-java';
// ...åŠ è½½æ›´å¤šè¯­è¨€

/**
 * ä»£ç é«˜äº®æ¸²æŸ“å™¨
 */
class CodeHighlighter {
  /**
   * é«˜äº®ä»£ç 
   */
  highlight(code: string, language: string): string {
    const grammar = Prism.languages[language];
    if (!grammar) {
      return code; // ä¸æ”¯æŒçš„è¯­è¨€,è¿”å›åŸæ–‡
    }

    return Prism.highlight(code, grammar, language);
  }

  /**
   * é«˜äº®ä»£ç å—å¹¶æ·»åŠ è¡Œå·
   */
  highlightWithLineNumbers(
    code: string,
    language: string,
    startLine: number = 1
  ): string {
    const highlighted = this.highlight(code, language);
    const lines = highlighted.split('\n');

    return lines
      .map((line, idx) => {
        const lineNum = startLine + idx;
        return `<span class="line-number">${lineNum}</span>${line}`;
      })
      .join('\n');
  }

  /**
   * ç”ŸæˆHTMLä»£ç å—
   */
  toHTML(code: string, language: string, options?: {
    showLineNumbers?: boolean;
    highlightLines?: number[];
    startLine?: number;
  }): string {
    const {
      showLineNumbers = true,
      highlightLines = [],
      startLine = 1
    } = options || {};

    const highlighted = this.highlight(code, language);
    const lines = highlighted.split('\n');

    let html = `<pre class="language-${language}"><code>`;

    lines.forEach((line, idx) => {
      const lineNum = startLine + idx;
      const isHighlighted = highlightLines.includes(lineNum);

      let lineHTML = '<span class="code-line';
      if (isHighlighted) lineHTML += ' highlighted';
      lineHTML += '">';

      if (showLineNumbers) {
        lineHTML += `<span class="line-number">${lineNum}</span>`;
      }

      lineHTML += line;
      lineHTML += '</span>\n';

      html += lineHTML;
    });

    html += '</code></pre>';

    return html;
  }

  /**
   * æ£€æµ‹ä»£ç è¯­è¨€
   */
  detectLanguage(code: string, fileName?: string): string {
    // 1. æ ¹æ®æ–‡ä»¶æ‰©å±•å
    if (fileName) {
      const ext = fileName.split('.').pop()?.toLowerCase();
      const extMap: Record<string, string> = {
        'ts': 'typescript',
        'js': 'javascript',
        'py': 'python',
        'java': 'java',
        'cpp': 'cpp',
        'c': 'c',
        'rs': 'rust',
        'go': 'go',
        'rb': 'ruby',
        'php': 'php',
        'sh': 'bash',
        'yml': 'yaml',
        'yaml': 'yaml',
        'json': 'json',
        'md': 'markdown'
      };

      if (ext && extMap[ext]) {
        return extMap[ext];
      }
    }

    // 2. æ ¹æ®ä»£ç ç‰¹å¾
    if (/^\s*import\s+.*\s+from\s+['"]/.test(code)) {
      return 'javascript';
    }
    if (/^\s*from\s+.*\s+import\s+/.test(code)) {
      return 'python';
    }
    if (/^\s*package\s+\w+;/.test(code)) {
      return 'java';
    }
    if (/^\s*use\s+\w+/.test(code)) {
      return 'rust';
    }

    return 'text';
  }
}
```

### 5.2 ç»ˆç«¯è¾“å‡ºæ¸²æŸ“

```typescript
import ansiToHtml from 'ansi-to-html';
import chalk from 'chalk';

/**
 * ç»ˆç«¯è¾“å‡ºæ¸²æŸ“å™¨
 */
class TerminalRenderer {
  private converter: any;

  constructor() {
    this.converter = new ansiToHtml({
      fg: '#FFF',
      bg: '#000',
      newline: true,
      escapeXML: true
    });
  }

  /**
   * å°†ANSIè½¬æ¢ä¸ºHTML
   */
  ansiToHTML(text: string): string {
    return this.converter.toHtml(text);
  }

  /**
   * ç”Ÿæˆå½©è‰²ç»ˆç«¯è¾“å‡º
   */
  formatOutput(type: 'success' | 'error' | 'warning' | 'info', message: string): string {
    switch (type) {
      case 'success':
        return chalk.green('âœ“ ') + message;
      case 'error':
        return chalk.red('âœ— ') + message;
      case 'warning':
        return chalk.yellow('âš  ') + message;
      case 'info':
        return chalk.blue('â„¹ ') + message;
      default:
        return message;
    }
  }

  /**
   * ç”Ÿæˆè¿›åº¦æ¡
   */
  progressBar(current: number, total: number, width: number = 40): string {
    const percentage = Math.min(100, Math.floor((current / total) * 100));
    const filled = Math.floor((percentage / 100) * width);
    const empty = width - filled;

    const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
    return `${chalk.cyan(bar)} ${percentage}% (${current}/${total})`;
  }

  /**
   * ç”Ÿæˆè¡¨æ ¼
   */
  table(headers: string[], rows: string[][]): string {
    const columnWidths = headers.map((header, idx) => {
      const cellWidths = rows.map(row => (row[idx] || '').length);
      return Math.max(header.length, ...cellWidths);
    });

    const separator = columnWidths.map(w => '-'.repeat(w + 2)).join('+');

    let result = separator + '\n';

    // è¡¨å¤´
    result += headers.map((h, idx) =>
      ' ' + chalk.bold(h.padEnd(columnWidths[idx])) + ' '
    ).join('|') + '\n';

    result += separator + '\n';

    // æ•°æ®è¡Œ
    rows.forEach(row => {
      result += row.map((cell, idx) =>
        ' ' + (cell || '').padEnd(columnWidths[idx]) + ' '
      ).join('|') + '\n';
    });

    result += separator;

    return result;
  }
}
```

---

## å…­ã€Markdownå®æ—¶é¢„è§ˆ

### 6.1 Markdownæ¸²æŸ“

```typescript
import MarkdownIt from 'markdown-it';
import hljs from 'highlight.js';

/**
 * Markdownæ¸²æŸ“å™¨
 */
class MarkdownRenderer {
  private md: MarkdownIt;

  constructor() {
    this.md = new MarkdownIt({
      html: true,
      linkify: true,
      typographer: true,
      highlight: (str, lang) => {
        if (lang && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(str, { language: lang }).value;
          } catch (error) {
            console.error('Highlight error:', error);
          }
        }
        return '';
      }
    });

    // æ·»åŠ æ’ä»¶
    this.md.use(require('markdown-it-emoji'));
    this.md.use(require('markdown-it-footnote'));
    this.md.use(require('markdown-it-task-lists'));
    this.md.use(require('markdown-it-anchor'));
    this.md.use(require('markdown-it-table-of-contents'));
  }

  /**
   * æ¸²æŸ“Markdownä¸ºHTML
   */
  render(markdown: string): string {
    return this.md.render(markdown);
  }

  /**
   * æ¸²æŸ“Markdownä¸ºçº¯æ–‡æœ¬
   */
  renderToText(markdown: string): string {
    // ç§»é™¤Markdownè¯­æ³•,åªä¿ç•™çº¯æ–‡æœ¬
    let text = markdown;

    // ç§»é™¤ä»£ç å—
    text = text.replace(/```[\s\S]*?```/g, '[ä»£ç å—]');

    // ç§»é™¤è¡Œå†…ä»£ç 
    text = text.replace(/`[^`]+`/g, match => match.slice(1, -1));

    // ç§»é™¤é“¾æ¥
    text = text.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');

    // ç§»é™¤å›¾ç‰‡
    text = text.replace(/!\[([^\]]*)\]\([^)]+\)/g, '[å›¾ç‰‡: $1]');

    // ç§»é™¤æ ‡é¢˜æ ‡è®°
    text = text.replace(/^#{1,6}\s+/gm, '');

    // ç§»é™¤åŠ ç²—å’Œæ–œä½“
    text = text.replace(/\*\*([^*]+)\*\*/g, '$1');
    text = text.replace(/\*([^*]+)\*/g, '$1');
    text = text.replace(/__([^_]+)__/g, '$1');
    text = text.replace(/_([^_]+)_/g, '$1');

    return text;
  }

  /**
   * æå–Markdownç›®å½•
   */
  extractTOC(markdown: string): Array<{
    level: number;
    text: string;
    anchor: string;
  }> {
    const headings: Array<{ level: number; text: string; anchor: string }> = [];
    const lines = markdown.split('\n');

    lines.forEach(line => {
      const match = line.match(/^(#{1,6})\s+(.+)$/);
      if (match) {
        const level = match[1].length;
        const text = match[2];
        const anchor = text
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .replace(/\s+/g, '-');

        headings.push({ level, text, anchor });
      }
    });

    return headings;
  }

  /**
   * ç”Ÿæˆå®Œæ•´çš„HTMLé¡µé¢
   */
  renderToHTMLPage(markdown: string, options?: {
    title?: string;
    css?: string;
    theme?: 'light' | 'dark';
  }): string {
    const {
      title = 'Markdown Preview',
      css = '',
      theme = 'light'
    } = options || {};

    const content = this.render(markdown);
    const toc = this.extractTOC(markdown);

    return `
<!DOCTYPE html>
<html lang="zh-CN" data-theme="${theme}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github${theme === 'dark' ? '-dark' : ''}.min.css">
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background-color: ${theme === 'dark' ? '#0d1117' : '#ffffff'};
    }
    .container {
      max-width: 980px;
      margin: 0 auto;
    }
    .markdown-body {
      padding: 45px;
      background-color: ${theme === 'dark' ? '#0d1117' : '#ffffff'};
    }
    .toc {
      position: fixed;
      right: 20px;
      top: 20px;
      width: 200px;
      max-height: 80vh;
      overflow-y: auto;
      background: ${theme === 'dark' ? '#161b22' : '#f6f8fa'};
      border-radius: 6px;
      padding: 16px;
    }
    .toc a {
      text-decoration: none;
      color: ${theme === 'dark' ? '#58a6ff' : '#0969da'};
      display: block;
      padding: 4px 0;
    }
    ${css}
  </style>
</head>
<body>
  <div class="toc">
    <h3>ç›®å½•</h3>
    ${toc.map(item => `
      <a href="#${item.anchor}" style="padding-left: ${(item.level - 1) * 12}px">
        ${item.text}
      </a>
    `).join('')}
  </div>
  <div class="container">
    <div class="markdown-body">
      ${content}
    </div>
  </div>
</body>
</html>
`;
  }
}
```

### 6.2 Markdownæ–‡ä»¶ç›‘å¬å’Œå®æ—¶é¢„è§ˆ

```typescript
import chokidar from 'chokidar';
import express from 'express';
import { Server } from 'socket.io';
import http from 'http';

/**
 * Markdownå®æ—¶é¢„è§ˆæœåŠ¡å™¨
 */
class MarkdownPreviewServer {
  private renderer: MarkdownRenderer;
  private app: express.Application;
  private server: http.Server;
  private io: Server;
  private watcher: chokidar.FSWatcher | null = null;

  constructor() {
    this.renderer = new MarkdownRenderer();
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = new Server(this.server);

    this.setupRoutes();
    this.setupWebSocket();
  }

  /**
   * è®¾ç½®HTTPè·¯ç”±
   */
  private setupRoutes(): void {
    this.app.get('/', (req, res) => {
      res.send(`
<!DOCTYPE html>
<html>
<head>
  <title>Markdown Preview</title>
  <script src="/socket.io/socket.io.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
  <style>
    body { margin: 0; padding: 20px; }
    .markdown-body { max-width: 980px; margin: 0 auto; padding: 45px; }
  </style>
</head>
<body>
  <div class="markdown-body" id="content">
    Loading...
  </div>
  <script>
    const socket = io();
    socket.on('update', (html) => {
      document.getElementById('content').innerHTML = html;
    });
  </script>
</body>
</html>
      `);
    });
  }

  /**
   * è®¾ç½®WebSocketè¿æ¥
   */
  private setupWebSocket(): void {
    this.io.on('connection', (socket) => {
      console.log('Client connected');

      socket.on('disconnect', () => {
        console.log('Client disconnected');
      });
    });
  }

  /**
   * å¯åŠ¨é¢„è§ˆæœåŠ¡å™¨
   */
  start(filePath: string, port: number = 3000): void {
    // è¯»å–å¹¶æ¸²æŸ“åˆå§‹å†…å®¹
    this.updatePreview(filePath);

    // ç›‘å¬æ–‡ä»¶å˜åŒ–
    this.watcher = chokidar.watch(filePath, {
      persistent: true,
      ignoreInitial: true
    });

    this.watcher.on('change', () => {
      console.log('File changed, updating preview...');
      this.updatePreview(filePath);
    });

    // å¯åŠ¨æœåŠ¡å™¨
    this.server.listen(port, () => {
      console.log(`Preview server running at http://localhost:${port}`);
      console.log(`Watching: ${filePath}`);
    });
  }

  /**
   * æ›´æ–°é¢„è§ˆå†…å®¹
   */
  private updatePreview(filePath: string): void {
    try {
      const markdown = fs.readFileSync(filePath, 'utf-8');
      const html = this.renderer.render(markdown);

      // é€šè¿‡WebSocketæ¨é€æ›´æ–°
      this.io.emit('update', html);
    } catch (error) {
      console.error('Failed to update preview:', error);
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  stop(): void {
    if (this.watcher) {
      this.watcher.close();
    }
    this.server.close();
  }
}
```

---

## ä¸ƒã€Jupyter Notebookæ”¯æŒ

### 7.1 Notebookæ¸²æŸ“

```typescript
/**
 * Jupyter Notebookæ¸²æŸ“å™¨
 */
class NotebookRenderer {
  private mdRenderer: MarkdownRenderer;
  private codeHighlighter: CodeHighlighter;

  constructor() {
    this.mdRenderer = new MarkdownRenderer();
    this.codeHighlighter = new CodeHighlighter();
  }

  /**
   * è¯»å–å’Œè§£æNotebook
   */
  async readNotebook(notebookPath: string): Promise<{
    cells: NotebookCell[];
    metadata: any;
  }> {
    const content = fs.readFileSync(notebookPath, 'utf-8');
    const notebook = JSON.parse(content);

    return {
      cells: notebook.cells || [],
      metadata: notebook.metadata || {}
    };
  }

  /**
   * æ¸²æŸ“Notebookä¸ºHTML
   */
  renderToHTML(notebook: { cells: NotebookCell[]; metadata: any }): string {
    let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Jupyter Notebook</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
  <style>
    body { margin: 0; padding: 20px; background: #f5f5f5; }
    .notebook { max-width: 980px; margin: 0 auto; background: white; padding: 20px; }
    .cell { margin: 20px 0; padding: 10px; border-left: 3px solid #ddd; }
    .cell.code { background: #f7f7f7; }
    .cell.markdown { background: white; }
    .cell-input { margin-bottom: 10px; }
    .cell-output { border-top: 1px solid #ddd; padding-top: 10px; }
    .execution-count { color: #888; font-family: monospace; }
  </style>
</head>
<body>
  <div class="notebook">
`;

    notebook.cells.forEach((cell, idx) => {
      html += this.renderCell(cell, idx);
    });

    html += `
  </div>
</body>
</html>
`;

    return html;
  }

  /**
   * æ¸²æŸ“å•ä¸ªCell
   */
  private renderCell(cell: NotebookCell, index: number): string {
    if (cell.cell_type === 'markdown') {
      return this.renderMarkdownCell(cell);
    } else if (cell.cell_type === 'code') {
      return this.renderCodeCell(cell, index);
    }
    return '';
  }

  /**
   * æ¸²æŸ“Markdown Cell
   */
  private renderMarkdownCell(cell: NotebookCell): string {
    const source = Array.isArray(cell.source)
      ? cell.source.join('')
      : cell.source;

    const html = this.mdRenderer.render(source);

    return `
<div class="cell markdown">
  <div class="cell-input">
    ${html}
  </div>
</div>
`;
  }

  /**
   * æ¸²æŸ“Code Cell
   */
  private renderCodeCell(cell: NotebookCell, index: number): string {
    const source = Array.isArray(cell.source)
      ? cell.source.join('')
      : cell.source;

    const highlightedCode = this.codeHighlighter.highlight(
      source,
      'python'
    );

    let html = `
<div class="cell code">
  <div class="cell-input">
    <span class="execution-count">In [${cell.execution_count || ' '}]:</span>
    <pre><code>${highlightedCode}</code></pre>
  </div>
`;

    // æ¸²æŸ“è¾“å‡º
    if (cell.outputs && cell.outputs.length > 0) {
      html += '<div class="cell-output">';
      html += `<span class="execution-count">Out[${cell.execution_count || ' '}]:</span>`;

      cell.outputs.forEach(output => {
        html += this.renderOutput(output);
      });

      html += '</div>';
    }

    html += '</div>';

    return html;
  }

  /**
   * æ¸²æŸ“è¾“å‡º
   */
  private renderOutput(output: NotebookOutput): string {
    if (output.output_type === 'stream') {
      const text = Array.isArray(output.text)
        ? output.text.join('')
        : output.text;
      return `<pre>${text}</pre>`;
    } else if (output.output_type === 'execute_result' || output.output_type === 'display_data') {
      if (output.data) {
        // å›¾åƒ
        if (output.data['image/png']) {
          return `<img src="data:image/png;base64,${output.data['image/png']}" />`;
        }
        // HTML
        if (output.data['text/html']) {
          const html = Array.isArray(output.data['text/html'])
            ? output.data['text/html'].join('')
            : output.data['text/html'];
          return html;
        }
        // çº¯æ–‡æœ¬
        if (output.data['text/plain']) {
          const text = Array.isArray(output.data['text/plain'])
            ? output.data['text/plain'].join('')
            : output.data['text/plain'];
          return `<pre>${text}</pre>`;
        }
      }
    } else if (output.output_type === 'error') {
      return `
<pre class="error">
${output.ename}: ${output.evalue}
${output.traceback ? output.traceback.join('\n') : ''}
</pre>
`;
    }

    return '';
  }
}

// Notebookç±»å‹å®šä¹‰
interface NotebookCell {
  cell_type: 'code' | 'markdown' | 'raw';
  source: string | string[];
  execution_count?: number;
  outputs?: NotebookOutput[];
  metadata?: any;
}

interface NotebookOutput {
  output_type: 'stream' | 'execute_result' | 'display_data' | 'error';
  text?: string | string[];
  data?: {
    'text/plain'?: string | string[];
    'text/html'?: string | string[];
    'image/png'?: string;
    [key: string]: any;
  };
  ename?: string;
  evalue?: string;
  traceback?: string[];
}
```

---

## å…«ã€éŸ³é¢‘å¤„ç†(æœªæ¥æ”¯æŒ)

è™½ç„¶ç›®å‰Claude Codeä¸»è¦ä¸“æ³¨äºæ–‡æœ¬ã€å›¾åƒå’Œæ–‡æ¡£,ä½†éŸ³é¢‘å¤„ç†ä¹Ÿæ˜¯å¤šæ¨¡æ€çš„é‡è¦æ–¹å‘:

```typescript
/**
 * éŸ³é¢‘å¤„ç†å·¥å…·(æ¦‚å¿µå®ç°)
 */
class AudioProcessor {
  /**
   * è¯­éŸ³è½¬æ–‡å­—(Speech-to-Text)
   */
  async transcribe(audioPath: string): Promise<{
    text: string;
    confidence: number;
    language: string;
  }> {
    // ä½¿ç”¨Whisper APIæˆ–å…¶ä»–STTæœåŠ¡
    // è¿™é‡Œæ˜¯æ¦‚å¿µå®ç°
    return {
      text: 'è½¬å½•çš„æ–‡å­—å†…å®¹',
      confidence: 0.95,
      language: 'zh-CN'
    };
  }

  /**
   * æ–‡å­—è½¬è¯­éŸ³(Text-to-Speech)
   */
  async synthesize(text: string, options?: {
    voice?: string;
    language?: string;
    speed?: number;
  }): Promise<Buffer> {
    // ä½¿ç”¨TTSæœåŠ¡ç”ŸæˆéŸ³é¢‘
    return Buffer.from([]);
  }

  /**
   * éŸ³é¢‘åˆ†æ
   */
  async analyze(audioPath: string): Promise<{
    duration: number;
    sampleRate: number;
    channels: number;
    format: string;
  }> {
    // åˆ†æéŸ³é¢‘æ–‡ä»¶
    return {
      duration: 0,
      sampleRate: 44100,
      channels: 2,
      format: 'mp3'
    };
  }
}
```

---

## ä¹ã€å®æˆ˜æ¡ˆä¾‹

### 9.1 æ¡ˆä¾‹1:è®¾è®¡ç¨¿è½¬ä»£ç 

```typescript
/**
 * å®Œæ•´çš„è®¾è®¡ç¨¿è½¬ä»£ç æµç¨‹
 */
class DesignToCodeConverter {
  private uiAnalyzer: UIScreenshotAnalyzer;
  private codeHighlighter: CodeHighlighter;

  constructor(apiKey: string) {
    this.uiAnalyzer = new UIScreenshotAnalyzer(apiKey);
    this.codeHighlighter = new CodeHighlighter();
  }

  /**
   * ä¸»æµç¨‹:è®¾è®¡ç¨¿ â†’ ä»£ç 
   */
  async convert(designPath: string): Promise<void> {
    console.log('å¼€å§‹åˆ†æè®¾è®¡ç¨¿...');

    // 1. æå–ç»„ä»¶å±‚æ¬¡ç»“æ„
    const { hierarchy, components } =
      await this.uiAnalyzer.extractComponentHierarchy(designPath);

    console.log('è¯†åˆ«åˆ°çš„ç»„ä»¶:', components);

    // 2. ç”ŸæˆReactä»£ç 
    const { code, analysis, suggestions } =
      await this.uiAnalyzer.screenshotToCode(designPath, {
        framework: 'react',
        styling: 'tailwind',
        responsive: true,
        accessibility: true
      });

    console.log('\nç”Ÿæˆçš„ä»£ç :');
    console.log('='.repeat(50));
    console.log(this.codeHighlighter.highlight(code, 'tsx'));
    console.log('='.repeat(50));

    console.log('\nUIåˆ†æ:');
    console.log(analysis);

    console.log('\næ”¹è¿›å»ºè®®:');
    suggestions.forEach((s, idx) => {
      console.log(`${idx + 1}. ${s}`);
    });

    // 3. ä¿å­˜ä»£ç æ–‡ä»¶
    const outputPath = './generated-component.tsx';
    fs.writeFileSync(outputPath, code, 'utf-8');
    console.log(`\nä»£ç å·²ä¿å­˜åˆ°: ${outputPath}`);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const converter = new DesignToCodeConverter(
    process.env.ANTHROPIC_API_KEY!
  );

  await converter.convert('./design-mockup.png');
}
```

### 9.2 æ¡ˆä¾‹2:æŠ€æœ¯æ–‡æ¡£æ™ºèƒ½è§£æ

```typescript
/**
 * æŠ€æœ¯æ–‡æ¡£è§£æå·¥å…·
 */
class TechDocParser {
  private pdfProcessor: PDFProcessor;
  private mdRenderer: MarkdownRenderer;

  constructor(apiKey: string) {
    this.pdfProcessor = new PDFProcessor(apiKey);
    this.mdRenderer = new MarkdownRenderer();
  }

  /**
   * è§£ææŠ€æœ¯æ–‡æ¡£å¹¶ç”Ÿæˆæ‘˜è¦
   */
  async parse(pdfPath: string): Promise<{
    summary: string;
    structure: any;
    codeExamples: Array<{ language: string; code: string }>;
    keyPoints: string[];
  }> {
    console.log('æ­£åœ¨è§£æPDFæ–‡æ¡£...');

    // 1. æå–æ–‡æ¡£ç»“æ„
    const structure = await this.pdfProcessor.extractStructure(pdfPath);

    console.log(`æ–‡æ¡£æ ‡é¢˜: ${structure.title}`);
    console.log(`ç« èŠ‚æ•°: ${structure.sections.length}`);

    // 2. æå–æ–‡æœ¬
    const { text } = await this.pdfProcessor.extractText(pdfPath);

    // 3. ä½¿ç”¨Claudeç”Ÿæˆæ‘˜è¦å’Œå…³é”®ç‚¹
    const client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY!
    });

    const response = await client.messages.create({
      model: 'claude-3-5-sonnet-20250929',
      max_tokens: 4096,
      messages: [
        {
          role: 'user',
          content: `
è¯·åˆ†æä»¥ä¸‹æŠ€æœ¯æ–‡æ¡£,æä¾›:
1. æ–‡æ¡£æ‘˜è¦(200å­—ä»¥å†…)
2. å…³é”®è¦ç‚¹(5-10æ¡)
3. ä»£ç ç¤ºä¾‹

æ–‡æ¡£å†…å®¹:
${text.slice(0, 50000)}

ä»¥JSONæ ¼å¼è¾“å‡º:
\`\`\`json
{
  "summary": "æ‘˜è¦",
  "keyPoints": ["è¦ç‚¹1"],
  "codeExamples": [
    {
      "language": "python",
      "code": "ç¤ºä¾‹ä»£ç "
    }
  ]
}
\`\`\`
`
        }
      ]
    });

    const resultText = response.content[0].type === 'text'
      ? response.content[0].text
      : '';

    const jsonMatch = resultText.match(/```json\n([\s\S]*?)```/);
    if (!jsonMatch) {
      throw new Error('Failed to parse document');
    }

    const parsed = JSON.parse(jsonMatch[1]);

    return {
      summary: parsed.summary,
      structure,
      codeExamples: parsed.codeExamples || [],
      keyPoints: parsed.keyPoints || []
    };
  }

  /**
   * ç”Ÿæˆæ–‡æ¡£æŠ¥å‘Š
   */
  async generateReport(pdfPath: string, outputPath: string): Promise<void> {
    const result = await this.parse(pdfPath);

    // ç”ŸæˆMarkdownæŠ¥å‘Š
    let markdown = `# ${result.structure.title}\n\n`;

    markdown += `## æ‘˜è¦\n\n${result.summary}\n\n`;

    markdown += `## æ–‡æ¡£ç»“æ„\n\n`;
    result.structure.sections.forEach((section: any) => {
      markdown += `- ${section.title} (ç¬¬${section.page}é¡µ)\n`;
    });
    markdown += '\n';

    markdown += `## å…³é”®è¦ç‚¹\n\n`;
    result.keyPoints.forEach((point, idx) => {
      markdown += `${idx + 1}. ${point}\n`;
    });
    markdown += '\n';

    markdown += `## ä»£ç ç¤ºä¾‹\n\n`;
    result.codeExamples.forEach((example, idx) => {
      markdown += `### ç¤ºä¾‹ ${idx + 1}\n\n`;
      markdown += `\`\`\`${example.language}\n${example.code}\n\`\`\`\n\n`;
    });

    markdown += `## å‚è€ƒæ–‡çŒ®\n\n`;
    result.structure.references.forEach((ref: string) => {
      markdown += `- ${ref}\n`;
    });

    // ä¿å­˜æŠ¥å‘Š
    fs.writeFileSync(outputPath, markdown, 'utf-8');
    console.log(`æŠ¥å‘Šå·²ä¿å­˜åˆ°: ${outputPath}`);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const parser = new TechDocParser(
    process.env.ANTHROPIC_API_KEY!
  );

  await parser.generateReport(
    './technical-doc.pdf',
    './doc-report.md'
  );
}
```

### 9.3 æ¡ˆä¾‹3:ä»£ç å®¡æŸ¥åŠ©æ‰‹

```typescript
/**
 * ä»£ç å®¡æŸ¥åŠ©æ‰‹
 */
class CodeReviewAssistant {
  private vision: VisionAPI;
  private codeHighlighter: CodeHighlighter;

  constructor(apiKey: string) {
    this.vision = new VisionAPI(apiKey);
    this.codeHighlighter = new CodeHighlighter();
  }

  /**
   * å®¡æŸ¥ä»£ç æˆªå›¾
   */
  async reviewCodeScreenshot(screenshotPath: string): Promise<{
    issues: Array<{
      severity: 'high' | 'medium' | 'low';
      type: string;
      description: string;
      suggestion: string;
    }>;
    positives: string[];
    summary: string;
  }> {
    const prompt = `
è¯·å®¡æŸ¥è¿™æ®µä»£ç æˆªå›¾,å…³æ³¨:
1. æ½œåœ¨çš„bugå’Œé”™è¯¯
2. ä»£ç è´¨é‡é—®é¢˜
3. æ€§èƒ½é—®é¢˜
4. å®‰å…¨éšæ‚£
5. ä»£ç é£æ ¼å’Œæœ€ä½³å®è·µ

ä»¥JSONæ ¼å¼è¾“å‡º:
\`\`\`json
{
  "issues": [
    {
      "severity": "high",
      "type": "Bug",
      "description": "é—®é¢˜æè¿°",
      "suggestion": "ä¿®å¤å»ºè®®"
    }
  ],
  "positives": ["å¥½çš„åœ°æ–¹1"],
  "summary": "æ€»ä½“è¯„ä»·"
}
\`\`\`
`;

    const result = await this.vision.analyzeImage(screenshotPath, prompt);

    const jsonMatch = result.match(/```json\n([\s\S]*?)```/);
    if (!jsonMatch) {
      throw new Error('Failed to parse review result');
    }

    return JSON.parse(jsonMatch[1]);
  }

  /**
   * ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š
   */
  async generateReviewReport(
    screenshotPath: string,
    outputPath: string
  ): Promise<void> {
    const review = await this.reviewCodeScreenshot(screenshotPath);

    let markdown = `# ä»£ç å®¡æŸ¥æŠ¥å‘Š\n\n`;

    markdown += `## æ€»ä½“è¯„ä»·\n\n${review.summary}\n\n`;

    markdown += `## å‘ç°çš„é—®é¢˜\n\n`;
    const issuesBySeverity = {
      high: review.issues.filter(i => i.severity === 'high'),
      medium: review.issues.filter(i => i.severity === 'medium'),
      low: review.issues.filter(i => i.severity === 'low')
    };

    if (issuesBySeverity.high.length > 0) {
      markdown += `### ğŸ”´ é«˜ä¼˜å…ˆçº§é—®é¢˜\n\n`;
      issuesBySeverity.high.forEach((issue, idx) => {
        markdown += `${idx + 1}. **${issue.type}**: ${issue.description}\n`;
        markdown += `   - å»ºè®®: ${issue.suggestion}\n\n`;
      });
    }

    if (issuesBySeverity.medium.length > 0) {
      markdown += `### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§é—®é¢˜\n\n`;
      issuesBySeverity.medium.forEach((issue, idx) => {
        markdown += `${idx + 1}. **${issue.type}**: ${issue.description}\n`;
        markdown += `   - å»ºè®®: ${issue.suggestion}\n\n`;
      });
    }

    if (issuesBySeverity.low.length > 0) {
      markdown += `### ğŸŸ¢ ä½ä¼˜å…ˆçº§é—®é¢˜\n\n`;
      issuesBySeverity.low.forEach((issue, idx) => {
        markdown += `${idx + 1}. **${issue.type}**: ${issue.description}\n`;
        markdown += `   - å»ºè®®: ${issue.suggestion}\n\n`;
      });
    }

    markdown += `## ä¼˜ç‚¹\n\n`;
    review.positives.forEach((positive) => {
      markdown += `- ${positive}\n`;
    });

    fs.writeFileSync(outputPath, markdown, 'utf-8');
    console.log(`å®¡æŸ¥æŠ¥å‘Šå·²ä¿å­˜åˆ°: ${outputPath}`);
  }
}
```

---

## åã€æœ€ä½³å®è·µ

### 10.1 å›¾åƒå¤„ç†æœ€ä½³å®è·µ

**1. å›¾åƒå¤§å°ä¼˜åŒ–**

```typescript
// âœ… å¥½çš„åšæ³•:è°ƒæ•´å›¾åƒå¤§å°ä»¥èŠ‚çœToken
const preprocessor = new ImagePreprocessor();
await preprocessor.resize(
  originalPath,
  processedPath,
  1568, // Claude Visionæœ€ä½³å®½åº¦
  1568
);

// âŒ ä¸å¥½çš„åšæ³•:ç›´æ¥ä½¿ç”¨è¶…å¤§å›¾åƒ
// ä¼šæµªè´¹Token,å½±å“æ€§èƒ½
```

**2. æ‰¹é‡å¤„ç†ç­–ç•¥**

```typescript
// âœ… å¥½çš„åšæ³•:æ‰¹é‡å¤„ç†ç›¸å…³å›¾åƒ
await vision.analyzeMultipleImages([
  { path: 'screen1.png', description: 'é¦–é¡µ' },
  { path: 'screen2.png', description: 'è¯¦æƒ…é¡µ' }
], 'è¯·å¯¹æ¯”è¿™ä¸¤ä¸ªé¡µé¢çš„å¸ƒå±€å·®å¼‚');

// âŒ ä¸å¥½çš„åšæ³•:å¤šæ¬¡å•ç‹¬è°ƒç”¨
// ä¼šä¸¢å¤±ä¸Šä¸‹æ–‡,å¢åŠ æˆæœ¬
```

**3. æç¤ºè¯ä¼˜åŒ–**

```typescript
// âœ… å¥½çš„åšæ³•:å…·ä½“ã€æ˜ç¡®çš„æç¤ºè¯
const prompt = `
è¯·åˆ†æè¿™ä¸ªç™»å½•é¡µé¢çš„UIè®¾è®¡,é‡ç‚¹å…³æ³¨:
1. è¡¨å•å¸ƒå±€æ˜¯å¦åˆç†
2. æŒ‰é’®ä½ç½®å’Œæ ·å¼
3. æ˜¯å¦ç¬¦åˆæ— éšœç¢æ ‡å‡†
4. é…è‰²æ–¹æ¡ˆ

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºåˆ†æç»“æœã€‚
`;

// âŒ ä¸å¥½çš„åšæ³•:æ¨¡ç³Šçš„æç¤ºè¯
const prompt = 'åˆ†æè¿™ä¸ªé¡µé¢'; // å¤ªç¬¼ç»Ÿ,ç»“æœä¸å¯æ§
```

### 10.2 PDFå¤„ç†æœ€ä½³å®è·µ

**1. å¤§å‹PDFåˆ†é¡µå¤„ç†**

```typescript
// âœ… å¥½çš„åšæ³•:åˆ†é¡µå¤„ç†å¤§å‹PDF
async function processBigPDF(pdfPath: string) {
  const { pages } = await pdfProcessor.extractText(pdfPath);

  for (let i = 1; i <= pages; i += 10) {
    // æ¯æ¬¡å¤„ç†10é¡µ
    const result = await processBatch(pdfPath, i, Math.min(i + 9, pages));
    await saveBatch(result);
  }
}

// âŒ ä¸å¥½çš„åšæ³•:ä¸€æ¬¡æ€§å¤„ç†æ‰€æœ‰é¡µé¢
// å¯èƒ½è¶…å‡ºTokené™åˆ¶
```

**2. ç¼“å­˜æå–ç»“æœ**

```typescript
// âœ… å¥½çš„åšæ³•:ç¼“å­˜PDFæ–‡æœ¬æå–ç»“æœ
class CachedPDFProcessor {
  private cache: Map<string, { text: string; mtime: number }> = new Map();

  async extractText(pdfPath: string) {
    const stat = fs.statSync(pdfPath);
    const cached = this.cache.get(pdfPath);

    if (cached && cached.mtime === stat.mtimeMs) {
      return cached; // è¿”å›ç¼“å­˜
    }

    const result = await this.actualExtract(pdfPath);
    this.cache.set(pdfPath, { ...result, mtime: stat.mtimeMs });
    return result;
  }
}
```

### 10.3 ä»£ç æ¸²æŸ“æœ€ä½³å®è·µ

**1. è¯­è¨€è‡ªåŠ¨æ£€æµ‹**

```typescript
// âœ… å¥½çš„åšæ³•:è‡ªåŠ¨æ£€æµ‹è¯­è¨€
const language = highlighter.detectLanguage(code, fileName);
const highlighted = highlighter.highlight(code, language);

// âŒ ä¸å¥½çš„åšæ³•:ç¡¬ç¼–ç è¯­è¨€
const highlighted = highlighter.highlight(code, 'javascript');
// å¦‚æœå®é™…æ˜¯Pythonä»£ç ,é«˜äº®ä¼šé”™è¯¯
```

**2. å¢é‡æ¸²æŸ“**

```typescript
// âœ… å¥½çš„åšæ³•:åªæ¸²æŸ“å¯è§éƒ¨åˆ†
class LazyCodeRenderer {
  renderVisible(code: string, startLine: number, endLine: number) {
    const lines = code.split('\n');
    const visibleLines = lines.slice(startLine, endLine);
    return this.highlight(visibleLines.join('\n'));
  }
}

// âŒ ä¸å¥½çš„åšæ³•:æ¸²æŸ“æ•´ä¸ªå¤§æ–‡ä»¶
// å¯¹äºæ•°ä¸‡è¡Œä»£ç ,ä¼šå¾ˆæ…¢
```

### 10.4 å¤šæ¨¡æ€ä¸Šä¸‹æ–‡ç®¡ç†

**1. Tokené¢„ç®—åˆ†é…**

```typescript
// âœ… å¥½çš„åšæ³•:ä¸ºä¸åŒæ¨¡æ€åˆ†é…Tokené¢„ç®—
class MultimodalContextManager {
  private readonly TOKEN_BUDGET = 150000;
  private readonly BUDGET_ALLOCATION = {
    text: 0.5,    // 50%ç»™æ–‡æœ¬
    image: 0.3,   // 30%ç»™å›¾åƒ
    pdf: 0.2      // 20%ç»™PDF
  };

  allocate(content: MultimodalContent) {
    const textBudget = this.TOKEN_BUDGET * this.BUDGET_ALLOCATION.text;
    const imageBudget = this.TOKEN_BUDGET * this.BUDGET_ALLOCATION.image;
    // ...
  }
}
```

**2. ä¼˜å…ˆçº§æ’åº**

```typescript
// âœ… å¥½çš„åšæ³•:æ ¹æ®ç›¸å…³æ€§æ’åº
interface MultimodalItem {
  type: 'text' | 'image' | 'pdf';
  content: any;
  relevance: number; // 0-1
  tokens: number;
}

function prioritize(items: MultimodalItem[]): MultimodalItem[] {
  return items.sort((a, b) => {
    // ä¼˜å…ˆçº§ = ç›¸å…³æ€§ / Tokenæ•°(æ€§ä»·æ¯”)
    const aPriority = a.relevance / a.tokens;
    const bPriority = b.relevance / b.tokens;
    return bPriority - aPriority;
  });
}
```

---

## åä¸€ã€å¸¸è§é—®é¢˜(FAQ)

### Q1: Claude Visionæ”¯æŒå“ªäº›å›¾åƒæ ¼å¼?

A: Claude Visionæ”¯æŒ:
- PNG (`.png`)
- JPEG (`.jpg`, `.jpeg`)
- GIF (`.gif`)
- WebP (`.webp`)

æ¨èä½¿ç”¨PNGæˆ–JPEG,WebPå‹ç¼©ç‡æ›´é«˜ä½†å…¼å®¹æ€§ç¨å·®ã€‚

### Q2: å›¾åƒå¤§å°æœ‰é™åˆ¶å—?

A: æ˜¯çš„,Claude Visionæœ‰ä»¥ä¸‹é™åˆ¶:
- æœ€å¤§æ–‡ä»¶å¤§å°: 5MB
- æœ€å¤§åˆ†è¾¨ç‡: 1568 x 1568åƒç´ 
- è¶…è¿‡é™åˆ¶çš„å›¾åƒä¼šè¢«è‡ªåŠ¨ç¼©æ”¾

å»ºè®®åœ¨ä¸Šä¼ å‰é¢„å¤„ç†å›¾åƒä»¥ä¼˜åŒ–æ€§èƒ½ã€‚

### Q3: PDFè§£æçš„å‡†ç¡®ç‡å¦‚ä½•?

A: PDFè§£æçš„å‡†ç¡®ç‡å–å†³äº:
- **æ‰«æä»¶ vs æ•°å­—åŒ–**: æ•°å­—åŒ–PDFå‡†ç¡®ç‡æ¥è¿‘100%,æ‰«æä»¶å–å†³äºå›¾åƒè´¨é‡
- **å¸ƒå±€å¤æ‚åº¦**: ç®€å•å¸ƒå±€å‡†ç¡®ç‡é«˜,å¤šåˆ—ã€å¤æ‚è¡¨æ ¼å¯èƒ½éœ€è¦é¢å¤–å¤„ç†
- **æ–‡å­—æ¸…æ™°åº¦**: æ¸…æ™°æ–‡å­—å‡†ç¡®ç‡95%+,æ¨¡ç³Šæ–‡å­—å¯èƒ½é™è‡³70-80%

å¯¹äºé‡è¦æ–‡æ¡£,å»ºè®®äººå·¥æ ¡éªŒã€‚

### Q4: å¤šæ¨¡æ€å¤„ç†çš„æˆæœ¬å¦‚ä½•?

A: æˆæœ¬è®¡ç®—:
- **å›¾åƒ**: çº¦ä¸º1500-2000 tokens/å¼ (å–å†³äºå¤§å°)
- **PDF**: æŒ‰æå–çš„æ–‡æœ¬Tokenæ•°è®¡ç®—
- **ä»£ç é«˜äº®**: æœ¬åœ°å¤„ç†,æ— é¢å¤–æˆæœ¬

ç¤ºä¾‹:åˆ†æä¸€å¼ UIæˆªå›¾ + ç”Ÿæˆä»£ç  â‰ˆ 5000-8000 tokens â‰ˆ $0.03-0.05

### Q5: å¦‚ä½•æå‡OCRå‡†ç¡®ç‡?

A: å‡ ä¸ªæŠ€å·§:
1. **é¢„å¤„ç†å›¾åƒ**: å¢å¼ºå¯¹æ¯”åº¦ã€è½¬ç°åº¦
2. **æé«˜åˆ†è¾¨ç‡**: è‡³å°‘300 DPI
3. **æ˜ç¡®æç¤ºè¯**: å‘Šè¯‰AIæ–‡å­—çš„è¯­è¨€å’Œæ ¼å¼
4. **åˆ†åŒºå¤„ç†**: å¤æ‚é¡µé¢åˆ†åŒºè¯†åˆ«

```typescript
// æå‡OCRæ•ˆæœçš„é¢„å¤„ç†
await preprocessor.enhanceContrast(inputPath, outputPath);
const { text } = await ocr.extractText(outputPath);
```

### Q6: æ”¯æŒå®æ—¶è§†é¢‘åˆ†æå—?

A: ç›®å‰Claude Codeä¸ç›´æ¥æ”¯æŒè§†é¢‘,ä½†å¯ä»¥:
1. æå–è§†é¢‘å…³é”®å¸§
2. é€å¸§åˆ†æ
3. æ±‡æ€»ç»“æœ

```typescript
// è§†é¢‘åˆ†æçš„å˜é€šæ–¹æ¡ˆ
async function analyzeVideo(videoPath: string) {
  const frames = await extractKeyFrames(videoPath, 10); // æ¯ç§’1å¸§
  const results = await Promise.all(
    frames.map(frame => vision.analyzeImage(frame, 'æè¿°è¿™ä¸€å¸§'))
  );
  return summarizeResults(results);
}
```

---

## åäºŒã€æ€»ç»“

å¤šæ¨¡æ€äº¤äº’æ˜¯Claude Codeçš„æ ¸å¿ƒç«äº‰åŠ›ä¹‹ä¸€,é€šè¿‡å¼ºå¤§çš„Vision APIå’Œæ–‡æ¡£å¤„ç†èƒ½åŠ›,å®ç°äº†:

âœ… **å›¾åƒç†è§£**: æˆªå›¾åˆ†æã€OCRã€UIè½¬ä»£ç 
âœ… **æ–‡æ¡£è§£æ**: PDFæå–ã€ç»“æ„åˆ†æã€è¡¨æ ¼è¯†åˆ«
âœ… **ä»£ç æ¸²æŸ“**: è¯­æ³•é«˜äº®ã€è¡Œå·ã€ä¸»é¢˜åˆ‡æ¢
âœ… **å®æ—¶é¢„è§ˆ**: Markdownã€Jupyter Notebook
âœ… **ä¸Šä¸‹æ–‡èåˆ**: å¤šæ¨¡æ€ä¿¡æ¯ç»¼åˆç†è§£

**æ ¸å¿ƒè¦ç‚¹å›é¡¾**:

1. **Vision APIä½¿ç”¨**: Base64ç¼–ç å›¾åƒ + æ–‡æœ¬æç¤ºè¯
2. **PDFå¤„ç†**: æ–‡æœ¬æå– + é¡µé¢å›¾åƒåˆ†æ
3. **ä»£ç é«˜äº®**: Prism.jsç­‰åº“å®ç°è¯­æ³•é«˜äº®
4. **Markdownæ¸²æŸ“**: markdown-it + æ–‡ä»¶ç›‘å¬
5. **æœ€ä½³å®è·µ**: å›¾åƒé¢„å¤„ç†ã€Tokené¢„ç®—ç®¡ç†ã€ç¼“å­˜ä¼˜åŒ–

**ä¸‹ä¸€æ­¥å»ºè®®**:

1. å®è·µå›¾åƒè½¬ä»£ç åŠŸèƒ½
2. å°è¯•è§£ææŠ€æœ¯PDFæ–‡æ¡£
3. å¼€å‘Markdownå®æ—¶é¢„è§ˆå·¥å…·
4. æ¢ç´¢æ›´å¤šå¤šæ¨¡æ€åº”ç”¨åœºæ™¯

---

## åä¸‰ã€æ‰©å±•é˜…è¯»

### æ¨èèµ„æº

- [Claude Vision APIæ–‡æ¡£](https://docs.anthropic.com/claude/docs/vision)
- [Anthropic Cookbook - Vision Examples](https://github.com/anthropics/anthropic-cookbook)
- [pdf-parseåº“](https://www.npmjs.com/package/pdf-parse)
- [Prism.jsæ–‡æ¡£](https://prismjs.com/)
- [markdown-itæ–‡æ¡£](https://github.com/markdown-it/markdown-it)

### ç›¸å…³æŠ€æœ¯

- **Tesseract OCR**: å¼€æºOCRå¼•æ“
- **pdfplumber**: Python PDFè§£æåº“
- **Sharp**: é«˜æ€§èƒ½Node.jså›¾åƒå¤„ç†
- **Mermaid**: æµç¨‹å›¾å’Œå›¾è¡¨æ¸²æŸ“
- **Monaco Editor**: VS Codeçš„ç¼–è¾‘å™¨æ ¸å¿ƒ

---

## ä¸‹ä¸€ç¯‡é¢„å‘Š

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­,æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨**[æ€§èƒ½ä¼˜åŒ–æ·±åº¦å‰–æ](./13-æ€§èƒ½ä¼˜åŒ–æ·±åº¦å‰–æ.md)**,åŒ…æ‹¬:
- è¯·æ±‚æ‰¹å¤„ç†å’Œåˆå¹¶ç­–ç•¥
- æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿè®¾è®¡
- Tokenä½¿ç”¨ä¼˜åŒ–æŠ€å·§
- å†…å­˜å’Œç½‘ç»œä¼˜åŒ–

æ•¬è¯·æœŸå¾…!

---

**å¦‚æœè§‰å¾—è¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©,æ¬¢è¿åˆ†äº«ç»™æ›´å¤šçš„æœ‹å‹!**
