---
title: 03 ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ
date: 2025-11-18
permalink: /ai/claude-code/architecture-03-context-management.html
categories:
  - AI
---

# ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ

## å¼•è¨€

åœ¨AIé©±åŠ¨çš„åº”ç”¨ä¸­ï¼Œä¸Šä¸‹æ–‡(Context)æ˜¯å†³å®šAIè¡¨ç°çš„å…³é”®å› ç´ ã€‚Claude Codeéœ€è¦å¤„ç†å¤§é‡çš„é¡¹ç›®æ–‡ä»¶ã€å¯¹è¯å†å²ã€å·¥å…·è¾“å‡ºç­‰ä¿¡æ¯ï¼Œå¦‚ä½•åœ¨æœ‰é™çš„Tokené¢„ç®—å†…ï¼Œæ™ºèƒ½åœ°é€‰æ‹©ã€ç»„ç»‡å’Œä¼ é€’è¿™äº›ä¿¡æ¯ï¼Œæ˜¯ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿçš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚

### ä¸Šä¸‹æ–‡çš„é‡è¦æ€§

æƒ³è±¡ä½ åœ¨ä¸ä¸€ä¸ªå¤±å¿†ç—‡æ‚£è€…å¯¹è¯ï¼Œæ¯æ¬¡å¯¹è¯ä»–éƒ½ä¸è®°å¾—ä¹‹å‰è¯´è¿‡ä»€ä¹ˆã€‚è¿™å°±æ˜¯æ²¡æœ‰ä¸Šä¸‹æ–‡ç®¡ç†çš„AIåº”ç”¨çš„çŠ¶æ€ã€‚

**ä¸Šä¸‹æ–‡çš„ä½œç”¨**ï¼š
- âœ… **æä¾›èƒŒæ™¯ä¿¡æ¯**ï¼šè®©AIç†è§£å½“å‰ä»»åŠ¡çš„å®Œæ•´èƒŒæ™¯
- âœ… **ä¿æŒå¯¹è¯è¿è´¯**ï¼šè®°ä½ä¹‹å‰çš„å¯¹è¯å†…å®¹
- âœ… **é¿å…é‡å¤æ“ä½œ**ï¼šçŸ¥é“å“ªäº›æ–‡ä»¶å·²ç»è¯»å–è¿‡
- âœ… **æå‡å‡†ç¡®æ€§**ï¼šåŸºäºçœŸå®æ•°æ®è€ŒéçŒœæµ‹

### Claudeçš„ä¸Šä¸‹æ–‡çª—å£

Claude 3.5 Sonnetæ‹¥æœ‰**200K tokens**çš„ä¸Šä¸‹æ–‡çª—å£ï¼Œè¿™ç›¸å½“äºï¼š
- çº¦150,000ä¸ªè‹±æ–‡å•è¯
- çº¦500é¡µçš„æ–‡æœ¬
- æ•°ç™¾ä¸ªä¸­ç­‰å¤§å°çš„ä»£ç æ–‡ä»¶

ä½†æ˜¯ï¼Œæ›´å¤§çš„ä¸Šä¸‹æ–‡çª—å£å¹¶ä¸æ„å‘³ç€å¯ä»¥æ— èŠ‚åˆ¶åœ°ä½¿ç”¨ï¼š
- âš ï¸ **æˆæœ¬è€ƒè™‘**ï¼šæ¯1M input tokensçº¦$3
- âš ï¸ **æ€§èƒ½å½±å“**ï¼šæ›´å¤§çš„ä¸Šä¸‹æ–‡ä¼šå¢åŠ å“åº”å»¶è¿Ÿ
- âš ï¸ **ä¿¡æ¯å†—ä½™**ï¼šè¿‡å¤šæ— å…³ä¿¡æ¯åè€Œé™ä½AIæ•ˆæœ

### ä¸Šä¸‹æ–‡ç®¡ç†çš„æŒ‘æˆ˜

```mermaid
graph TB
    A[ä¸Šä¸‹æ–‡ç®¡ç†æŒ‘æˆ˜] --> B[Tokené¢„ç®—æœ‰é™]
    A --> C[ä¿¡æ¯ä¼˜å…ˆçº§]
    A --> D[åŠ¨æ€å˜åŒ–]
    A --> E[å¤šæºæ•´åˆ]

    B --> B1[å¦‚ä½•åœ¨é¢„ç®—å†…åŒ…å«æœ€é‡è¦çš„ä¿¡æ¯?]
    C --> C1[å“ªäº›ä¿¡æ¯æœ€é‡è¦?]
    C --> C2[å¦‚ä½•é‡åŒ–ä¼˜å…ˆçº§?]
    D --> D1[æ–‡ä»¶å†…å®¹å˜åŒ–]
    D --> D2[å¯¹è¯å†å²å¢é•¿]
    E --> E1[æ–‡ä»¶å†…å®¹]
    E --> E2[GitçŠ¶æ€]
    E --> E3[å·¥å…·è¾“å‡º]
    E --> E4[å¯¹è¯å†å²]

    style A fill:#ffe1f5,stroke:#333,stroke-width:3px
    style B fill:#fff4e1
    style C fill:#e1f5ff
```


## äºŒã€Tokenè®¡æ•°å’Œé¢„ç®—æ§åˆ¶

### 2.1 Tokenè®¡æ•°åŸç†

Tokenæ˜¯LLMå¤„ç†æ–‡æœ¬çš„åŸºæœ¬å•ä½ã€‚ä¸åŒçš„æ–‡æœ¬æœ‰ä¸åŒçš„Tokenæ•°é‡ï¼š

**Tokenè®¡æ•°è§„åˆ™**ï¼ˆè¿‘ä¼¼ï¼‰ï¼š
- è‹±æ–‡ï¼šçº¦4ä¸ªå­—ç¬¦ = 1 token
- ä¸­æ–‡ï¼šçº¦1.5ä¸ªå­—ç¬¦ = 1 token
- ä»£ç ï¼šçº¦3ä¸ªå­—ç¬¦ = 1 token
- ç©ºæ ¼å’Œæ ‡ç‚¹ï¼šä¹Ÿè®¡å…¥token

**ç¤ºä¾‹**ï¼š
```
æ–‡æœ¬ï¼šHello, world!
Tokenæ•°ï¼š3 (Hello, world, !)

æ–‡æœ¬ï¼šä½ å¥½ä¸–ç•Œ
Tokenæ•°ï¼šçº¦3 (ä½ å¥½, ä¸–ç•Œ)

ä»£ç ï¼šfunction hello() { return "world"; }
Tokenæ•°ï¼šçº¦10
```

### 2.2 Tokenè®¡æ•°å™¨å®ç°

```typescript
import { encoding_for_model } from 'tiktoken';

/**
 * Tokenè®¡æ•°å™¨ - ä½¿ç”¨tiktokenåº“ç²¾ç¡®è®¡ç®—tokenæ•°
 */
class TokenCounter {
  private encoding: any;
  private cache: Map<string, number>;

  constructor(model: string = 'claude-3-5-sonnet-20250929') {
    // åˆå§‹åŒ–ç¼–ç å™¨
    // Claudeä½¿ç”¨cl100k_baseç¼–ç (ä¸GPT-4ç›¸åŒ)
    this.encoding = encoding_for_model('gpt-4');
    this.cache = new Map();
  }

  /**
   * è®¡ç®—æ–‡æœ¬çš„tokenæ•°
   */
  count(text: string): number {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(text);
    if (cached !== undefined) {
      return cached;
    }

    // ç¼–ç æ–‡æœ¬
    const tokens = this.encoding.encode(text);
    const count = tokens.length;

    // ç¼“å­˜ç»“æœ(é™åˆ¶ç¼“å­˜å¤§å°)
    if (this.cache.size < 10000) {
      this.cache.set(text, count);
    }

    return count;
  }

  /**
   * è®¡ç®—æ¶ˆæ¯åˆ—è¡¨çš„tokenæ•°
   */
  countMessages(messages: Message[]): number {
    let total = 0;

    for (const message of messages) {
      // æ¯æ¡æ¶ˆæ¯æœ‰å›ºå®šçš„æ ¼å¼å¼€é”€
      total += 4; // æ¶ˆæ¯è¾¹ç•Œtokens

      // è§’è‰²token
      total += this.count(message.role);

      // å†…å®¹tokens
      if (typeof message.content === 'string') {
        total += this.count(message.content);
      } else if (Array.isArray(message.content)) {
        for (const block of message.content) {
          if (block.type === 'text') {
            total += this.count(block.text);
          } else if (block.type === 'tool_use') {
            total += this.count(block.name);
            total += this.count(JSON.stringify(block.input));
          } else if (block.type === 'tool_result') {
            total += this.count(String(block.content));
          }
        }
      }
    }

    return total;
  }

  /**
   * è®¡ç®—ä¸Šä¸‹æ–‡çš„tokenæ•°
   */
  countContext(context: FullContext): ContextTokenStats {
    const stats: ContextTokenStats = {
      static: 0,
      dynamic: 0,
      temporary: 0,
      total: 0,
      breakdown: {}
    };

    // é™æ€ä¸Šä¸‹æ–‡
    stats.static += this.count(context.static.systemPrompt);
    stats.breakdown['systemPrompt'] = this.count(context.static.systemPrompt);

    // å·¥å…·å®šä¹‰
    const toolTokens = context.static.toolDefinitions.reduce(
      (sum, tool) => sum + this.count(JSON.stringify(tool)),
      0
    );
    stats.static += toolTokens;
    stats.breakdown['toolDefinitions'] = toolTokens;

    // åŠ¨æ€ä¸Šä¸‹æ–‡ - æ–‡ä»¶
    const fileTokens = context.dynamic.files.reduce(
      (sum, file) => sum + this.count(file.content),
      0
    );
    stats.dynamic += fileTokens;
    stats.breakdown['files'] = fileTokens;

    // å¯¹è¯å†å²
    const conversationTokens = this.countMessages(
      context.dynamic.conversationHistory
    );
    stats.dynamic += conversationTokens;
    stats.breakdown['conversation'] = conversationTokens;

    // GitçŠ¶æ€
    const gitTokens = this.count(JSON.stringify(context.dynamic.gitStatus));
    stats.dynamic += gitTokens;
    stats.breakdown['gitStatus'] = gitTokens;

    // ä¸´æ—¶ä¸Šä¸‹æ–‡ - å·¥å…·ç»“æœ
    const toolResultTokens = context.temporary.toolResults.reduce(
      (sum, result) => sum + this.count(JSON.stringify(result)),
      0
    );
    stats.temporary += toolResultTokens;
    stats.breakdown['toolResults'] = toolResultTokens;

    // æ€»è®¡
    stats.total = stats.static + stats.dynamic + stats.temporary;

    return stats;
  }

  /**
   * ä¼°ç®—æ–‡æœ¬çš„tokenæ•°(å¿«é€Ÿä½†ä¸ç²¾ç¡®)
   */
  estimate(text: string): number {
    // ç»Ÿè®¡ä¸­è‹±æ–‡å­—ç¬¦
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const otherChars = text.length - chineseChars;

    // ç²—ç•¥ä¼°ç®—
    return Math.ceil(chineseChars / 1.5 + otherChars / 4);
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * é‡Šæ”¾èµ„æº
   */
  dispose(): void {
    this.encoding.free();
    this.clearCache();
  }
}

/**
 * ä¸Šä¸‹æ–‡tokenç»Ÿè®¡
 */
interface ContextTokenStats {
  static: number;                 // é™æ€ä¸Šä¸‹æ–‡tokens
  dynamic: number;                // åŠ¨æ€ä¸Šä¸‹æ–‡tokens
  temporary: number;              // ä¸´æ—¶ä¸Šä¸‹æ–‡tokens
  total: number;                  // æ€»tokens
  breakdown: Record<string, number>; // è¯¦ç»†åˆ†è§£
}

export { TokenCounter, ContextTokenStats };
```

### 2.3 Tokené¢„ç®—ç®¡ç†å™¨

```mermaid
graph LR
    A[Tokené¢„ç®—ç®¡ç†] --> B[è®¾å®šé¢„ç®—]
    A --> C[å®æ—¶ç›‘æ§]
    A --> D[æ™ºèƒ½åˆ†é…]

    B --> B1[æ€»é¢„ç®—: 100K]
    B --> B2[é™æ€: 10K]
    B --> B3[åŠ¨æ€: 70K]
    B --> B4[ä¸´æ—¶: 20K]

    C --> C1[è®¡ç®—å½“å‰ä½¿ç”¨]
    C --> C2[é¢„æµ‹å¢é•¿]
    C --> C3[è§¦å‘è­¦å‘Š]

    D --> D1[æŒ‰ä¼˜å…ˆçº§åˆ†é…]
    D --> D2[åŠ¨æ€è°ƒæ•´]
    D --> D3[è¶…é™æˆªæ–­]

    style A fill:#e1f5ff,stroke:#333,stroke-width:3px
    style B fill:#e8f5e9
    style C fill:#fff4e1
    style D fill:#ffe1f5
```

```typescript
/**
 * Tokené¢„ç®—ç®¡ç†å™¨
 */
class TokenBudgetManager {
  private maxTokens: number;
  private tokenCounter: TokenCounter;
  private budgetAllocation: BudgetAllocation;

  constructor(maxTokens: number = 100000) {
    this.maxTokens = maxTokens;
    this.tokenCounter = new TokenCounter();
    this.budgetAllocation = this.calculateBudgetAllocation(maxTokens);
  }

  /**
   * è®¡ç®—é¢„ç®—åˆ†é…
   */
  private calculateBudgetAllocation(total: number): BudgetAllocation {
    return {
      total,
      static: Math.floor(total * 0.1),      // 10% é™æ€ä¸Šä¸‹æ–‡
      dynamic: Math.floor(total * 0.7),     // 70% åŠ¨æ€ä¸Šä¸‹æ–‡
      temporary: Math.floor(total * 0.2),   // 20% ä¸´æ—¶ä¸Šä¸‹æ–‡
      reserved: Math.floor(total * 0.1)     // 10% é¢„ç•™(è¾“å‡º)
    };
  }

  /**
   * æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦è¶…å‡ºé¢„ç®—
   */
  checkBudget(context: FullContext): BudgetCheckResult {
    const stats = this.tokenCounter.countContext(context);

    // è®¡ç®—å¯ç”¨äºè¾“å‡ºçš„tokens
    const availableForOutput = this.maxTokens - stats.total;

    const result: BudgetCheckResult = {
      isWithinBudget: stats.total <= (this.maxTokens - this.budgetAllocation.reserved),
      currentUsage: stats,
      budgetAllocation: this.budgetAllocation,
      availableForOutput,
      exceedBy: Math.max(0, stats.total - this.maxTokens),
      warnings: []
    };

    // ç”Ÿæˆè­¦å‘Š
    if (stats.static > this.budgetAllocation.static) {
      result.warnings.push(
        `é™æ€ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.static} > ${this.budgetAllocation.static}`
      );
    }

    if (stats.dynamic > this.budgetAllocation.dynamic) {
      result.warnings.push(
        `åŠ¨æ€ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.dynamic} > ${this.budgetAllocation.dynamic}`
      );
    }

    if (stats.temporary > this.budgetAllocation.temporary) {
      result.warnings.push(
        `ä¸´æ—¶ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.temporary} > ${this.budgetAllocation.temporary}`
      );
    }

    if (availableForOutput < 1000) {
      result.warnings.push(
        `å¯ç”¨è¾“å‡ºç©ºé—´ä¸è¶³: ${availableForOutput} tokens`
      );
    }

    return result;
  }

  /**
   * ä¼˜åŒ–ä¸Šä¸‹æ–‡ä»¥é€‚åº”é¢„ç®—
   */
  optimizeContext(
    context: FullContext,
    checkResult: BudgetCheckResult
  ): FullContext {
    // å¦‚æœåœ¨é¢„ç®—å†…,ç›´æ¥è¿”å›
    if (checkResult.isWithinBudget) {
      console.log('âœ… ä¸Šä¸‹æ–‡åœ¨é¢„ç®—å†…,æ— éœ€ä¼˜åŒ–');
      return context;
    }

    console.log(`âš ï¸  ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®— ${checkResult.exceedBy} tokens,å¼€å§‹ä¼˜åŒ–...`);

    let optimized = { ...context };

    // 1. ä¼˜åŒ–ä¸´æ—¶ä¸Šä¸‹æ–‡(æœ€ä½ä¼˜å…ˆçº§)
    if (checkResult.currentUsage.temporary > this.budgetAllocation.temporary) {
      optimized = this.optimizeTemporaryContext(optimized);
    }

    // 2. ä¼˜åŒ–åŠ¨æ€ä¸Šä¸‹æ–‡
    if (checkResult.currentUsage.dynamic > this.budgetAllocation.dynamic) {
      optimized = this.optimizeDynamicContext(optimized);
    }

    // 3. é‡æ–°æ£€æŸ¥
    const newCheck = this.checkBudget(optimized);
    if (newCheck.isWithinBudget) {
      console.log(`âœ… ä¼˜åŒ–å®Œæˆ,èŠ‚çœ ${checkResult.exceedBy - newCheck.exceedBy} tokens`);
      return optimized;
    }

    // 4. å¦‚æœè¿˜æ˜¯è¶…å‡º,è¿›è¡Œæ¿€è¿›æˆªæ–­
    console.log('âš ï¸  å¸¸è§„ä¼˜åŒ–ä¸è¶³,è¿›è¡Œæ¿€è¿›æˆªæ–­...');
    return this.aggressiveTruncate(optimized, this.maxTokens);
  }

  /**
   * ä¼˜åŒ–ä¸´æ—¶ä¸Šä¸‹æ–‡
   */
  private optimizeTemporaryContext(context: FullContext): FullContext {
    const optimized = { ...context };

    // é™åˆ¶å·¥å…·ç»“æœæ•°é‡(åªä¿ç•™æœ€è¿‘5ä¸ª)
    optimized.temporary = {
      ...context.temporary,
      toolResults: context.temporary.toolResults.slice(-5)
    };

    return optimized;
  }

  /**
   * ä¼˜åŒ–åŠ¨æ€ä¸Šä¸‹æ–‡
   */
  private optimizeDynamicContext(context: FullContext): FullContext {
    const optimized = { ...context };

    // 1. æˆªæ–­å¯¹è¯å†å²(ä¿ç•™æœ€è¿‘10è½®)
    optimized.dynamic = {
      ...context.dynamic,
      conversationHistory: context.dynamic.conversationHistory.slice(-10)
    };

    // 2. ç§»é™¤ä½ç›¸å…³æ€§æ–‡ä»¶
    const sortedFiles = [...context.dynamic.files].sort(
      (a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0)
    );

    // åªä¿ç•™ç›¸å…³æ€§>0.5çš„æ–‡ä»¶,æˆ–æœ€å¤š5ä¸ªæ–‡ä»¶
    optimized.dynamic.files = sortedFiles
      .filter(f => (f.relevanceScore || 0) > 0.5)
      .slice(0, 5);

    return optimized;
  }

  /**
   * æ¿€è¿›æˆªæ–­
   */
  private aggressiveTruncate(
    context: FullContext,
    maxTokens: number
  ): FullContext {
    // ä¿ç•™é™æ€ä¸Šä¸‹æ–‡
    // å¤§å¹…å‡å°‘åŠ¨æ€å’Œä¸´æ—¶ä¸Šä¸‹æ–‡
    return {
      ...context,
      dynamic: {
        ...context.dynamic,
        files: context.dynamic.files.slice(0, 2), // åªä¿ç•™2ä¸ªæ–‡ä»¶
        conversationHistory: context.dynamic.conversationHistory.slice(-5) // åªä¿ç•™5è½®å¯¹è¯
      },
      temporary: {
        ...context.temporary,
        toolResults: context.temporary.toolResults.slice(-2) // åªä¿ç•™2ä¸ªå·¥å…·ç»“æœ
      }
    };
  }

  /**
   * ç”Ÿæˆé¢„ç®—æŠ¥å‘Š
   */
  generateReport(context: FullContext): string {
    const stats = this.tokenCounter.countContext(context);
    const check = this.checkBudget(context);

    let report = '\n=== Tokené¢„ç®—æŠ¥å‘Š ===\n';
    report += `æ€»é¢„ç®—: ${this.maxTokens.toLocaleString()} tokens\n`;
    report += `å½“å‰ä½¿ç”¨: ${stats.total.toLocaleString()} tokens (${((stats.total / this.maxTokens) * 100).toFixed(1)}%)\n`;
    report += `\n--- åˆ†ç±»ç»Ÿè®¡ ---\n`;
    report += `é™æ€ä¸Šä¸‹æ–‡: ${stats.static.toLocaleString()} / ${this.budgetAllocation.static.toLocaleString()} tokens\n`;
    report += `åŠ¨æ€ä¸Šä¸‹æ–‡: ${stats.dynamic.toLocaleString()} / ${this.budgetAllocation.dynamic.toLocaleString()} tokens\n`;
    report += `ä¸´æ—¶ä¸Šä¸‹æ–‡: ${stats.temporary.toLocaleString()} / ${this.budgetAllocation.temporary.toLocaleString()} tokens\n`;
    report += `\n--- è¯¦ç»†åˆ†è§£ ---\n`;
    for (const [key, value] of Object.entries(stats.breakdown)) {
      report += `${key}: ${value.toLocaleString()} tokens\n`;
    }
    report += `\nå¯ç”¨è¾“å‡ºç©ºé—´: ${check.availableForOutput.toLocaleString()} tokens\n`;

    if (check.warnings.length > 0) {
      report += `\nâš ï¸  è­¦å‘Š:\n`;
      check.warnings.forEach(w => report += `  - ${w}\n`);
    }

    return report;
  }
}

/**
 * é¢„ç®—åˆ†é…
 */
interface BudgetAllocation {
  total: number;                  // æ€»é¢„ç®—
  static: number;                 // é™æ€ä¸Šä¸‹æ–‡é¢„ç®—
  dynamic: number;                // åŠ¨æ€ä¸Šä¸‹æ–‡é¢„ç®—
  temporary: number;              // ä¸´æ—¶ä¸Šä¸‹æ–‡é¢„ç®—
  reserved: number;               // é¢„ç•™(è¾“å‡º)
}

/**
 * é¢„ç®—æ£€æŸ¥ç»“æœ
 */
interface BudgetCheckResult {
  isWithinBudget: boolean;        // æ˜¯å¦åœ¨é¢„ç®—å†…
  currentUsage: ContextTokenStats; // å½“å‰ä½¿ç”¨æƒ…å†µ
  budgetAllocation: BudgetAllocation; // é¢„ç®—åˆ†é…
  availableForOutput: number;     // å¯ç”¨è¾“å‡ºç©ºé—´
  exceedBy: number;               // è¶…å‡ºé‡
  warnings: string[];             // è­¦å‘Šä¿¡æ¯
}

export { TokenBudgetManager, BudgetAllocation, BudgetCheckResult };
```


## å››ã€ä¸Šä¸‹æ–‡ä¼˜å…ˆçº§æ’åº

### 4.1 ä¼˜å…ˆçº§çŸ©é˜µ

| ä¸Šä¸‹æ–‡ç±»å‹ | åŸºç¡€ä¼˜å…ˆçº§ | è°ƒæ•´å› ç´  | æœ€ç»ˆèŒƒå›´ |
|-----------|----------|---------|---------|
| ç³»ç»Ÿæç¤ºè¯ | 10 | å›ºå®š | 10 |
| å½“å‰æ–‡ä»¶ | 9 | ç”¨æˆ·æ˜ç¡®æŒ‡å®š+1 | 9-10 |
| æœ€è¿‘ç¼–è¾‘ | 8 | æ—¶é—´è¡°å‡ | 5-8 |
| é”™è¯¯ä¿¡æ¯ | 8 | - | 8 |
| ç”¨æˆ·æŒ‡å®šæ–‡ä»¶ | 7-9 | æŒ‡å®šæ–¹å¼ | 7-9 |
| ç›¸å…³æ–‡ä»¶ | 7 | ç›¸å…³åº¦è¯„åˆ† | 4-7 |
| å·¥å…·è¾“å‡º | 6 | æœ€è¿‘ä½¿ç”¨+1 | 6-7 |
| GitçŠ¶æ€ | 5 | ä¿®æ”¹é‡ | 4-6 |
| é¡¹ç›®ä¿¡æ¯ | 5 | - | 5 |
| å†å²å¯¹è¯ | 4 | æ—¶é—´è¡°å‡ | 2-4 |
| æ—§æ–‡ä»¶ | 3 | ç›¸å…³åº¦ | 1-3 |

### 4.2 ä¼˜å…ˆçº§è®¡ç®—å™¨

```typescript
/**
 * ä¼˜å…ˆçº§è®¡ç®—å™¨
 */
class PriorityCalculator {
  /**
   * è®¡ç®—ä¸Šä¸‹æ–‡é¡¹çš„ä¼˜å…ˆçº§
   */
  calculate(item: ContextItem, context: PriorityContext): number {
    let priority = item.basePriority || 5;

    // 1. æ—¶é—´è¡°å‡
    if (item.timestamp) {
      priority *= this.calculateTimeDecay(item.timestamp);
    }

    // 2. ç›¸å…³æ€§åŠ æƒ
    if (item.relevanceScore !== undefined) {
      priority *= item.relevanceScore;
    }

    // 3. ç”¨æˆ·æ˜ç¡®æŒ‡å®š
    if (item.explicitlyRequested) {
      priority += 2;
    }

    // 4. æœ€è¿‘ä½¿ç”¨åŠ æƒ
    if (this.isRecentlyUsed(item, context)) {
      priority += 1;
    }

    // 5. é”™è¯¯ç›¸å…³åŠ æƒ
    if (this.isErrorRelated(item, context)) {
      priority += 1;
    }

    // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
    return Math.max(0, Math.min(10, priority));
  }

  /**
   * è®¡ç®—æ—¶é—´è¡°å‡å› å­
   */
  private calculateTimeDecay(timestamp: number): number {
    const ageMs = Date.now() - timestamp;
    const ageHours = ageMs / (1000 * 60 * 60);

    // æŒ‡æ•°è¡°å‡: æ¯å°æ—¶è¡°å‡å› å­
    // 1å°æ—¶: 1.0
    // 24å°æ—¶: 0.5
    // 168å°æ—¶(7å¤©): 0.1
    return Math.exp(-ageHours / 24);
  }

  /**
   * æ˜¯å¦æœ€è¿‘ä½¿ç”¨
   */
  private isRecentlyUsed(
    item: ContextItem,
    context: PriorityContext
  ): boolean {
    if (!item.filePath) return false;

    return context.recentlyAccessedFiles?.includes(item.filePath) || false;
  }

  /**
   * æ˜¯å¦ä¸é”™è¯¯ç›¸å…³
   */
  private isErrorRelated(
    item: ContextItem,
    context: PriorityContext
  ): boolean {
    if (!context.recentError) return false;

    // æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦åœ¨é”™è¯¯å †æ ˆä¸­
    if (item.filePath && context.recentError.includes(item.filePath)) {
      return true;
    }

    // æ£€æŸ¥å†…å®¹æ˜¯å¦åŒ…å«é”™è¯¯å…³é”®å­—
    if (context.errorKeywords?.some(kw => item.content.includes(kw))) {
      return true;
    }

    return false;
  }

  /**
   * æ‰¹é‡è®¡ç®—ä¼˜å…ˆçº§
   */
  calculateBatch(
    items: ContextItem[],
    context: PriorityContext
  ): ContextItemWithPriority[] {
    return items.map(item => ({
      ...item,
      calculatedPriority: this.calculate(item, context)
    }));
  }

  /**
   * æ’åºä¸Šä¸‹æ–‡é¡¹(æŒ‰ä¼˜å…ˆçº§é™åº)
   */
  sort(items: ContextItemWithPriority[]): ContextItemWithPriority[] {
    return [...items].sort((a, b) => b.calculatedPriority - a.calculatedPriority);
  }
}

/**
 * ä¼˜å…ˆçº§ä¸Šä¸‹æ–‡(ç”¨äºè®¡ç®—ä¼˜å…ˆçº§çš„è¾…åŠ©ä¿¡æ¯)
 */
interface PriorityContext {
  recentlyAccessedFiles?: string[];  // æœ€è¿‘è®¿é—®çš„æ–‡ä»¶
  recentError?: string;              // æœ€è¿‘çš„é”™è¯¯ä¿¡æ¯
  errorKeywords?: string[];          // é”™è¯¯å…³é”®å­—
  currentTask?: string;              // å½“å‰ä»»åŠ¡
}

/**
 * å¸¦ä¼˜å…ˆçº§çš„ä¸Šä¸‹æ–‡é¡¹
 */
interface ContextItemWithPriority extends ContextItem {
  calculatedPriority: number;        // è®¡ç®—åçš„ä¼˜å…ˆçº§
  basePriority?: number;             // åŸºç¡€ä¼˜å…ˆçº§
  timestamp?: number;                // æ—¶é—´æˆ³
  relevanceScore?: number;           // ç›¸å…³æ€§è¯„åˆ†(0-1)
  explicitlyRequested?: boolean;     // æ˜¯å¦ç”¨æˆ·æ˜ç¡®è¯·æ±‚
  filePath?: string;                 // æ–‡ä»¶è·¯å¾„
}

export { PriorityCalculator, PriorityContext, ContextItemWithPriority };
```

### 4.3 åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´

```typescript
/**
 * åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´å™¨
 */
class DynamicPriorityAdjuster {
  private calculator: PriorityCalculator;
  private history: AdjustmentHistory[];

  constructor() {
    this.calculator = new PriorityCalculator();
    this.history = [];
  }

  /**
   * æ ¹æ®AIåé¦ˆè°ƒæ•´ä¼˜å…ˆçº§
   */
  adjustBasedOnFeedback(
    items: ContextItemWithPriority[],
    feedback: AIFeedback
  ): ContextItemWithPriority[] {
    const adjusted = [...items];

    // å¦‚æœAIè¯´ä¸Šä¸‹æ–‡ä¸è¶³
    if (feedback.type === 'insufficient_context') {
      // æå‡ç›¸å…³æ–‡ä»¶çš„ä¼˜å…ˆçº§
      feedback.requestedFiles?.forEach(filePath => {
        const item = adjusted.find(i => i.filePath === filePath);
        if (item) {
          item.calculatedPriority += 1;
          this.recordAdjustment('boost', filePath, 1);
        }
      });
    }

    // å¦‚æœAIè¯´ä¸Šä¸‹æ–‡è¿‡å¤š
    if (feedback.type === 'too_much_context') {
      // é™ä½ä¸ç›¸å…³æ–‡ä»¶çš„ä¼˜å…ˆçº§
      feedback.unusedFiles?.forEach(filePath => {
        const item = adjusted.find(i => i.filePath === filePath);
        if (item) {
          item.calculatedPriority -= 0.5;
          this.recordAdjustment('reduce', filePath, 0.5);
        }
      });
    }

    return adjusted;
  }

  /**
   * æ ¹æ®ç”¨æˆ·è¡Œä¸ºè°ƒæ•´
   */
  adjustBasedOnUserBehavior(
    items: ContextItemWithPriority[],
    behavior: UserBehavior
  ): ContextItemWithPriority[] {
    const adjusted = [...items];

    // ç”¨æˆ·æ‰“å¼€äº†æŸä¸ªæ–‡ä»¶
    if (behavior.action === 'file_opened') {
      const item = adjusted.find(i => i.filePath === behavior.filePath);
      if (item) {
        item.explicitlyRequested = true;
        item.calculatedPriority += 2;
        this.recordAdjustment('user_opened', behavior.filePath!, 2);
      }
    }

    // ç”¨æˆ·ç¼–è¾‘äº†æŸä¸ªæ–‡ä»¶
    if (behavior.action === 'file_edited') {
      const item = adjusted.find(i => i.filePath === behavior.filePath);
      if (item) {
        item.timestamp = Date.now();
        item.calculatedPriority += 1;
        this.recordAdjustment('user_edited', behavior.filePath!, 1);
      }
    }

    return adjusted;
  }

  /**
   * è®°å½•è°ƒæ•´å†å²
   */
  private recordAdjustment(
    type: string,
    target: string,
    amount: number
  ): void {
    this.history.push({
      type,
      target,
      amount,
      timestamp: Date.now()
    });

    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.history.length > 100) {
      this.history.shift();
    }
  }

  /**
   * è·å–è°ƒæ•´å†å²
   */
  getHistory(): AdjustmentHistory[] {
    return [...this.history];
  }
}

/**
 * AIåé¦ˆ
 */
interface AIFeedback {
  type: 'insufficient_context' | 'too_much_context' | 'optimal';
  requestedFiles?: string[];      // AIè¯·æ±‚çš„æ–‡ä»¶
  unusedFiles?: string[];         // AIæœªä½¿ç”¨çš„æ–‡ä»¶
  message?: string;               // åé¦ˆæ¶ˆæ¯
}

/**
 * ç”¨æˆ·è¡Œä¸º
 */
interface UserBehavior {
  action: 'file_opened' | 'file_edited' | 'file_closed';
  filePath?: string;
  timestamp: number;
}

/**
 * è°ƒæ•´å†å²
 */
interface AdjustmentHistory {
  type: string;                   // è°ƒæ•´ç±»å‹
  target: string;                 // è°ƒæ•´ç›®æ ‡
  amount: number;                 // è°ƒæ•´é‡
  timestamp: number;              // æ—¶é—´æˆ³
}

export { DynamicPriorityAdjuster, AIFeedback, UserBehavior };
```


## å…­ã€æ–‡ä»¶ç›‘å¬å’Œå¢é‡æ›´æ–°

### 6.1 æ–‡ä»¶ç›‘å¬å™¨

```typescript
import chokidar from 'chokidar';
import { EventEmitter } from 'events';

/**
 * æ–‡ä»¶ç›‘å¬å™¨
 */
class FileWatcher extends EventEmitter {
  private watcher: chokidar.FSWatcher | null = null;
  private editHistory: EditHistory[] = [];
  private maxHistorySize: number = 100;

  constructor(private workspaceRoot: string) {
    super();
  }

  /**
   * å¯åŠ¨ç›‘å¬
   */
  start(): void {
    console.log(`ğŸ‘€ å¼€å§‹ç›‘å¬æ–‡ä»¶å˜åŒ–: ${this.workspaceRoot}`);

    this.watcher = chokidar.watch(this.workspaceRoot, {
      ignored: /(^|[\/\\])\../, // å¿½ç•¥éšè—æ–‡ä»¶
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 500,
        pollInterval: 100
      }
    });

    // ç›‘å¬æ–‡ä»¶å˜åŒ–äº‹ä»¶
    this.watcher
      .on('add', (path) => this.onFileAdded(path))
      .on('change', (path) => this.onFileChanged(path))
      .on('unlink', (path) => this.onFileDeleted(path));
  }

  /**
   * åœæ­¢ç›‘å¬
   */
  async stop(): Promise<void> {
    if (this.watcher) {
      await this.watcher.close();
      this.watcher = null;
      console.log('âœ… æ–‡ä»¶ç›‘å¬å·²åœæ­¢');
    }
  }

  /**
   * æ–‡ä»¶æ·»åŠ äº‹ä»¶
   */
  private onFileAdded(filePath: string): void {
    console.log(`â• æ–‡ä»¶æ·»åŠ : ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'create',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:added', edit);
  }

  /**
   * æ–‡ä»¶ä¿®æ”¹äº‹ä»¶
   */
  private onFileChanged(filePath: string): void {
    console.log(`âœï¸  æ–‡ä»¶ä¿®æ”¹: ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'modify',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:changed', edit);
  }

  /**
   * æ–‡ä»¶åˆ é™¤äº‹ä»¶
   */
  private onFileDeleted(filePath: string): void {
    console.log(`âŒ æ–‡ä»¶åˆ é™¤: ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'delete',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:deleted', edit);
  }

  /**
   * æ·»åŠ åˆ°å†å²è®°å½•
   */
  private addToHistory(edit: EditHistory): void {
    this.editHistory.push(edit);

    // é™åˆ¶å†å²è®°å½•å¤§å°
    if (this.editHistory.length > this.maxHistorySize) {
      this.editHistory.shift();
    }
  }

  /**
   * è·å–æœ€è¿‘ç¼–è¾‘è®°å½•
   */
  getRecentEdits(count: number = 10): EditHistory[] {
    return this.editHistory.slice(-count);
  }

  /**
   * è·å–ç‰¹å®šæ–‡ä»¶çš„ç¼–è¾‘å†å²
   */
  getFileEditHistory(filePath: string): EditHistory[] {
    return this.editHistory.filter(e => e.filePath === filePath);
  }

  /**
   * æ¸…ç©ºå†å²è®°å½•
   */
  clearHistory(): void {
    this.editHistory = [];
  }
}

export { FileWatcher };
```

### 6.2 å¢é‡æ›´æ–°ç®¡ç†å™¨

```typescript
/**
 * å¢é‡æ›´æ–°ç®¡ç†å™¨
 */
class IncrementalUpdateManager {
  private fileCache: Map<string, FileSnapshot>;
  private fileWatcher: FileWatcher;

  constructor(workspaceRoot: string) {
    this.fileCache = new Map();
    this.fileWatcher = new FileWatcher(workspaceRoot);

    // ç›‘å¬æ–‡ä»¶å˜åŒ–
    this.fileWatcher.on('file:changed', (edit) => {
      this.handleFileChange(edit);
    });

    this.fileWatcher.start();
  }

  /**
   * å¤„ç†æ–‡ä»¶å˜åŒ–
   */
  private async handleFileChange(edit: EditHistory): Promise<void> {
    const oldSnapshot = this.fileCache.get(edit.filePath);
    if (!oldSnapshot) {
      // é¦–æ¬¡è¯»å–,å…¨é‡åŠ è½½
      await this.loadFullFile(edit.filePath);
      return;
    }

    // è®¡ç®—å·®å¼‚
    const newContent = await fs.readFile(edit.filePath, 'utf-8');
    const diff = this.calculateDiff(oldSnapshot.content, newContent);

    // æ›´æ–°ç¼“å­˜
    this.fileCache.set(edit.filePath, {
      path: edit.filePath,
      content: newContent,
      timestamp: Date.now(),
      diff
    });

    console.log(`ğŸ“ å¢é‡æ›´æ–°: ${edit.filePath}`);
    console.log(`  æ·»åŠ : ${diff.added.length}è¡Œ, åˆ é™¤: ${diff.removed.length}è¡Œ`);
  }

  /**
   * åŠ è½½å®Œæ•´æ–‡ä»¶
   */
  private async loadFullFile(filePath: string): Promise<void> {
    const content = await fs.readFile(filePath, 'utf-8');

    this.fileCache.set(filePath, {
      path: filePath,
      content,
      timestamp: Date.now()
    });
  }

  /**
   * è®¡ç®—æ–‡ä»¶å·®å¼‚
   */
  private calculateDiff(
    oldContent: string,
    newContent: string
  ): FileDiff {
    const oldLines = oldContent.split('\n');
    const newLines = newContent.split('\n');

    const added: DiffLine[] = [];
    const removed: DiffLine[] = [];
    const modified: DiffLine[] = [];

    // ç®€å•çš„é€è¡Œæ¯”è¾ƒ(å®é™…åº”ç”¨ä¸­å¯ä½¿ç”¨diffç®—æ³•å¦‚Myers)
    const maxLen = Math.max(oldLines.length, newLines.length);

    for (let i = 0; i < maxLen; i++) {
      const oldLine = oldLines[i];
      const newLine = newLines[i];

      if (oldLine === undefined) {
        // æ–°å¢è¡Œ
        added.push({ lineNumber: i + 1, content: newLine });
      } else if (newLine === undefined) {
        // åˆ é™¤è¡Œ
        removed.push({ lineNumber: i + 1, content: oldLine });
      } else if (oldLine !== newLine) {
        // ä¿®æ”¹è¡Œ
        modified.push({
          lineNumber: i + 1,
          content: newLine,
          oldContent: oldLine
        });
      }
    }

    return { added, removed, modified };
  }

  /**
   * è·å–æ–‡ä»¶å¿«ç…§
   */
  getFileSnapshot(filePath: string): FileSnapshot | undefined {
    return this.fileCache.get(filePath);
  }

  /**
   * è·å–å˜åŒ–æ‘˜è¦
   */
  getChangesSummary(since: number): ChangesSummary {
    const changes: ChangesSummary = {
      filesChanged: 0,
      linesAdded: 0,
      linesRemoved: 0,
      files: []
    };

    for (const [path, snapshot] of this.fileCache.entries()) {
      if (snapshot.timestamp >= since && snapshot.diff) {
        changes.filesChanged++;
        changes.linesAdded += snapshot.diff.added.length;
        changes.linesRemoved += snapshot.diff.removed.length;
        changes.files.push(path);
      }
    }

    return changes;
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  clearCache(): void {
    this.fileCache.clear();
  }

  /**
   * åœæ­¢ç›‘å¬
   */
  async dispose(): Promise<void> {
    await this.fileWatcher.stop();
    this.clearCache();
  }
}

/**
 * æ–‡ä»¶å¿«ç…§
 */
interface FileSnapshot {
  path: string;
  content: string;
  timestamp: number;
  diff?: FileDiff;
}

/**
 * æ–‡ä»¶å·®å¼‚
 */
interface FileDiff {
  added: DiffLine[];
  removed: DiffLine[];
  modified: DiffLine[];
}

/**
 * å·®å¼‚è¡Œ
 */
interface DiffLine {
  lineNumber: number;
  content: string;
  oldContent?: string;
}

/**
 * å˜åŒ–æ‘˜è¦
 */
interface ChangesSummary {
  filesChanged: number;
  linesAdded: number;
  linesRemoved: number;
  files: string[];
}

export { IncrementalUpdateManager, FileSnapshot, FileDiff, ChangesSummary };
```


## å…«ã€ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ•´åˆ

### 8.1 å®Œæ•´çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```typescript
/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨ - æ•´åˆæ‰€æœ‰ä¸Šä¸‹æ–‡ç®¡ç†åŠŸèƒ½
 */
class ContextManager {
  private collector: ContextCollector;
  private tokenCounter: TokenCounter;
  private budgetManager: TokenBudgetManager;
  private truncator: SmartTruncator;
  private priorityCalculator: PriorityCalculator;
  private cache: MultiLevelCache;
  private compressor: ContextCompressor;

  constructor(config: ContextManagerConfig) {
    this.collector = new ContextCollector(config.workspaceRoot);
    this.tokenCounter = new TokenCounter();
    this.budgetManager = new TokenBudgetManager(config.maxTokens);
    this.truncator = new SmartTruncator(config.maxTokens);
    this.priorityCalculator = new PriorityCalculator();
    this.cache = new MultiLevelCache(config.cacheConfig || {});
    this.compressor = new ContextCompressor();
  }

  /**
   * å‡†å¤‡ä¸Šä¸‹æ–‡ - ä¸»å…¥å£
   */
  async prepareContext(options: PrepareOptions): Promise<PreparedContext> {
    console.log('ğŸ”„ å¼€å§‹å‡†å¤‡ä¸Šä¸‹æ–‡...');

    // 1. æ”¶é›†åŸå§‹ä¸Šä¸‹æ–‡
    const rawContext = await this.collector.collectFullContext({
      conversationHistory: options.conversationHistory,
      recentToolResults: options.toolResults,
      userFiles: options.userFiles
    });

    // 2. è®¡ç®—ä¼˜å…ˆçº§
    const contextItems = this.convertToItems(rawContext);
    const prioritized = this.priorityCalculator.calculateBatch(
      contextItems,
      options.priorityContext || {}
    );

    // 3. æ£€æŸ¥tokené¢„ç®—
    const budgetCheck = this.budgetManager.checkBudget(rawContext);

    // 4. å¦‚æœè¶…å‡ºé¢„ç®—,è¿›è¡Œä¼˜åŒ–
    let optimizedItems = prioritized;
    if (!budgetCheck.isWithinBudget) {
      console.log('âš ï¸  è¶…å‡ºé¢„ç®—,è¿›è¡Œä¼˜åŒ–...');

      // æ’åº
      optimizedItems = this.priorityCalculator.sort(prioritized);

      // æˆªæ–­
      const targetTokens = this.budgetManager.budgetAllocation.total -
        this.budgetManager.budgetAllocation.reserved;
      optimizedItems = this.truncator.truncate(optimizedItems, targetTokens);
    }

    // 5. è½¬æ¢å›å®Œæ•´ä¸Šä¸‹æ–‡æ ¼å¼
    const finalContext = this.convertToFullContext(optimizedItems, rawContext);

    // 6. ç”ŸæˆæŠ¥å‘Š
    const report = this.budgetManager.generateReport(finalContext);
    console.log(report);

    return {
      context: finalContext,
      metadata: {
        totalItems: contextItems.length,
        includedItems: optimizedItems.length,
        totalTokens: this.tokenCounter.countContext(finalContext).total,
        budgetUtilization: budgetCheck.currentUsage.total / budgetCheck.budgetAllocation.total,
        optimized: !budgetCheck.isWithinBudget
      }
    };
  }

  /**
   * å°†FullContextè½¬æ¢ä¸ºContextItemæ•°ç»„
   */
  private convertToItems(context: FullContext): ContextItem[] {
    const items: ContextItem[] = [];

    // é™æ€ä¸Šä¸‹æ–‡
    items.push({
      type: 'system',
      content: context.static.systemPrompt,
      priority: 10,
      tokens: this.tokenCounter.count(context.static.systemPrompt)
    });

    // åŠ¨æ€ä¸Šä¸‹æ–‡ - æ–‡ä»¶
    for (const file of context.dynamic.files) {
      items.push({
        type: 'file',
        content: file.content,
        priority: 7,
        tokens: this.tokenCounter.count(file.content),
        metadata: {
          path: file.path,
          language: file.language
        },
        filePath: file.path,
        relevanceScore: file.relevanceScore,
        timestamp: file.lastModified
      });
    }

    // å¯¹è¯å†å²
    if (context.dynamic.conversationHistory.length > 0) {
      items.push({
        type: 'conversation',
        content: JSON.stringify(context.dynamic.conversationHistory),
        priority: 4,
        tokens: this.tokenCounter.countMessages(context.dynamic.conversationHistory)
      });
    }

    // å·¥å…·ç»“æœ
    for (const result of context.temporary.toolResults) {
      items.push({
        type: 'tool_result',
        content: JSON.stringify(result),
        priority: 6,
        tokens: this.tokenCounter.count(JSON.stringify(result)),
        timestamp: result.timestamp
      });
    }

    return items;
  }

  /**
   * å°†ContextItemæ•°ç»„è½¬æ¢å›FullContext
   */
  private convertToFullContext(
    items: ContextItem[],
    original: FullContext
  ): FullContext {
    const result: FullContext = {
      static: { ...original.static },
      dynamic: {
        files: [],
        gitStatus: original.dynamic.gitStatus,
        conversationHistory: [],
        recentEdits: original.dynamic.recentEdits
      },
      temporary: {
        toolResults: [],
        userSpecifiedFiles: original.temporary.userSpecifiedFiles,
        sessionVariables: original.temporary.sessionVariables,
        pendingOperations: []
      },
      timestamp: Date.now()
    };

    // é‡æ–°ç»„è£…
    for (const item of items) {
      if (item.type === 'system') {
        result.static.systemPrompt = item.content;
      } else if (item.type === 'file' && item.metadata?.path) {
        result.dynamic.files.push({
          path: item.metadata.path,
          content: item.content,
          language: item.metadata.language,
          size: item.content.length,
          lastModified: item.timestamp || Date.now(),
          relevanceScore: item.relevanceScore
        });
      } else if (item.type === 'conversation') {
        result.dynamic.conversationHistory = JSON.parse(item.content);
      } else if (item.type === 'tool_result') {
        result.temporary.toolResults.push(JSON.parse(item.content));
      }
    }

    return result;
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  async cleanup(): Promise<void> {
    await this.cache.cleanup();
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): ContextManagerStats {
    return {
      cache: this.cache.getStats(),
      budget: this.budgetManager.budgetAllocation
    };
  }
}

/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨é…ç½®
 */
interface ContextManagerConfig {
  workspaceRoot: string;
  maxTokens?: number;
  cacheConfig?: CacheConfig;
}

/**
 * å‡†å¤‡é€‰é¡¹
 */
interface PrepareOptions {
  conversationHistory?: Message[];
  toolResults?: ToolResult[];
  userFiles?: string[];
  priorityContext?: PriorityContext;
}

/**
 * å‡†å¤‡å¥½çš„ä¸Šä¸‹æ–‡
 */
interface PreparedContext {
  context: FullContext;
  metadata: {
    totalItems: number;
    includedItems: number;
    totalTokens: number;
    budgetUtilization: number;
    optimized: boolean;
  };
}

/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç»Ÿè®¡
 */
interface ContextManagerStats {
  cache: MultiLevelCacheStats;
  budget: BudgetAllocation;
}

export { ContextManager, ContextManagerConfig, PrepareOptions, PreparedContext };
```


## åã€å¸¸è§é—®é¢˜FAQ

### Q1: å¦‚ä½•é€‰æ‹©åˆé€‚çš„Tokené¢„ç®—?

**å»ºè®®**:
```typescript
// æ ¹æ®ä»»åŠ¡å¤æ‚åº¦è°ƒæ•´
const budgetByTask = {
  simple: 50000,    // ç®€å•ä»»åŠ¡(ä»£ç æ ¼å¼åŒ–ç­‰)
  medium: 100000,   // ä¸­ç­‰ä»»åŠ¡(ä»£ç é‡æ„ç­‰)
  complex: 150000   // å¤æ‚ä»»åŠ¡(æ¶æ„è®¾è®¡ç­‰)
};

// ç›‘æ§å®é™…ä½¿ç”¨æƒ…å†µ
const stats = contextManager.getStats();
if (stats.budgetUtilization > 0.9) {
  console.warn('é¢„ç®—ä½¿ç”¨ç‡è¿‡é«˜,è€ƒè™‘å¢åŠ é¢„ç®—æˆ–ä¼˜åŒ–ä¸Šä¸‹æ–‡');
}
```

### Q2: ä¸Šä¸‹æ–‡è¿‡å¤§å¯¼è‡´å“åº”æ…¢æ€ä¹ˆåŠ?

**è§£å†³æ–¹æ¡ˆ**:
1. **å¯ç”¨ç¼“å­˜**: é¿å…é‡å¤è¯»å–æ–‡ä»¶
2. **æ™ºèƒ½æˆªæ–­**: ç§»é™¤ä½ä¼˜å…ˆçº§å†…å®¹
3. **å‹ç¼©å†…å®¹**: ç§»é™¤æ³¨é‡Šã€ç©ºè¡Œ
4. **åˆ†æ‰¹å¤„ç†**: å°†å¤§ä»»åŠ¡æ‹†åˆ†

```typescript
// ç¤ºä¾‹: åˆ†æ‰¹å¤„ç†å¤§é‡æ–‡ä»¶
async function processLargeCodebase(files: string[]) {
  const batchSize = 10;

  for (let i = 0; i < files.length; i += batchSize) {
    const batch = files.slice(i, i + batchSize);
    await processFiles(batch);
  }
}
```

### Q3: å¦‚ä½•å¤„ç†é¢‘ç¹å˜åŒ–çš„æ–‡ä»¶?

**ç­–ç•¥**:
```typescript
// 1. ä½¿ç”¨æ–‡ä»¶ç›‘å¬
const watcher = new FileWatcher(workspaceRoot);
watcher.on('file:changed', async (edit) => {
  // å¤±æ•ˆç¼“å­˜
  cache.delete(edit.filePath);

  // é€šçŸ¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨
  contextManager.onFileChanged(edit);
});

// 2. è®¾ç½®è¾ƒçŸ­çš„ç¼“å­˜TTL
cache.set(filePath, content, 60000); // 1åˆ†é’Ÿè¿‡æœŸ
```

### Q4: å¤šä¸ªç”¨æˆ·å…±äº«ä¸Šä¸‹æ–‡ç¼“å­˜æ˜¯å¦å®‰å…¨?

**æ³¨æ„äº‹é¡¹**:
```typescript
// âŒ ä¸å®‰å…¨: ç›´æ¥å…±äº«
const sharedCache = new LRUCache(1000);

// âœ… å®‰å…¨: æŒ‰ç”¨æˆ·éš”ç¦»
class UserContextCache {
  private caches = new Map<string, LRUCache>();

  getCache(userId: string): LRUCache {
    if (!this.caches.has(userId)) {
      this.caches.set(userId, new LRUCache(100));
    }
    return this.caches.get(userId)!;
  }
}
```

### Q5: å¦‚ä½•è°ƒè¯•ä¸Šä¸‹æ–‡é—®é¢˜?

**è°ƒè¯•æŠ€å·§**:
```typescript
// 1. å¯ç”¨è¯¦ç»†æ—¥å¿—
contextManager.setDebugMode(true);

// 2. å¯¼å‡ºä¸Šä¸‹æ–‡å¿«ç…§
const snapshot = contextManager.exportSnapshot();
fs.writeFileSync('context-snapshot.json', JSON.stringify(snapshot, null, 2));

// 3. åˆ†æTokenåˆ†å¸ƒ
const report = budgetManager.generateReport(context);
console.log(report);
```


## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **ä¸Šä¸‹æ–‡åˆ†ç±»**
   - é™æ€ä¸Šä¸‹æ–‡: ä¸å˜çš„åŸºç¡€ä¿¡æ¯
   - åŠ¨æ€ä¸Šä¸‹æ–‡: éšé¡¹ç›®çŠ¶æ€å˜åŒ–
   - ä¸´æ—¶ä¸Šä¸‹æ–‡: å•æ¬¡å¯¹è¯æœ‰æ•ˆ

2. **Tokenç®¡ç†**
   - ç²¾ç¡®è®¡æ•°: ä½¿ç”¨tiktokenåº“
   - é¢„ç®—åˆ†é…: é™æ€10%ã€åŠ¨æ€70%ã€ä¸´æ—¶20%
   - é¢„ç•™ç©ºé—´: è‡³å°‘10%ç”¨äºè¾“å‡º

3. **æ™ºèƒ½æˆªæ–­**
   - ä¼˜å…ˆçº§æ’åº: ç³»ç»Ÿ>å½“å‰æ–‡ä»¶>æœ€è¿‘ç¼–è¾‘>å†å²å¯¹è¯
   - åˆ†å±‚æˆªæ–­: å…ˆä¸´æ—¶ã€å†åŠ¨æ€ã€ä¿æŠ¤é™æ€
   - éƒ¨åˆ†ä¿ç•™: å¤§æ–‡ä»¶æˆªå–é‡è¦éƒ¨åˆ†

4. **ç¼“å­˜ä¼˜åŒ–**
   - å¤šçº§ç¼“å­˜: L1å†…å­˜ + L2ç£ç›˜
   - LRUç­–ç•¥: è‡ªåŠ¨æ·˜æ±°æœ€ä¹…æœªç”¨
   - TTLè¿‡æœŸ: é¿å…è¿‡æœŸæ•°æ®

5. **å¢é‡æ›´æ–°**
   - æ–‡ä»¶ç›‘å¬: å®æ—¶æ„ŸçŸ¥å˜åŒ–
   - å·®å¼‚è®¡ç®—: åªæ›´æ–°å˜åŒ–éƒ¨åˆ†
   - æ™ºèƒ½å¤±æ•ˆ: ç²¾å‡†å¤±æ•ˆç¼“å­˜

### æœ€ä½³å®è·µæ€»ç»“

âœ… **DO åº”è¯¥åšçš„**:
- æ˜ç¡®å®šä¹‰ä¼˜å…ˆçº§ç­–ç•¥
- é¢„ç•™å……è¶³çš„è¾“å‡ºTokenç©ºé—´
- å¯ç”¨å¤šçº§ç¼“å­˜
- ç›‘æ§Tokenä½¿ç”¨æƒ…å†µ
- å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜

âŒ **DON'T ä¸åº”è¯¥åšçš„**:
- å°†æ‰€æœ‰æ–‡ä»¶éƒ½åŠ å…¥ä¸Šä¸‹æ–‡
- å¿½ç•¥Tokené¢„ç®—é™åˆ¶
- ç¼“å­˜æ°¸ä¸è¿‡æœŸ
- ç¡¬ç¼–ç ä¼˜å…ˆçº§å€¼
- é˜»å¡ä¸»çº¿ç¨‹è¯»å–å¤§æ–‡ä»¶

### æ€§èƒ½æŒ‡æ ‡

ä¼˜ç§€çš„ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿåº”è¯¥è¾¾åˆ°:
- Tokené¢„ç®—åˆ©ç”¨ç‡: 70-90%
- ç¼“å­˜å‘½ä¸­ç‡: >90%
- ä¸Šä¸‹æ–‡å‡†å¤‡æ—¶é—´: <1ç§’
- å†…å­˜å ç”¨: <500MB
- æ–‡ä»¶å˜åŒ–å“åº”: <100ms

### ä¸‹ä¸€æ­¥

åœ¨æŒæ¡äº†ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿå,ä½ å¯ä»¥:

1. **æ·±å…¥å­¦ä¹ ç¬¬4ç¯‡**: ä¼šè¯ä¸çŠ¶æ€ç®¡ç†
2. **å®è·µé¡¹ç›®**: æ„å»ºè‡ªå·±çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨
3. **æ€§èƒ½ä¼˜åŒ–**: é’ˆå¯¹å¤§å‹é¡¹ç›®ä¼˜åŒ–
4. **æ‰©å±•åŠŸèƒ½**: æ”¯æŒæ›´å¤šæ–‡ä»¶ç±»å‹å’Œæ•°æ®æº


**ç³»åˆ—æ–‡ç« å¯¼èˆª**:
- [ç¬¬1ç¯‡: æ•´ä½“æ¶æ„è®¾è®¡](./01-æ•´ä½“æ¶æ„è®¾è®¡.md)
- [ç¬¬2ç¯‡: æ ¸å¿ƒå¼•æ“å®ç°](./02-æ ¸å¿ƒå¼•æ“å®ç°.md)
- [ç¬¬3ç¯‡: ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ](./03-ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ.md) (å½“å‰)
- [ç¬¬4ç¯‡: ä¼šè¯ä¸çŠ¶æ€ç®¡ç†](./04-ä¼šè¯ä¸çŠ¶æ€ç®¡ç†.md) (å³å°†å‘å¸ƒ)

---

**æ–‡æ¡£ä¿¡æ¯**:
- å­—æ•°ç»Ÿè®¡: ~9,500å­—
- ä»£ç ç¤ºä¾‹: 20+
- Mermaidå›¾: 5ä¸ª
- æœ€åæ›´æ–°: 2025-01-14
