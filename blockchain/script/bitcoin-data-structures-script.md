---
title: 比特币数据结构 - 视频脚本
date: 2025-01-22
categories:
  - Blockchain
  - Bitcoin
---

# 比特币数据结构 - 视频脚本

**视频时长：10分钟**
**目标受众：有编程基础的开发者**

---

## 【开场Hook】(30秒，约120字)

大家好！如果我问你："区块链是如何存储数据的？一笔比特币交易包含哪些信息？你的比特币余额存在哪里？"你能准确回答吗？

很多人只知道比特币是一串数字，但不了解底层的数据组织方式。今天这期视频，我要带你深入比特币的"数据库"，看看区块、交易、UTXO这些核心数据结构是如何设计的。理解了这些，你就真正理解了区块链的本质。

---

## 【主题介绍】(30秒，约130字)

这期视频我会详细讲解比特币的四大核心数据结构：

- **第一**，区块结构，看看80字节的区块头包含什么信息
- **第二**，交易结构，理解输入和输出是如何工作的
- **第三**，UTXO模型，搞清楚比特币余额的真相
- **第四**，链式存储，理解区块如何连接成不可篡改的链

掌握这四个数据结构，你就能读懂任何一个区块浏览器上的信息，甚至能自己开发区块链应用。

---

## 【第一部分：区块结构】(2.5分钟，约600字)

### 1. 区块的两部分

一个比特币区块由两部分组成：**区块头**和**区块体**。

**区块头**只有80字节，却包含了区块的所有关键信息。**区块体**包含实际的交易数据，大小可以达到几MB。

为什么要这样设计？因为轻节点只需要下载区块头就能验证区块，不用下载所有交易数据，大大节省了存储和带宽。

### 2. 区块头的6个字段

让我们仔细看看80字节的区块头都包含什么：

**第一个字段：版本号（4字节）**
- 表示区块遵循的协议版本
- 当前主要是版本2、3、4
- 用于软分叉升级

**第二个字段：前一区块哈希（32字节）**
- 这是整个区块链的核心！
- 每个区块都指向前一个区块的哈希
- 形成不可篡改的链式结构
- 如果有人篡改历史区块，这个哈希值就会变化，链条断裂

**第三个字段：Merkle根（32字节）**
- 代表区块中所有交易的哈希树根
- 任何一笔交易的改动都会改变Merkle根
- 支持SPV轻节点快速验证交易

**第四个字段：时间戳（4字节）**
- 记录区块创建的大致时间
- Unix时间戳，精确到秒
- 用于难度调整和时间锁定

**第五个字段：难度目标（4字节）**
- 也叫bits，是难度的压缩表示
- 定义了有效区块哈希的目标值
- 每2016个区块调整一次

**第六个字段：Nonce（4字节）**
- 随机数，矿工不断改变这个值来寻找有效哈希
- Nonce从0到42亿，矿工依次尝试
- 找到合适的Nonce就挖到了区块

### 3. 区块头的哈希计算

区块的哈希值就是对这80字节进行**双重SHA-256**得到的。

注意，**区块哈希并不存储在区块中**，它是动态计算出来的。下一个区块会引用这个哈希，形成链接。

而且，区块哈希在比特币中是**反向存储**的，也就是小端序。这是历史遗留问题，但我们要知道这个细节。

### 4. 创世区块

比特币的第一个区块叫**创世区块**，区块高度为0，在2009年1月3日被挖出。

它有几个特殊之处：
- 前一区块哈希全是0（因为没有前一个区块）
- Coinbase交易包含了中本聪的留言："The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"（泰晤士报：财政大臣即将第二次救助银行）
- 创世区块的奖励50 BTC无法花费（这是代码的一个bug，但已经成为特性）

### 5. 区块体

区块体包含：
- 交易计数器（可变长度整数）
- 交易列表（第一笔必定是Coinbase交易）

区块大小有限制，最初是1MB，后来通过隔离见证扩容到4MB（以区块权重计算）。

---

## 【第二部分：交易结构】(3分钟，约700字)

### 1. 交易的四个部分

一笔比特币交易包含四个部分：

**版本号（4字节）** - 交易格式版本
**输入列表** - 花费哪些UTXO
**输出列表** - 创建新的UTXO
**锁定时间（4字节）** - 交易生效时间

关键在于理解**输入和输出**。

### 2. 交易输入详解

每个交易输入包含4个字段：

**1. 前一笔交易哈希（32字节）**
- 指向要花费的交易ID
- 这就是区块链的"引用"机制

**2. 输出索引（4字节）**
- 指向那笔交易的第几个输出
- 因为一笔交易可以有多个输出

**3. 解锁脚本（可变长度）**
- 也叫scriptSig
- 包含签名和公钥
- 证明你有权花费这个输出

**4. 序列号（4字节）**
- 用于交易替换和时间锁定
- 通常设为0xFFFFFFFF

这四个字段合起来叫做**输入**，它引用了之前的某个未花费输出。

### 3. 交易输出详解

每个交易输出包含2个字段：

**1. 金额（8字节）**
- 以"聪"为单位（1 BTC = 1亿聪）
- 64位整数，支持8位小数精度

**2. 锁定脚本（可变长度）**
- 也叫scriptPubKey
- 定义了花费这个输出的条件
- 通常是"证明你拥有某个私钥"

输出创建的就是新的UTXO，等待被花费。

### 4. 交易脚本系统

比特币有一套独特的脚本语言，基于栈的、非图灵完备的语言。

最常见的是**P2PKH**（Pay to Public Key Hash，支付到公钥哈希）：

**锁定脚本**：
```
OP_DUP OP_HASH160 <公钥哈希> OP_EQUALVERIFY OP_CHECKSIG
```

**解锁脚本**：
```
<签名> <公钥>
```

验证时，先执行解锁脚本，再执行锁定脚本：
1. 把签名和公钥压入栈
2. OP_DUP复制公钥
3. OP_HASH160计算公钥哈希
4. 比较哈希是否匹配
5. OP_CHECKSIG验证签名

所有操作成功，栈顶为真，交易有效。

### 5. 交易ID（TXID）

交易ID是对整个交易进行**双重SHA-256哈希**得到的。

重要的是，**交易ID只包含交易数据，不包含见证数据**（对于隔离见证交易）。这是为了解决交易延展性问题。

### 6. Coinbase交易

每个区块的第一笔交易是特殊的**Coinbase交易**，它没有输入（或者说输入是凭空创造的）。

Coinbase交易的输出包含：
- 区块奖励（目前是6.25 BTC，每21万个区块减半）
- 所有交易的手续费总和

矿工通过Coinbase交易获得收益，这也是新比特币进入流通的唯一方式。

Coinbase交易还有一个特殊字段：**Coinbase数据**，矿工可以在这里写任意信息，最大100字节。著名的例子就是创世区块中中本聪的留言。

---

## 【第三部分：UTXO模型】(2.5分钟，约600字)

### 1. 什么是UTXO？

UTXO全称是**Unspent Transaction Output**，未花费交易输出。

这是理解比特币的关键概念。很多人以为比特币有个"账户"存着你的余额，其实不是！

**比特币没有账户，只有UTXO**。

### 2. UTXO如何工作？

让我用一个例子说明：

假设Alice有10 BTC，实际上是她拥有一个或多个UTXO，总额为10 BTC。比如：
- UTXO1：来自交易A的第2个输出，金额6 BTC
- UTXO2：来自交易B的第0个输出，金额4 BTC

现在Alice要给Bob转账3 BTC，她必须：
1. 选择一个或多个UTXO作为输入（比如UTXO2，4 BTC）
2. 创建两个输出：
   - 输出1：给Bob 3 BTC
   - 输出2：找零给自己0.999 BTC
   - 剩余0.001 BTC作为手续费

注意，UTXO必须**完整花费**。如果你有一个4 BTC的UTXO，想转账3 BTC，你必须把整个4 BTC的UTXO作为输入，然后创建找零输出。

### 3. UTXO集合

所有比特币节点都维护一个**UTXO集合**，记录当前所有未花费的输出。

这个集合就是比特币的"状态"，它告诉我们：
- 哪些输出还没被花费
- 每个输出有多少比特币
- 谁有权花费这些输出

当一笔新交易被确认：
- 输入引用的UTXO从集合中移除（已花费）
- 新创建的输出加入集合（未花费）

UTXO集合的大小影响节点的内存占用。目前UTXO集合大约有8000万个输出，占用约5GB空间。

### 4. UTXO vs 账户模型

为什么比特币用UTXO模型而不是账户模型（像以太坊那样）？

**UTXO模型的优点**：

**1. 并行处理**
- 不同的UTXO可以并行验证
- 没有账户状态的竞争条件

**2. 隐私性更好**
- 每笔交易可以用不同的地址
- 难以追踪用户的总资产

**3. 简单明确**
- 每个输出独立存在
- 要么花费要么不花费，没有中间状态

**4. 双花检测容易**
- 只需检查UTXO是否已花费
- 不需要检查账户余额

**UTXO模型的缺点**：
- 复杂性：用户需要理解找零机制
- 空间占用：需要维护整个UTXO集合
- 碎片化：小额UTXO会累积，占用空间

### 5. 查询余额

那么，如何查询一个地址的余额呢？

你需要：
1. 遍历整个UTXO集合
2. 找出所有属于该地址的UTXO
3. 把它们的金额加起来

这就是为什么比特币节点查询余额比较慢，因为没有现成的"账户表"，必须实时计算。

钱包软件通常会维护自己的UTXO索引，加速余额查询。

---

## 【第四部分：链式存储】(1分钟，约250字)

### 1. 区块链的链式结构

最后让我们看看区块如何连接成链。

每个区块通过**前一区块哈希**字段指向父区块，形成单向链表。

这个设计有三个关键特性：

**1. 不可篡改**
- 改变任何历史区块，它的哈希会变
- 导致所有后续区块的"前一区块哈希"不匹配
- 需要重新挖掘所有后续区块，算力上不可行

**2. 易于验证**
- 从创世区块开始，验证每个区块
- 确保每个"前一区块哈希"都匹配
- 确保每个区块的工作量证明有效

**3. 支持分叉**
- 可能有多个区块指向同一个父区块
- 节点会选择累积工作量最大的链
- 这是解决分布式共识的关键

### 2. 区块高度

从创世区块（高度0）开始，每个区块高度加1。

当前（2025年）比特币区块高度已经超过87万。按每10分钟一个块，平均每年产生约5.26万个区块。

---

## 【总结回顾】(30秒，约150字)

好，让我们快速回顾一下比特币的四大数据结构：

**1. 区块结构**
- 80字节区块头 + 可变长度区块体
- 6个关键字段：版本、前一哈希、Merkle根、时间戳、难度、Nonce

**2. 交易结构**
- 输入：引用之前的UTXO
- 输出：创建新的UTXO
- 通过脚本系统验证

**3. UTXO模型**
- 比特币没有账户概念
- 所有余额都是UTXO的总和
- 支持并行验证和更好的隐私

**4. 链式存储**
- 通过哈希指针连接
- 形成不可篡改的账本

---

## 【结尾互动】(30秒，约120字)

理解了这些数据结构，你就掌握了比特币的"骨架"。下次在区块浏览器上看到一笔交易，你就能看懂每个字段的含义了。

**思考题**：为什么比特币选择UTXO模型而不是账户模型？你觉得哪种更好？欢迎在评论区分享你的观点。

如果这期视频对你有帮助，请点赞、收藏。下期我会讲比特币的共识机制——工作量证明的完整流程。关注我，我们下期见！

---

**视频脚本总字数：约2520字**
**预计语速：220-250字/分钟**
**实际时长：10-11分钟**
