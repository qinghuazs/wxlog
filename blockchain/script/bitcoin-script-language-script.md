---
title: 比特币脚本语言详解 - 视频脚本
date: 2025-01-22
categories:
  - Technology
  - Learning
---

# 比特币脚本语言详解 - 视频脚本

**视频时长:10分钟**
**目标受众:有编程基础的区块链开发者**

---

## 【开场Hook】(30秒,约120字)

大家好!你有没有想过,比特币的"可编程货币"是什么意思?为什么说比特币有脚本语言,却不能像以太坊那样写复杂的智能合约?为什么这门语言故意设计成"不完整"?

很多人只知道比特币能转账,但不了解每笔交易背后都有脚本在执行。这些脚本定义了"谁能花费这笔钱"的规则。今天这期视频,我要带你深入比特币Script语言,看看这门独特的栈式脚本语言是如何工作的。

---

## 【主题介绍】(30秒,约130字)

这期视频我会为你讲解比特币脚本语言的四个核心内容:

- **第一**,语言基础特性,理解为什么是栈式、图灵非完备的设计
- **第二**,核心操作码,看看脚本有哪些基本操作
- **第三**,标准脚本模板,了解P2PKH、P2SH、SegWit等常用脚本
- **第四**,高级应用,探索多签、时间锁、HTLC等实用场景

掌握Script语言,你就能理解比特币的可编程性,甚至能设计自己的智能合约!

---

## 【第一部分:语言基础】(2.5分钟,约600字)

### 1. 什么是Script语言?

比特币Script是一种专门为比特币设计的脚本语言,用于定义交易的花费条件。

**基本特点:**
- **基于栈**:所有操作都在栈上进行
- **图灵非完备**:没有循环,不能写任意程序
- **无状态**:不依赖外部状态
- **确定性**:相同输入总是相同输出

**为什么这样设计?**

**简单安全:**
- 没有循环 → 不会死循环
- 无状态 → 可预测
- 图灵非完备 → 功能受限但安全

**举个例子:**
以太坊的Solidity是图灵完备的,可以写复杂合约,但也容易出bug(比如The DAO事件)。比特币的Script功能有限,但更安全可靠。

### 2. 栈式执行模型

Script语言基于**栈**工作,就像逆波兰表达式。

**栈的基本操作:**

**入栈(Push):**
```
操作: Push 2
栈: [2]

操作: Push 3
栈: [2, 3]
```

**出栈(Pop):**
```
操作: Pop
栈: [2]  (3被弹出)
```

**运算示例:计算2+3**

传统写法:`2 + 3 = 5`
栈式写法:`2 3 ADD`

执行过程:
```
步骤1: Push 2     栈: [2]
步骤2: Push 3     栈: [2, 3]
步骤3: ADD        栈: [5]  (弹出3和2,压入2+3的结果)
```

**为什么用栈?**
- 简单高效
- 容易实现
- 不需要变量名
- 执行顺序清晰

### 3. 脚本执行流程

每笔比特币交易包含两个脚本:

**scriptSig(解锁脚本):**
- 由花费方提供
- 包含签名和公钥
- 证明"我有权花费"

**scriptPubKey(锁定脚本):**
- 由接收方设置
- 定义花费条件
- 类似"只有这个公钥的所有者能花费"

**验证流程:**

```
步骤1: 执行 scriptSig
     → 将数据压入栈

步骤2: 执行 scriptPubKey
     → 继续在同一个栈上操作

步骤3: 检查栈顶
     → 如果栈顶为"真",交易有效
     → 否则,交易无效
```

**举个例子:**

**scriptSig**: `<签名> <公钥>`
**scriptPubKey**: `OP_DUP OP_HASH160 <公钥哈希> OP_EQUALVERIFY OP_CHECKSIG`

执行:
```
1. [签名, 公钥]                    # 执行scriptSig
2. [签名, 公钥, 公钥]              # OP_DUP 复制公钥
3. [签名, 公钥, hash(公钥)]        # OP_HASH160
4. [签名, 公钥, hash(公钥), 期望哈希] # 压入期望哈希
5. [签名, 公钥]                    # OP_EQUALVERIFY 验证相等
6. [true]                          # OP_CHECKSIG 验证签名
```

栈顶为真,交易有效!

### 4. 脚本限制

比特币对脚本有严格限制:

**大小限制:**
- 最大脚本大小:10,000字节
- 最大元素大小:520字节
- 最大栈大小:1,000个元素

**操作限制:**
- 最大操作码数:201个
- 禁用的操作码:OP_CAT、OP_MUL、OP_DIV等

**为什么限制?**
- **防止DoS攻击:**限制资源消耗
- **确保安全:**禁用危险操作
- **保持简单:**避免复杂逻辑

---

## 【第二部分:核心操作码】(2.5分钟,约600字)

### 1. 常量操作码

**OP_0 到 OP_16:**
- 直接压入0到16
- `OP_0`: 压入空字节(false)
- `OP_1`: 压入1(true)

**OP_PUSHDATA:**
- 压入任意数据
- `OP_PUSHDATA1/2/4`: 不同长度的数据

### 2. 栈操作码

**OP_DUP (0x76):**
复制栈顶元素
```
操作前: [A, B]
操作后: [A, B, B]
```

**OP_DROP (0x75):**
删除栈顶元素
```
操作前: [A, B, C]
操作后: [A, B]
```

**OP_SWAP (0x7c):**
交换栈顶两个元素
```
操作前: [A, B, C]
操作后: [A, C, B]
```

**OP_ROT (0x7b):**
旋转栈顶三个元素
```
操作前: [A, B, C, D]
操作后: [A, C, D, B]
```

### 3. 算术操作码

**OP_ADD (0x93):**
相加
```
操作: 2 3 OP_ADD
结果: 5
```

**OP_SUB (0x94):**
相减
```
操作: 5 2 OP_SUB
结果: 3
```

**OP_1ADD (0x8b):**
加1(优化操作)
```
操作: 5 OP_1ADD
结果: 6
```

**注意:**OP_MUL、OP_DIV、OP_MOD都被禁用了!

### 4. 密码学操作码

**OP_SHA256 (0xa8):**
SHA256哈希
```
操作: <data> OP_SHA256
结果: 32字节哈希值
```

**OP_HASH160 (0xa9):**
SHA256 + RIPEMD160
```
操作: <pubkey> OP_HASH160
结果: 20字节公钥哈希
```

**OP_CHECKSIG (0xac):**
验证签名
```
操作: <signature> <pubkey> OP_CHECKSIG
结果: true/false
```

**OP_CHECKMULTISIG (0xae):**
多重签名验证
```
操作: OP_0 <sig1> <sig2> OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG
结果: true (如果2-of-3验证通过)
```

### 5. 流程控制操作码

**OP_IF / OP_ELSE / OP_ENDIF:**
条件分支
```
<condition>
OP_IF
    <true分支>
OP_ELSE
    <false分支>
OP_ENDIF
```

**OP_VERIFY (0x69):**
验证栈顶为真,否则失败
```
操作: <value> OP_VERIFY
如果value为假,脚本失败
```

**OP_RETURN (0x6a):**
标记输出不可花费
```
OP_RETURN <data>
# 常用于存储数据
```

### 6. 时间锁操作码

**OP_CHECKLOCKTIMEVERIFY (0xb1):**
绝对时间锁
```
<锁定时间> OP_CHECKLOCKTIMEVERIFY OP_DROP
# 只有到达指定时间/区块高度才能花费
```

**OP_CHECKSEQUENCEVERIFY (0xb2):**
相对时间锁
```
<相对时间> OP_CHECKSEQUENCEVERIFY OP_DROP
# 相对于UTXO创建时间的延迟
```

---

## 【第三部分:标准脚本模板】(2.5分钟,约600字)

### 1. P2PKH(支付到公钥哈希)

最常见的脚本,地址以"1"开头。

**锁定脚本:**
```
OP_DUP OP_HASH160 <公钥哈希> OP_EQUALVERIFY OP_CHECKSIG
```

**解锁脚本:**
```
<签名> <公钥>
```

**执行流程:**
1. 压入签名和公钥
2. 复制公钥(OP_DUP)
3. 哈希公钥(OP_HASH160)
4. 比较哈希(OP_EQUALVERIFY)
5. 验证签名(OP_CHECKSIG)

**为什么不直接用公钥?**
- 地址更短(20字节 vs 33字节)
- 更安全(抗量子计算)

### 2. P2SH(支付到脚本哈希)

支持复杂脚本,地址以"3"开头。

**锁定脚本:**
```
OP_HASH160 <脚本哈希> OP_EQUAL
```

**解锁脚本:**
```
<数据...> <赎回脚本>
```

**两次验证:**
1. 验证赎回脚本哈希
2. 执行赎回脚本本身

**优势:**
- 支持多签
- 复杂逻辑
- 费用由花费方承担

### 3. P2WPKH(见证公钥哈希)

SegWit原生地址,以"bc1q"开头。

**锁定脚本:**
```
OP_0 <20字节公钥哈希>
```

**见证数据:**
```
<签名> <公钥>
```

**优势:**
- 修复交易延展性
- 减少手续费
- 支持批量验证

### 4. P2WSH(见证脚本哈希)

SegWit脚本,以"bc1q"开头(32字节)。

**锁定脚本:**
```
OP_0 <32字节脚本哈希>
```

**见证数据:**
```
<数据...> <见证脚本>
```

### 5. P2TR(Taproot)

最新的脚本类型,以"bc1p"开头。

**锁定脚本:**
```
OP_1 <32字节输出公钥>
```

**特性:**
- 密钥路径花费(像P2PKH)
- 脚本路径花费(Merkle树)
- 隐私更好(所有输出看起来一样)
- Schnorr签名聚合

---

## 【第四部分:高级应用】(2分钟,约500字)

### 1. 多重签名

**2-of-3多签:**
```
OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG
```

**解锁:**
```
OP_0 <sig1> <sig2>
```

**注意:**OP_0是历史bug,必须保留!

**应用场景:**
- 公司财务:需要两个高管签名
- 托管服务:买家+卖家+仲裁方
- 夫妻账户:双方共同管理

### 2. 哈希时间锁(HTLC)

闪电网络的核心技术!

**脚本:**
```
OP_IF
    OP_SHA256 <秘密哈希> OP_EQUALVERIFY
    <接收方公钥> OP_CHECKSIG
OP_ELSE
    <锁定时间> OP_CHECKLOCKTIMEVERIFY OP_DROP
    <发送方公钥> OP_CHECKSIG
OP_ENDIF
```

**两条路径:**
1. 接收方提供秘密,立即领取
2. 超时后,发送方取回

### 3. 原子交换

跨链交易,要么全成功,要么全失败。

**Alice(比特币) ↔ Bob(莱特币)**

**Alice的HTLC:**
```
秘密哈希H
如果Bob提供R(使得H=hash(R)),Bob得币
超时后Alice取回
```

**Bob的HTLC:**
```
同样的秘密哈希H
如果Alice提供R,Alice得币
超时后Bob取回
```

**流程:**
1. Alice先锁定比特币
2. Bob锁定莱特币
3. Alice提供R领取莱特币(暴露秘密)
4. Bob用R领取比特币

安全!要么都成功,要么都超时退款。

### 4. 遗产继承

**所有者随时可用,继承人一年后可用:**
```
OP_IF
    <所有者公钥> OP_CHECKSIG
OP_ELSE
    <52560> OP_CHECKSEQUENCEVERIFY OP_DROP
    <继承人公钥> OP_CHECKSIG
OP_ENDIF
```

52560块 ≈ 1年(10分钟/块)

### 5. 数据存储

**OP_RETURN:**
```
OP_RETURN <任意数据>
```

**用途:**
- 文档哈希存证
- 协议标记
- NFT元数据

**注意:**OP_RETURN输出不可花费!

---

## 【总结回顾】(30秒,约150字)

让我们回顾比特币Script语言的核心要点:

**1. 语言特性**
- 栈式执行模型
- 图灵非完备设计
- 确定性和无状态

**2. 核心操作码**
- 栈操作:DUP、DROP、SWAP
- 密码学:SHA256、CHECKSIG
- 时间锁:CLTV、CSV

**3. 标准脚本**
- P2PKH:最常用
- P2SH:支持复杂脚本
- SegWit:修复延展性
- Taproot:最新最优

**4. 高级应用**
- 多签、HTLC、原子交换
- 实现强大的智能合约

---

## 【结尾互动】(30秒,约120字)

现在你应该明白,比特币虽然是图灵非完备的,但通过精巧的脚本设计,实现了强大的可编程性。从简单的转账到复杂的闪电网络,都基于Script语言。

**思考题**:为什么比特币选择图灵非完备而不是图灵完备?这个设计哲学对区块链发展有什么启示?欢迎在评论区分享你的看法。

如果这期视频让你对Script语言有了深入理解,请点赞支持。下期我会讲比特币入门基础概念。关注我,我们下期见!

---

**视频脚本总字数:约2500字**
**预计语速:220-250字/分钟**
**实际时长:10-11分钟**
