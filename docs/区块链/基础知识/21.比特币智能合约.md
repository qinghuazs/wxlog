---
title: 比特币智能合约
date: 2025-09-30
categories:
  - Technology
  - Learning
---

# 比特币智能合约

## Bitcoin Script基础

### Script语言特性

比特币Script是一种基于栈的、非图灵完备的脚本语言。

```java
public class BitcoinScript {

    public void scriptCharacteristics() {
        System.out.println("=== Bitcoin Script 特性 ===\n");

        System.out.println("设计特点：");
        System.out.println("✓ 基于栈（Stack-based）");
        System.out.println("✓ 从左到右执行");
        System.out.println("✓ 非图灵完备");
        System.out.println("✓ 无循环");
        System.out.println("✓ 确定性执行");

        System.out.println("\n为何非图灵完备？");
        System.out.println("- 防止无限循环");
        System.out.println("- 避免DoS攻击");
        System.out.println("- 可预测gas费用");
        System.out.println("- 简化验证");
    }

    // Script执行示例
    public void executeScript() {
        System.out.println("\n=== Script 执行示例 ===\n");

        // 脚本：2 3 OP_ADD 5 OP_EQUAL
        Stack<Integer> stack = new Stack<>();

        System.out.println("脚本: 2 3 OP_ADD 5 OP_EQUAL");
        System.out.println("\n执行过程：");

        // 2
        stack.push(2);
        System.out.println("1. 压入 2: " + stack);

        // 3
        stack.push(3);
        System.out.println("2. 压入 3: " + stack);

        // OP_ADD
        int b = stack.pop();
        int a = stack.pop();
        stack.push(a + b);
        System.out.println("3. OP_ADD: " + stack);

        // 5
        stack.push(5);
        System.out.println("4. 压入 5: " + stack);

        // OP_EQUAL
        int y = stack.pop();
        int x = stack.pop();
        stack.push(x == y ? 1 : 0);
        System.out.println("5. OP_EQUAL: " + stack);

        boolean result = stack.pop() == 1;
        System.out.println("\n结果: " + (result ? "✓ 成功" : "✗ 失败"));
    }
}
```

### 常用操作码

```java
public class ScriptOpcodes {

    public void categorizeOpcodes() {
        System.out.println("=== Script 操作码分类 ===\n");

        System.out.println("【常量】");
        System.out.println("OP_0, OP_1, ..., OP_16    推送小整数");
        System.out.println("OP_PUSHDATA1/2/4          推送数据");

        System.out.println("\n【栈操作】");
        System.out.println("OP_DUP                    复制栈顶");
        System.out.println("OP_DROP                   删除栈顶");
        System.out.println("OP_SWAP                   交换栈顶两元素");

        System.out.println("\n【算术】");
        System.out.println("OP_ADD                    加法");
        System.out.println("OP_SUB                    减法");
        System.out.println("OP_MUL                    乘法（禁用）");

        System.out.println("\n【比较】");
        System.out.println("OP_EQUAL                  相等");
        System.out.println("OP_EQUALVERIFY            相等并验证");
        System.out.println("OP_LESSTHAN               小于");

        System.out.println("\n【密码学】");
        System.out.println("OP_HASH160                RIPEMD160(SHA256(x))");
        System.out.println("OP_SHA256                 SHA256");
        System.out.println("OP_CHECKSIG               验证签名");
        System.out.println("OP_CHECKMULTISIG          验证多签");

        System.out.println("\n【时间锁】");
        System.out.println("OP_CHECKLOCKTIMEVERIFY    绝对时间锁");
        System.out.println("OP_CHECKSEQUENCEVERIFY    相对时间锁");
    }
}
```

## 标准交易类型

### P2PKH (Pay-to-PubKey-Hash)

```java
public class P2PKH {

    public void createP2PKH() {
        System.out.println("=== P2PKH 脚本 ===\n");

        // ScriptPubKey (锁定脚本)
        String scriptPubKey =
            "OP_DUP " +
            "OP_HASH160 " +
            "<pubKeyHash> " +
            "OP_EQUALVERIFY " +
            "OP_CHECKSIG";

        System.out.println("ScriptPubKey:");
        System.out.println(scriptPubKey);

        // ScriptSig (解锁脚本)
        String scriptSig =
            "<signature> " +
            "<publicKey>";

        System.out.println("\nScriptSig:");
        System.out.println(scriptSig);

        System.out.println("\n执行流程：");
        demonstrateP2PKH();
    }

    private void demonstrateP2PKH() {
        Stack<String> stack = new Stack<>();

        System.out.println("\n1. 执行 ScriptSig:");
        stack.push("<signature>");
        System.out.println("   压入 <signature>");
        stack.push("<publicKey>");
        System.out.println("   压入 <publicKey>");
        System.out.println("   栈: [<sig>, <pubKey>]");

        System.out.println("\n2. 执行 ScriptPubKey:");

        System.out.println("   OP_DUP");
        String top = stack.peek();
        stack.push(top);
        System.out.println("   栈: [<sig>, <pubKey>, <pubKey>]");

        System.out.println("\n   OP_HASH160");
        String pubKey = stack.pop();
        String pubKeyHash = hash160(pubKey);
        stack.push(pubKeyHash);
        System.out.println("   栈: [<sig>, <pubKey>, <pubKeyHash>]");

        System.out.println("\n   <pubKeyHash>");
        stack.push("<expectedPubKeyHash>");
        System.out.println("   栈: [<sig>, <pubKey>, <pubKeyHash>, <expected>]");

        System.out.println("\n   OP_EQUALVERIFY");
        String expected = stack.pop();
        String actual = stack.pop();
        if (!expected.equals(actual)) {
            System.out.println("   失败：哈希不匹配");
            return;
        }
        System.out.println("   栈: [<sig>, <pubKey>]");

        System.out.println("\n   OP_CHECKSIG");
        String sig = stack.pop();
        String pk = stack.pop();
        boolean valid = verifySignature(sig, pk);
        stack.push(valid ? "1" : "0");
        System.out.println("   栈: [" + (valid ? "1" : "0") + "]");

        System.out.println("\n3. 结果: " + (valid ? "✓ 验证通过" : "✗ 验证失败"));
    }
}
```

### P2SH (Pay-to-Script-Hash)

```java
public class P2SH {

    public void createP2SH() {
        System.out.println("=== P2SH 脚本 ===\n");

        System.out.println("用途：");
        System.out.println("- 隐藏复杂脚本");
        System.out.println("- 接收方定义花费条件");
        System.out.println("- 多签钱包常用");

        // 赎回脚本 (Redeem Script)
        String redeemScript = "2 <pubKey1> <pubKey2> <pubKey3> 3 OP_CHECKMULTISIG";
        System.out.println("\nRedeem Script (2-of-3多签):");
        System.out.println(redeemScript);

        // 计算脚本哈希
        String scriptHash = hash160(redeemScript);
        System.out.println("\nScript Hash:");
        System.out.println(scriptHash);

        // ScriptPubKey
        String scriptPubKey =
            "OP_HASH160 " +
            "<scriptHash> " +
            "OP_EQUAL";

        System.out.println("\nScriptPubKey:");
        System.out.println(scriptPubKey);

        // ScriptSig
        String scriptSig =
            "<sig1> " +
            "<sig2> " +
            "<redeemScript>";

        System.out.println("\nScriptSig:");
        System.out.println(scriptSig);
    }

    public void demonstrateP2SH() {
        System.out.println("\n=== P2SH 执行 ===\n");

        System.out.println("1. 验证脚本哈希:");
        System.out.println("   hash160(<redeemScript>) == <scriptHash>");
        System.out.println("   ✓ 匹配");

        System.out.println("\n2. 执行赎回脚本:");
        System.out.println("   2 <pubKey1> <pubKey2> <pubKey3> 3 OP_CHECKMULTISIG");
        System.out.println("   需要3个公钥中的2个签名");
        System.out.println("   ✓ 验证通过");
    }
}
```

## 高级Script应用

### 时间锁合约

```java
public class TimeLockContracts {

    // 绝对时间锁 (CLTV)
    public void absoluteTimeLock() {
        System.out.println("=== OP_CHECKLOCKTIMEVERIFY (CLTV) ===\n");

        System.out.println("用途：");
        System.out.println("- 在特定时间后才能花费");
        System.out.println("- 遗嘱合约");
        System.out.println("- 托管服务");

        // 脚本示例：2024年1月1日后可花费
        long unlockTime = 1704067200;  // Unix时间戳

        String script =
            "<unlockTime> " +
            "OP_CHECKLOCKTIMEVERIFY " +
            "OP_DROP " +
            "OP_DUP " +
            "OP_HASH160 " +
            "<pubKeyHash> " +
            "OP_EQUALVERIFY " +
            "OP_CHECKSIG";

        System.out.println("\n脚本:");
        System.out.println(script);

        System.out.println("\n执行条件：");
        System.out.println("1. 当前时间 >= " + unlockTime);
        System.out.println("2. 交易nLockTime >= " + unlockTime);
        System.out.println("3. 提供有效签名");
    }

    // 相对时间锁 (CSV)
    public void relativeTimeLock() {
        System.out.println("\n=== OP_CHECKSEQUENCEVERIFY (CSV) ===\n");

        System.out.println("用途：");
        System.out.println("- 从确认后N个区块才能花费");
        System.out.println("- 闪电网络通道");
        System.out.println("- 支付通道");

        // 脚本示例：确认后100个区块
        int blocks = 100;

        String script =
            "<blocks> " +
            "OP_CHECKSEQUENCEVERIFY " +
            "OP_DROP " +
            "OP_DUP " +
            "OP_HASH160 " +
            "<pubKeyHash> " +
            "OP_EQUALVERIFY " +
            "OP_CHECKSIG";

        System.out.println("\n脚本:");
        System.out.println(script);

        System.out.println("\n执行条件：");
        System.out.println("1. 输入UTXO已确认" + blocks + "个区块");
        System.out.println("2. 输入nSequence >= " + blocks);
        System.out.println("3. 提供有效签名");
    }

    // 时间锁应用：遗嘱合约
    public void willContract() {
        System.out.println("\n=== 遗嘱合约示例 ===\n");

        System.out.println("场景：");
        System.out.println("- Alice锁定BTC");
        System.out.println("- 正常情况：Alice可以花费");
        System.out.println("- 1年无活动：继承人Bob可以花费");

        String script =
            "OP_IF " +
            "  <Alice_pubKey> OP_CHECKSIG " +
            "OP_ELSE " +
            "  <1年> OP_CHECKLOCKTIMEVERIFY OP_DROP " +
            "  <Bob_pubKey> OP_CHECKSIG " +
            "OP_ENDIF";

        System.out.println("\n脚本:");
        System.out.println(script);

        System.out.println("\n使用方式：");
        System.out.println("1. Alice定期\"刷新\"（创建新交易）");
        System.out.println("2. 如果Alice 1年未活动");
        System.out.println("3. Bob可以用时间锁分支花费");
    }
}
```

### 哈希时间锁合约 (HTLC)

```java
public class HTLC {

    public void explainHTLC() {
        System.out.println("=== 哈希时间锁合约 (HTLC) ===\n");

        System.out.println("用途：");
        System.out.println("- 闪电网络路由");
        System.out.println("- 原子交换");
        System.out.println("- 跨链互换");

        System.out.println("\n工作原理：");
        System.out.println("1. 接收方生成密钥secret");
        System.out.println("2. 计算哈希 h = hash(secret)");
        System.out.println("3. 发送方锁定资金：");
        System.out.println("   - 条件A: 提供secret");
        System.out.println("   - 条件B: 超时后退款");
    }

    public void htlcScript() {
        System.out.println("\n=== HTLC 脚本 ===\n");

        String script =
            "OP_IF " +
            "  OP_HASH160 <hash> OP_EQUALVERIFY " +
            "  <receiver_pubKey> OP_CHECKSIG " +
            "OP_ELSE " +
            "  <timeout> OP_CHECKLOCKTIMEVERIFY OP_DROP " +
            "  <sender_pubKey> OP_CHECKSIG " +
            "OP_ENDIF";

        System.out.println("脚本:");
        System.out.println(script);

        System.out.println("\n路径1（接收方）：");
        System.out.println("ScriptSig: <receiver_sig> <secret> 1");
        System.out.println("条件：提供正确的secret");

        System.out.println("\n路径2（发送方退款）：");
        System.out.println("ScriptSig: <sender_sig> 0");
        System.out.println("条件：超时后");
    }

    // 原子交换示例
    public void atomicSwap() {
        System.out.println("\n=== 原子交换示例 ===\n");

        System.out.println("场景：Alice和Bob交换BTC <-> LTC");

        System.out.println("\n步骤：");
        System.out.println("1. Alice生成secret");
        String secret = "random_secret_123";
        String hash = sha256(secret);
        System.out.println("   secret: " + secret);
        System.out.println("   hash: " + hash);

        System.out.println("\n2. Alice创建BTC HTLC");
        System.out.println("   锁定: 1 BTC");
        System.out.println("   接收方: Bob");
        System.out.println("   条件: secret或24小时退款");

        System.out.println("\n3. Bob创建LTC HTLC");
        System.out.println("   锁定: 100 LTC");
        System.out.println("   接收方: Alice");
        System.out.println("   条件: secret或12小时退款");

        System.out.println("\n4. Alice公开secret领取LTC");
        System.out.println("   secret暴露！");

        System.out.println("\n5. Bob用secret领取BTC");
        System.out.println("   交换完成！");

        System.out.println("\n结果：");
        System.out.println("✓ 全部成功或全部失败");
        System.out.println("✓ 无需信任第三方");
    }
}
```

### 多签合约

```java
public class MultiSigContracts {

    public void standardMultisig() {
        System.out.println("=== 标准多签 ===\n");

        // 2-of-3多签
        String script =
            "2 " +
            "<pubKey1> " +
            "<pubKey2> " +
            "<pubKey3> " +
            "3 " +
            "OP_CHECKMULTISIG";

        System.out.println("2-of-3 多签脚本:");
        System.out.println(script);

        System.out.println("\nScriptSig:");
        System.out.println("OP_0 <sig1> <sig2>");
        System.out.println("(注：OP_0是因为OP_CHECKMULTISIG的bug)");

        System.out.println("\n应用场景：");
        System.out.println("- 公司账户（需要多个高管签名）");
        System.out.println("- 托管服务（买方+卖方+仲裁方）");
        System.out.println("- 资金安全（分散密钥风险）");
    }

    public void thresholdSignatures() {
        System.out.println("\n=== 门槛签名方案 ===\n");

        System.out.println("常见配置：");

        System.out.println("\n1-of-1: 单签");
        System.out.println("- 个人钱包");

        System.out.println("\n2-of-2: 双签");
        System.out.println("- 联名账户");
        System.out.println("- 合伙企业");

        System.out.println("\n2-of-3: 灵活多签");
        System.out.println("- 公司账户");
        System.out.println("- 托管服务");
        System.out.println("- 容忍1个密钥丢失");

        System.out.println("\n3-of-5: 大型组织");
        System.out.println("- 董事会决策");
        System.out.println("- 高安全要求");
        System.out.println("- 容忍2个密钥丢失");
    }

    // MuSig（Schnorr聚合签名）
    public void muSig() {
        System.out.println("\n=== MuSig (Schnorr聚合) ===\n");

        System.out.println("优势：");
        System.out.println("✓ 多签看起来像单签");
        System.out.println("✓ 隐私增强");
        System.out.println("✓ 空间节省");
        System.out.println("✓ 费用降低");

        System.out.println("\n对比：");
        System.out.println("传统2-of-2:");
        System.out.println("  脚本: 2 <pubKey1> <pubKey2> 2 OP_CHECKMULTISIG");
        System.out.println("  大小: ~100 字节");

        System.out.println("\nMuSig 2-of-2:");
        System.out.println("  脚本: <aggregated_pubKey> OP_CHECKSIG");
        System.out.println("  大小: ~65 字节");
        System.out.println("  节省: 35%");
    }
}
```

## DLC (Discreet Log Contracts)

```java
public class DLC {

    public void explainDLC() {
        System.out.println("=== 离散日志合约 (DLC) ===\n");

        System.out.println("概念：");
        System.out.println("- 基于预言机的合约");
        System.out.println("- 在比特币上实现智能合约");
        System.out.println("- 链下协商，链上结算");

        System.out.println("\n组成：");
        System.out.println("1. 预言机（Oracle）");
        System.out.println("   - 提供外部数据");
        System.out.println("   - 签名特定结果");

        System.out.println("\n2. 合约参与方");
        System.out.println("   - 协商合约条款");
        System.out.println("   - 预签名所有结果");

        System.out.println("\n3. 结算交易");
        System.out.println("   - 根据预言机签名");
        System.out.println("   - 执行对应结果");
    }

    public void dlcExample() {
        System.out.println("\n=== DLC 应用示例 ===\n");

        System.out.println("【场景1：期权合约】");
        System.out.println("Alice和Bob对赌BTC价格");
        System.out.println("- 如果BTC > $50,000: Alice赢");
        System.out.println("- 如果BTC < $50,000: Bob赢");

        System.out.println("\n步骤：");
        System.out.println("1. 双方锁定资金（各1 BTC）");
        System.out.println("2. 预言机承诺签名价格");
        System.out.println("3. 双方预签名所有结果:");
        System.out.println("   - 价格>50k: Alice获得2 BTC");
        System.out.println("   - 价格<50k: Bob获得2 BTC");
        System.out.println("4. 到期时预言机公布价格签名");
        System.out.println("5. 赢家广播对应的预签名交易");

        System.out.println("\n【场景2：保险合约】");
        System.out.println("农民购买天气保险");
        System.out.println("- 降雨量<50mm: 获得赔付");
        System.out.println("- 降雨量≥50mm: 不赔付");

        System.out.println("\n【场景3：稳定币】");
        System.out.println("抵押BTC发行稳定币");
        System.out.println("- 根据价格预言机");
        System.out.println("- 自动清算");
    }

    public void dlcVsHTLC() {
        System.out.println("\n=== DLC vs HTLC ===\n");

        System.out.println("HTLC:");
        System.out.println("- 基于密钥揭示");
        System.out.println("- 无需外部数据");
        System.out.println("- 二元结果");

        System.out.println("\nDLC:");
        System.out.println("- 基于预言机签名");
        System.out.println("- 依赖外部数据");
        System.out.println("- 多种结果");
        System.out.println("- 更灵活");
    }
}
```

## RGB协议

```java
public class RGBProtocol {

    public void explainRGB() {
        System.out.println("=== RGB 协议 ===\n");

        System.out.println("核心思想：");
        System.out.println("- 客户端验证");
        System.out.println("- 链下状态");
        System.out.println("- 比特币承诺");

        System.out.println("\n特点：");
        System.out.println("✓ 不占用区块空间");
        System.out.println("✓ 隐私保护");
        System.out.println("✓ 可扩展");
        System.out.println("✓ 智能合约");
    }

    public void rgbTokens() {
        System.out.println("\n=== RGB 代币发行 ===\n");

        System.out.println("步骤：");
        System.out.println("1. 创建代币定义");
        System.out.println("   - 名称、符号");
        System.out.println("   - 总量、精度");

        System.out.println("\n2. 生成创世UTXO");
        System.out.println("   - 在比特币交易中承诺");
        System.out.println("   - 链下存储状态");

        System.out.println("\n3. 代币转移");
        System.out.println("   - 比特币交易包含承诺");
        System.out.println("   - 链下传递证明");

        System.out.println("\n4. 客户端验证");
        System.out.println("   - 验证完整历史");
        System.out.println("   - 无需全局状态");
    }

    public void rgbVsOmni() {
        System.out.println("\n=== RGB vs Omni/Colored Coins ===\n");

        System.out.println("Omni/Colored Coins:");
        System.out.println("- 链上存储所有数据");
        System.out.println("- 占用区块空间");
        System.out.println("- 全局可见");

        System.out.println("\nRGB:");
        System.out.println("- 链下存储状态");
        System.out.println("- 仅承诺在链上");
        System.out.println("- 隐私保护");
        System.out.println("- 可扩展性更好");
    }
}
```

## Taproot 智能合约

```java
public class TaprootContracts {

    public void taprootScripts() {
        System.out.println("=== Taproot 脚本树 ===\n");

        System.out.println("优势：");
        System.out.println("- 脚本隐私");
        System.out.println("- 灵活组合");
        System.out.println("- 仅暴露执行分支");

        System.out.println("\n示例：多条件钱包");
        System.out.println("密钥路径: 3-of-3聚合密钥（常用）");
        System.out.println("脚本路径1: 2-of-3多签（降级）");
        System.out.println("脚本路径2: 90天后单签（紧急）");
        System.out.println("脚本路径3: 公司CEO + CFO（商业）");

        System.out.println("\n使用：");
        System.out.println("- 正常：密钥路径，隐私最佳");
        System.out.println("- 异常：脚本路径，仅暴露该分支");
        System.out.println("- 外部无法知道其他分支");
    }

    public void taprootExamples() {
        System.out.println("\n=== Taproot 应用示例 ===\n");

        System.out.println("【遗嘱合约】");
        System.out.println("密钥路径: Alice单签");
        System.out.println("脚本1: 1年后Bob继承");
        System.out.println("脚本2: Alice+Bob联合");

        System.out.println("\n【托管合约】");
        System.out.println("密钥路径: 买方+卖方");
        System.out.println("脚本1: 买方+仲裁方");
        System.out.println("脚本2: 卖方+仲裁方");
        System.out.println("脚本3: 14天后卖方退款");

        System.out.println("\n【DAO金库】");
        System.out.println("密钥路径: 所有成员聚合");
        System.out.println("脚本1: 5-of-9理事会");
        System.out.println("脚本2: 30天后任何人+时间锁");
    }
}
```

## 总结

### 核心要点

✅ **Bitcoin Script**
- 基于栈的脚本语言
- 非图灵完备
- 确定性执行
- 适合简单合约

✅ **标准模式**
- P2PKH: 单签
- P2SH: 隐藏脚本
- P2WPKH/P2WSH: SegWit
- P2TR: Taproot

✅ **高级应用**
- 时间锁：CLTV, CSV
- HTLC：原子交换
- DLC：预言机合约
- RGB：客户端验证

✅ **发展方向**
- Taproot脚本树
- Schnorr聚合
- 客户端验证
- Layer 2集成

### 能力边界

**比特币可以：**
- ✓ 多签
- ✓ 时间锁
- ✓ 哈希锁
- ✓ 简单条件逻辑

**比特币不擅长：**
- ✗ 复杂计算
- ✗ 循环
- ✗ 链上存储大量数据
- ✗ 动态状态

**解决方案：**
- Layer 2（闪电网络）
- 侧链（RSK）
- 客户端验证（RGB）

---

**相关文档：**
- [比特币脚本语言详解](./09.比特币脚本语言详解)
- [闪电网络原理详解](./08.闪电网络原理详解)
- [比特币扩展方案](./20.比特币扩展方案)

比特币智能合约虽然简单，但通过巧妙设计可以实现强大功能！🔧