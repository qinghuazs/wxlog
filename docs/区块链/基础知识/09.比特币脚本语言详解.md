---
title: 比特币脚本语言详解
date: 2025-09-29
permalink: /blockchain/bitcoin-script-language.html
categories:
  - Technology
  - Learning
---

# 比特币脚本语言详解

## 前言

比特币脚本（Bitcoin Script）是一种基于栈的、图灵非完备的脚本语言，用于定义比特币交易的花费条件。虽然功能有限，但它为比特币提供了可编程性，使得多签、时间锁等高级功能成为可能。本文将深入解析Script语言的设计原理、操作码详解和实际应用。

## 一、脚本语言基础

### 1.1 语言特性

```python
class ScriptBasics:
    """比特币脚本基础"""
    
    def __init__(self):
        self.features = {
            'stack_based': True,           # 基于栈
            'turing_complete': False,       # 图灵非完备
            'stateless': True,              # 无状态
            'deterministic': True,          # 确定性
            'no_loops': True,               # 无循环
            'max_script_size': 10000,      # 最大脚本大小（字节）
            'max_stack_size': 1000,        # 最大栈大小
            'max_opcodes': 201             # 最大操作码数量
        }
        
        self.stack = []         # 主栈
        self.alt_stack = []     # 备用栈
        self.if_stack = []      # 条件栈
        
    def execute_script(self, script_sig, script_pubkey):
        """执行脚本验证"""
        
        # 1. 执行scriptSig（解锁脚本）
        if not self.execute(script_sig):
            return False
        
        # 2. 复制栈
        stack_copy = self.stack.copy()
        
        # 3. 执行scriptPubKey（锁定脚本）
        if not self.execute(script_pubkey):
            return False
        
        # 4. 检查结果
        if not self.stack:
            return False
        
        # 栈顶元素必须为真
        return self.cast_to_bool(self.stack[-1])
    
    def cast_to_bool(self, value):
        """将值转换为布尔值"""
        if isinstance(value, bytes):
            # 空字节串或全零为假
            if not value or all(b == 0 for b in value):
                return False
        elif isinstance(value, int):
            if value == 0:
                return False
        return True
    
    def execute(self, script):
        """执行脚本"""
        pc = 0  # 程序计数器
        op_count = 0  # 操作码计数
        
        while pc < len(script):
            # 防止脚本过长
            if op_count > self.features['max_opcodes']:
                return False
            
            # 读取操作码
            opcode = script[pc]
            pc += 1
            op_count += 1
            
            # 执行操作码
            if not self.execute_opcode(opcode, script, pc):
                return False
                
        return True
```

### 1.2 栈操作原理

```python
class StackOperations:
    """栈操作"""
    
    def __init__(self):
        self.stack = []
        
    def push(self, item):
        """压栈"""
        if len(self.stack) >= 1000:
            raise Exception("Stack size limit exceeded")
        self.stack.append(item)
    
    def pop(self):
        """弹栈"""
        if not self.stack:
            raise Exception("Stack underflow")
        return self.stack.pop()
    
    def peek(self, index=-1):
        """查看栈元素"""
        if abs(index) > len(self.stack):
            raise Exception("Stack index out of range")
        return self.stack[index]
    
    def demonstrate_stack_execution(self):
        """演示栈执行"""
        
        # 示例：2 + 3 = 5
        script = [
            'OP_2',         # 压入2
            'OP_3',         # 压入3
            'OP_ADD',       # 弹出两个，相加，压入结果
            'OP_5',         # 压入5
            'OP_EQUAL'      # 比较是否相等
        ]
        
        execution_trace = []
        
        for op in script:
            if op == 'OP_2':
                self.push(2)
                execution_trace.append(f"Push 2: stack={self.stack}")
            elif op == 'OP_3':
                self.push(3)
                execution_trace.append(f"Push 3: stack={self.stack}")
            elif op == 'OP_ADD':
                b = self.pop()
                a = self.pop()
                self.push(a + b)
                execution_trace.append(f"Add: stack={self.stack}")
            elif op == 'OP_5':
                self.push(5)
                execution_trace.append(f"Push 5: stack={self.stack}")
            elif op == 'OP_EQUAL':
                b = self.pop()
                a = self.pop()
                self.push(1 if a == b else 0)
                execution_trace.append(f"Equal: stack={self.stack}")
        
        return {
            'script': script,
            'trace': execution_trace,
            'result': bool(self.stack[-1]) if self.stack else False
        }
```

## 二、操作码详解

### 2.1 常量操作码

```python
class ConstantOpcodes:
    """常量操作码"""
    
    def __init__(self):
        self.opcodes = {
            # 推送数据
            0x00: 'OP_0/OP_FALSE',     # 推送空字节串
            0x4c: 'OP_PUSHDATA1',       # 下一字节为长度
            0x4d: 'OP_PUSHDATA2',       # 下两字节为长度
            0x4e: 'OP_PUSHDATA4',       # 下四字节为长度
            0x4f: 'OP_1NEGATE',         # 推送-1
            0x51: 'OP_1/OP_TRUE',       # 推送1
            0x52: 'OP_2',               # 推送2
            # ... 0x53-0x60: OP_3 到 OP_16
            0x60: 'OP_16'               # 推送16
        }
    
    def op_pushdata(self, data):
        """推送数据操作"""
        length = len(data)
        
        if length <= 75:
            # 直接推送（长度作为操作码）
            return bytes([length]) + data
        elif length <= 255:
            # OP_PUSHDATA1
            return bytes([0x4c, length]) + data
        elif length <= 65535:
            # OP_PUSHDATA2
            return bytes([0x4d]) + length.to_bytes(2, 'little') + data
        elif length <= 4294967295:
            # OP_PUSHDATA4
            return bytes([0x4e]) + length.to_bytes(4, 'little') + data
        else:
            raise ValueError("Data too long")
    
    def push_number(self, n):
        """推送数字"""
        if n == -1:
            return bytes([0x4f])  # OP_1NEGATE
        elif n == 0:
            return bytes([0x00])  # OP_0
        elif 1 <= n <= 16:
            return bytes([0x50 + n])  # OP_1 到 OP_16
        else:
            # 推送为字节串
            return self.encode_number(n)
    
    def encode_number(self, n):
        """编码数字为脚本格式"""
        if n == 0:
            return bytes([0])
        
        negative = n < 0
        if negative:
            n = -n
        
        result = []
        while n > 0:
            result.append(n & 0xff)
            n >>= 8
        
        if result[-1] & 0x80:
            result.append(0x80 if negative else 0)
        elif negative:
            result[-1] |= 0x80
        
        return bytes([len(result)]) + bytes(result)
```

### 2.2 栈操作码

```python
class StackOpcodes:
    """栈操作码"""
    
    def __init__(self):
        self.stack = []
        self.alt_stack = []
    
    # 栈操作
    def op_dup(self):
        """OP_DUP (0x76): 复制栈顶元素"""
        if not self.stack:
            return False
        self.stack.append(self.stack[-1])
        return True
    
    def op_2dup(self):
        """OP_2DUP (0x6e): 复制栈顶两个元素"""
        if len(self.stack) < 2:
            return False
        self.stack.extend(self.stack[-2:])
        return True
    
    def op_drop(self):
        """OP_DROP (0x75): 删除栈顶元素"""
        if not self.stack:
            return False
        self.stack.pop()
        return True
    
    def op_swap(self):
        """OP_SWAP (0x7c): 交换栈顶两个元素"""
        if len(self.stack) < 2:
            return False
        self.stack[-1], self.stack[-2] = self.stack[-2], self.stack[-1]
        return True
    
    def op_pick(self):
        """OP_PICK (0x79): 复制第n个元素到栈顶"""
        if len(self.stack) < 2:
            return False
        n = self.pop_as_int()
        if n < 0 or n >= len(self.stack):
            return False
        self.stack.append(self.stack[-n-1])
        return True
    
    def op_roll(self):
        """OP_ROLL (0x7a): 移动第n个元素到栈顶"""
        if len(self.stack) < 2:
            return False
        n = self.pop_as_int()
        if n < 0 or n >= len(self.stack):
            return False
        self.stack.append(self.stack.pop(-n-1))
        return True
    
    def op_rot(self):
        """OP_ROT (0x7b): 旋转栈顶三个元素"""
        if len(self.stack) < 3:
            return False
        self.stack[-3:] = [self.stack[-2], self.stack[-1], self.stack[-3]]
        return True
    
    def op_toaltstack(self):
        """OP_TOALTSTACK (0x6b): 移动到备用栈"""
        if not self.stack:
            return False
        self.alt_stack.append(self.stack.pop())
        return True
    
    def op_fromaltstack(self):
        """OP_FROMALTSTACK (0x6c): 从备用栈移回"""
        if not self.alt_stack:
            return False
        self.stack.append(self.alt_stack.pop())
        return True
    
    def op_depth(self):
        """OP_DEPTH (0x74): 压入栈深度"""
        self.stack.append(len(self.stack))
        return True
```

### 2.3 算术操作码

```python
class ArithmeticOpcodes:
    """算术操作码"""
    
    def op_add(self):
        """OP_ADD (0x93): 相加"""
        if len(self.stack) < 2:
            return False
        b = self.pop_as_int()
        a = self.pop_as_int()
        self.push_int(a + b)
        return True
    
    def op_sub(self):
        """OP_SUB (0x94): 相减"""
        if len(self.stack) < 2:
            return False
        b = self.pop_as_int()
        a = self.pop_as_int()
        self.push_int(a - b)
        return True
    
    def op_mul(self):
        """OP_MUL (0x95): 相乘（已禁用）"""
        return False  # 出于安全考虑被禁用
    
    def op_div(self):
        """OP_DIV (0x96): 相除（已禁用）"""
        return False  # 出于安全考虑被禁用
    
    def op_mod(self):
        """OP_MOD (0x97): 取模（已禁用）"""
        return False  # 出于安全考虑被禁用
    
    def op_1add(self):
        """OP_1ADD (0x8b): 加1"""
        if not self.stack:
            return False
        n = self.pop_as_int()
        self.push_int(n + 1)
        return True
    
    def op_1sub(self):
        """OP_1SUB (0x8c): 减1"""
        if not self.stack:
            return False
        n = self.pop_as_int()
        self.push_int(n - 1)
        return True
    
    def op_negate(self):
        """OP_NEGATE (0x8f): 取负"""
        if not self.stack:
            return False
        n = self.pop_as_int()
        self.push_int(-n)
        return True
    
    def op_abs(self):
        """OP_ABS (0x90): 绝对值"""
        if not self.stack:
            return False
        n = self.pop_as_int()
        self.push_int(abs(n))
        return True
    
    def op_min(self):
        """OP_MIN (0xa3): 最小值"""
        if len(self.stack) < 2:
            return False
        b = self.pop_as_int()
        a = self.pop_as_int()
        self.push_int(min(a, b))
        return True
    
    def op_max(self):
        """OP_MAX (0xa4): 最大值"""
        if len(self.stack) < 2:
            return False
        b = self.pop_as_int()
        a = self.pop_as_int()
        self.push_int(max(a, b))
        return True
    
    def op_within(self):
        """OP_WITHIN (0xa5): 检查是否在范围内"""
        if len(self.stack) < 3:
            return False
        max_val = self.pop_as_int()
        min_val = self.pop_as_int()
        x = self.pop_as_int()
        self.push_bool(min_val <= x < max_val)
        return True
```

### 2.4 密码学操作码

```python
import hashlib

class CryptoOpcodes:
    """密码学操作码"""
    
    def op_ripemd160(self):
        """OP_RIPEMD160 (0xa6): RIPEMD160哈希"""
        if not self.stack:
            return False
        data = self.stack.pop()
        h = hashlib.new('ripemd160')
        h.update(data)
        self.stack.append(h.digest())
        return True
    
    def op_sha1(self):
        """OP_SHA1 (0xa7): SHA1哈希"""
        if not self.stack:
            return False
        data = self.stack.pop()
        self.stack.append(hashlib.sha1(data).digest())
        return True
    
    def op_sha256(self):
        """OP_SHA256 (0xa8): SHA256哈希"""
        if not self.stack:
            return False
        data = self.stack.pop()
        self.stack.append(hashlib.sha256(data).digest())
        return True
    
    def op_hash160(self):
        """OP_HASH160 (0xa9): SHA256后RIPEMD160"""
        if not self.stack:
            return False
        data = self.stack.pop()
        sha256_hash = hashlib.sha256(data).digest()
        h = hashlib.new('ripemd160')
        h.update(sha256_hash)
        self.stack.append(h.digest())
        return True
    
    def op_hash256(self):
        """OP_HASH256 (0xaa): 双SHA256"""
        if not self.stack:
            return False
        data = self.stack.pop()
        hash1 = hashlib.sha256(data).digest()
        hash2 = hashlib.sha256(hash1).digest()
        self.stack.append(hash2)
        return True
    
    def op_checksig(self):
        """OP_CHECKSIG (0xac): 验证签名"""
        if len(self.stack) < 2:
            return False
        
        pubkey = self.stack.pop()
        signature = self.stack.pop()
        
        # 从签名中提取签名哈希类型
        if len(signature) < 1:
            self.push_bool(False)
            return True
        
        sighash_type = signature[-1]
        signature = signature[:-1]
        
        # 创建签名哈希
        sighash = self.create_signature_hash(self.current_tx, 
                                            self.current_input_index,
                                            self.current_script,
                                            sighash_type)
        
        # 验证签名
        valid = self.verify_signature(signature, pubkey, sighash)
        self.push_bool(valid)
        return True
    
    def op_checksigverify(self):
        """OP_CHECKSIGVERIFY (0xad): 验证签名并要求为真"""
        if not self.op_checksig():
            return False
        return self.op_verify()
    
    def op_checkmultisig(self):
        """OP_CHECKMULTISIG (0xae): 多重签名验证"""
        if not self.stack:
            return False
        
        # 获取公钥数量
        n_keys = self.pop_as_int()
        if n_keys < 0 or n_keys > 20:
            return False
        
        # 弹出n个公钥
        pubkeys = []
        for _ in range(n_keys):
            if not self.stack:
                return False
            pubkeys.append(self.stack.pop())
        
        # 获取签名数量
        n_sigs = self.pop_as_int()
        if n_sigs < 0 or n_sigs > n_keys:
            return False
        
        # 弹出m个签名
        signatures = []
        for _ in range(n_sigs):
            if not self.stack:
                return False
            signatures.append(self.stack.pop())
        
        # 弹出一个额外元素（协议bug）
        if not self.stack:
            return False
        self.stack.pop()
        
        # 验证签名
        success = self.verify_multisig(signatures, pubkeys)
        self.push_bool(success)
        return True
    
    def op_checksigadd(self):
        """OP_CHECKSIGADD (0xba): Tapscript签名累加"""
        # BIP 342 - Tapscript
        if len(self.stack) < 3:
            return False
        
        pubkey = self.stack.pop()
        n = self.pop_as_int()
        signature = self.stack.pop()
        
        if signature:
            valid = self.verify_signature(signature, pubkey, self.sighash)
            if valid:
                n += 1
        
        self.push_int(n)
        return True
```

### 2.5 流程控制操作码

```python
class FlowControlOpcodes:
    """流程控制操作码"""
    
    def __init__(self):
        self.if_stack = []  # 条件栈
        
    def op_if(self):
        """OP_IF (0x63): 条件开始"""
        if not self.stack:
            return False
        
        condition = self.pop_as_bool()
        self.if_stack.append(condition)
        return True
    
    def op_notif(self):
        """OP_NOTIF (0x64): 否定条件开始"""
        if not self.stack:
            return False
        
        condition = not self.pop_as_bool()
        self.if_stack.append(condition)
        return True
    
    def op_else(self):
        """OP_ELSE (0x67): 条件分支"""
        if not self.if_stack:
            return False
        
        self.if_stack[-1] = not self.if_stack[-1]
        return True
    
    def op_endif(self):
        """OP_ENDIF (0x68): 条件结束"""
        if not self.if_stack:
            return False
        
        self.if_stack.pop()
        return True
    
    def op_verify(self):
        """OP_VERIFY (0x69): 验证栈顶为真"""
        if not self.stack:
            return False
        
        value = self.stack.pop()
        return self.cast_to_bool(value)
    
    def op_return(self):
        """OP_RETURN (0x6a): 标记交易无效"""
        # OP_RETURN使交易输出不可花费
        # 常用于在区块链上存储数据
        return False
    
    def execute_conditional_script(self):
        """执行条件脚本示例"""
        
        # IF...ELSE...ENDIF示例
        script = """
        <condition>
        OP_IF
            <true_branch>
        OP_ELSE
            <false_branch>
        OP_ENDIF
        """
        
        # 嵌套条件示例
        nested_script = """
        <condition1>
        OP_IF
            <condition2>
            OP_IF
                <both_true>
            OP_ELSE
                <first_true_second_false>
            OP_ENDIF
        OP_ELSE
            <first_false>
        OP_ENDIF
        """
```

### 2.6 时间锁操作码

```python
class TimeLockOpcodes:
    """时间锁操作码"""
    
    def op_checklocktimeverify(self):
        """OP_CHECKLOCKTIMEVERIFY/OP_CLTV (0xb1): 绝对时间锁"""
        if not self.stack:
            return False
        
        locktime = self.peek_as_int()
        
        # 检查交易的nLockTime
        if self.tx_locktime < locktime:
            return False
        
        # 检查序列号
        if self.tx_sequence == 0xffffffff:
            return False
        
        # 比较锁定时间类型（区块高度vs时间戳）
        if (locktime < 500000000 and self.tx_locktime >= 500000000) or \
           (locktime >= 500000000 and self.tx_locktime < 500000000):
            return False
        
        return True
    
    def op_checksequenceverify(self):
        """OP_CHECKSEQUENCEVERIFY/OP_CSV (0xb2): 相对时间锁"""
        if not self.stack:
            return False
        
        sequence = self.peek_as_int()
        
        # 检查是否为负数
        if sequence < 0:
            return False
        
        # 禁用标志检查
        if sequence & (1 << 31):
            return True  # 如果设置了禁用标志，总是通过
        
        # 检查交易版本
        if self.tx_version < 2:
            return False
        
        # 检查输入序列号
        if self.input_sequence & (1 << 31):
            return False
        
        # 比较序列号
        masked_sequence = sequence & 0x0000ffff
        masked_input = self.input_sequence & 0x0000ffff
        
        # 检查时间类型标志
        if (sequence & (1 << 22)) != (self.input_sequence & (1 << 22)):
            return False
        
        if masked_sequence > masked_input:
            return False
        
        return True
    
    def create_timelock_script(self, locktime):
        """创建时间锁脚本"""
        
        # 绝对时间锁（CLTV）
        absolute_timelock = f"""
        <{locktime}>
        OP_CHECKLOCKTIMEVERIFY
        OP_DROP
        <pubkey>
        OP_CHECKSIG
        """
        
        # 相对时间锁（CSV）
        relative_timelock = f"""
        <{locktime}>
        OP_CHECKSEQUENCEVERIFY
        OP_DROP
        <pubkey>
        OP_CHECKSIG
        """
        
        return {
            'absolute': absolute_timelock,
            'relative': relative_timelock
        }
```

## 三、标准脚本模板

### 3.1 P2PK (Pay to Public Key)

```python
class P2PKScript:
    """P2PK脚本"""
    
    def create_p2pk_script(self, pubkey):
        """创建P2PK锁定脚本"""
        # scriptPubKey: <pubkey> OP_CHECKSIG
        script = pubkey + bytes([0xac])  # 0xac = OP_CHECKSIG
        return script
    
    def create_p2pk_unlock(self, signature):
        """创建P2PK解锁脚本"""
        # scriptSig: <signature>
        return self.push_data(signature)
    
    def validate_p2pk(self, scriptSig, scriptPubKey):
        """验证P2PK脚本"""
        # 执行: <signature> <pubkey> OP_CHECKSIG
        stack = []
        
        # 执行scriptSig
        stack.append(self.extract_signature(scriptSig))
        
        # 执行scriptPubKey
        pubkey = scriptPubKey[:-1]  # 移除OP_CHECKSIG
        stack.append(pubkey)
        
        # 执行OP_CHECKSIG
        sig = stack.pop()
        pk = stack.pop()
        
        return self.verify_signature(sig, pk)
```

### 3.2 P2PKH (Pay to Public Key Hash)

```python
class P2PKHScript:
    """P2PKH脚本"""
    
    def create_p2pkh_script(self, pubkey_hash):
        """创建P2PKH锁定脚本"""
        # scriptPubKey: OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG
        script = bytes([
            0x76,  # OP_DUP
            0xa9,  # OP_HASH160
            0x14   # 推送20字节
        ])
        script += pubkey_hash  # 20字节的公钥哈希
        script += bytes([
            0x88,  # OP_EQUALVERIFY
            0xac   # OP_CHECKSIG
        ])
        return script
    
    def create_p2pkh_unlock(self, signature, pubkey):
        """创建P2PKH解锁脚本"""
        # scriptSig: <signature> <pubkey>
        script = self.push_data(signature)
        script += self.push_data(pubkey)
        return script
    
    def validate_p2pkh(self):
        """验证P2PKH脚本执行流程"""
        execution_steps = """
        初始栈: [signature, pubkey]
        
        OP_DUP:         [signature, pubkey, pubkey]
        OP_HASH160:     [signature, pubkey, hash(pubkey)]
        <pubkey_hash>:  [signature, pubkey, hash(pubkey), pubkey_hash]
        OP_EQUALVERIFY: [signature, pubkey] (验证哈希匹配)
        OP_CHECKSIG:    [1] (验证签名)
        """
        return execution_steps
```

### 3.3 P2SH (Pay to Script Hash)

```python
class P2SHScript:
    """P2SH脚本"""
    
    def create_p2sh_script(self, script_hash):
        """创建P2SH锁定脚本"""
        # scriptPubKey: OP_HASH160 <script_hash> OP_EQUAL
        script = bytes([
            0xa9,  # OP_HASH160
            0x14   # 推送20字节
        ])
        script += script_hash  # 20字节的脚本哈希
        script += bytes([0x87])  # OP_EQUAL
        return script
    
    def create_p2sh_unlock(self, signatures, redeem_script):
        """创建P2SH解锁脚本"""
        # scriptSig: <signatures...> <redeem_script>
        script = b''
        for sig in signatures:
            script += self.push_data(sig)
        script += self.push_data(redeem_script)
        return script
    
    def create_multisig_redeem_script(self, m, pubkeys):
        """创建多签赎回脚本"""
        # m <pubkey1> <pubkey2> ... <pubkeyn> n OP_CHECKMULTISIG
        
        if not (1 <= m <= len(pubkeys) <= 15):
            raise ValueError("Invalid multisig parameters")
        
        script = bytes([0x50 + m])  # OP_1 到 OP_16
        
        for pubkey in pubkeys:
            script += self.push_data(pubkey)
        
        script += bytes([0x50 + len(pubkeys)])  # n
        script += bytes([0xae])  # OP_CHECKMULTISIG
        
        return script
    
    def validate_p2sh(self):
        """P2SH验证流程"""
        steps = """
        1. 执行scriptSig，将数据压入栈
        2. 复制栈，保存赎回脚本
        3. 执行scriptPubKey（OP_HASH160 <hash> OP_EQUAL）
        4. 验证赎回脚本哈希匹配
        5. 执行赎回脚本本身
        """
        return steps
```

### 3.4 P2WPKH (Pay to Witness Public Key Hash)

```python
class P2WPKHScript:
    """P2WPKH脚本 (SegWit)"""
    
    def create_p2wpkh_script(self, pubkey_hash):
        """创建P2WPKH锁定脚本"""
        # scriptPubKey: OP_0 <20-byte-pubkey-hash>
        script = bytes([0x00, 0x14])  # OP_0 + 推送20字节
        script += pubkey_hash
        return script
    
    def create_p2wpkh_witness(self, signature, pubkey):
        """创建P2WPKH见证数据"""
        # witness: <signature> <pubkey>
        witness = [signature, pubkey]
        return witness
    
    def validate_p2wpkh(self, witness, pubkey_hash):
        """验证P2WPKH"""
        if len(witness) != 2:
            return False
        
        signature = witness[0]
        pubkey = witness[1]
        
        # 验证公钥哈希
        computed_hash = self.hash160(pubkey)
        if computed_hash != pubkey_hash:
            return False
        
        # 验证签名
        return self.verify_signature(signature, pubkey)
```

### 3.5 P2WSH (Pay to Witness Script Hash)

```python
class P2WSHScript:
    """P2WSH脚本 (SegWit)"""
    
    def create_p2wsh_script(self, script_hash):
        """创建P2WSH锁定脚本"""
        # scriptPubKey: OP_0 <32-byte-script-hash>
        script = bytes([0x00, 0x20])  # OP_0 + 推送32字节
        script += script_hash  # SHA256哈希
        return script
    
    def create_p2wsh_witness(self, items, witness_script):
        """创建P2WSH见证数据"""
        # witness: <items...> <witness_script>
        witness = items + [witness_script]
        return witness
    
    def create_witness_multisig_script(self, m, pubkeys):
        """创建见证多签脚本"""
        # 与P2SH多签相同，但在见证数据中
        return self.create_multisig_redeem_script(m, pubkeys)
```

### 3.6 P2TR (Pay to Taproot)

```python
class P2TRScript:
    """P2TR脚本 (Taproot)"""
    
    def create_p2tr_script(self, output_pubkey):
        """创建P2TR锁定脚本"""
        # scriptPubKey: OP_1 <32-byte-output-pubkey>
        script = bytes([0x51, 0x20])  # OP_1 + 推送32字节
        script += output_pubkey  # 32字节的输出公钥
        return script
    
    def create_taproot_output(self, internal_pubkey, script_tree=None):
        """创建Taproot输出"""
        if script_tree is None:
            # 密钥路径花费
            tweak = self.tagged_hash("TapTweak", internal_pubkey)
        else:
            # 脚本路径花费
            merkle_root = self.compute_taproot_merkle_root(script_tree)
            tweak = self.tagged_hash("TapTweak", internal_pubkey + merkle_root)
        
        # 计算输出公钥
        output_pubkey = self.point_add(internal_pubkey, self.point_mul(tweak))
        
        return output_pubkey
    
    def create_tapscript(self):
        """创建Tapscript"""
        # Tapscript支持更多操作码
        tapscript = """
        <pubkey>
        OP_CHECKSIGADD  # 新操作码
        <threshold>
        OP_NUMEQUAL
        """
        return tapscript
```

## 四、高级脚本应用

### 4.1 原子交换脚本

```python
class AtomicSwapScript:
    """原子交换脚本"""
    
    def create_htlc_script(self, recipient_pubkey_hash, refund_pubkey_hash, 
                          secret_hash, locktime):
        """创建哈希时间锁定合约"""
        
        script = """
        OP_IF
            # 接收方路径：提供秘密
            OP_SHA256
            <secret_hash>
            OP_EQUALVERIFY
            OP_DUP
            OP_HASH160
            <recipient_pubkey_hash>
        OP_ELSE
            # 退款路径：超时后
            <locktime>
            OP_CHECKLOCKTIMEVERIFY
            OP_DROP
            OP_DUP
            OP_HASH160
            <refund_pubkey_hash>
        OP_ENDIF
        OP_EQUALVERIFY
        OP_CHECKSIG
        """
        
        # 编译为字节码
        compiled = bytes([0x63])  # OP_IF
        
        # 接收方路径
        compiled += bytes([0xa8])  # OP_SHA256
        compiled += self.push_data(secret_hash)
        compiled += bytes([0x88])  # OP_EQUALVERIFY
        compiled += bytes([0x76])  # OP_DUP
        compiled += bytes([0xa9])  # OP_HASH160
        compiled += self.push_data(recipient_pubkey_hash)
        
        compiled += bytes([0x67])  # OP_ELSE
        
        # 退款路径
        compiled += self.push_number(locktime)
        compiled += bytes([0xb1])  # OP_CHECKLOCKTIMEVERIFY
        compiled += bytes([0x75])  # OP_DROP
        compiled += bytes([0x76])  # OP_DUP
        compiled += bytes([0xa9])  # OP_HASH160
        compiled += self.push_data(refund_pubkey_hash)
        
        compiled += bytes([0x68])  # OP_ENDIF
        compiled += bytes([0x88])  # OP_EQUALVERIFY
        compiled += bytes([0xac])  # OP_CHECKSIG
        
        return compiled
```

### 4.2 托管脚本

```python
class EscrowScript:
    """托管脚本"""
    
    def create_2of3_escrow(self, buyer_pubkey, seller_pubkey, escrow_pubkey):
        """创建2-of-3托管脚本"""
        
        # 2-of-3多签
        script = bytes([0x52])  # OP_2
        script += self.push_data(buyer_pubkey)
        script += self.push_data(seller_pubkey)
        script += self.push_data(escrow_pubkey)
        script += bytes([0x53])  # OP_3
        script += bytes([0xae])  # OP_CHECKMULTISIG
        
        return script
    
    def create_escrow_with_timeout(self, parties, timeout):
        """创建带超时的托管脚本"""
        
        script = f"""
        OP_IF
            # 正常路径：2-of-3多签
            OP_2
            <buyer_pubkey>
            <seller_pubkey>
            <arbiter_pubkey>
            OP_3
            OP_CHECKMULTISIG
        OP_ELSE
            # 超时路径：买家可退款
            <timeout>
            OP_CHECKLOCKTIMEVERIFY
            OP_DROP
            <buyer_pubkey>
            OP_CHECKSIG
        OP_ENDIF
        """
        
        return self.compile_script(script)
```

### 4.3 遗产继承脚本

```python
class InheritanceScript:
    """遗产继承脚本"""
    
    def create_inheritance_script(self, owner_pubkey, heir_pubkey, 
                                 inactivity_period):
        """创建遗产继承脚本
        
        所有者可以随时花费
        继承人在不活跃期后可以花费
        """
        
        script = f"""
        OP_IF
            # 所有者路径
            <owner_pubkey>
            OP_CHECKSIG
        OP_ELSE
            # 继承人路径（相对时间锁）
            <{inactivity_period}>
            OP_CHECKSEQUENCEVERIFY
            OP_DROP
            <heir_pubkey>
            OP_CHECKSIG
        OP_ENDIF
        """
        
        compiled = bytes([0x63])  # OP_IF
        compiled += self.push_data(owner_pubkey)
        compiled += bytes([0xac])  # OP_CHECKSIG
        compiled += bytes([0x67])  # OP_ELSE
        compiled += self.push_number(inactivity_period)
        compiled += bytes([0xb2])  # OP_CHECKSEQUENCEVERIFY
        compiled += bytes([0x75])  # OP_DROP
        compiled += self.push_data(heir_pubkey)
        compiled += bytes([0xac])  # OP_CHECKSIG
        compiled += bytes([0x68])  # OP_ENDIF
        
        return compiled
```

### 4.4 数据存储脚本

```python
class DataStorageScript:
    """数据存储脚本"""
    
    def create_op_return_script(self, data):
        """创建OP_RETURN脚本存储数据"""
        
        if len(data) > 80:
            raise ValueError("Data too large for OP_RETURN")
        
        # OP_RETURN <data>
        script = bytes([0x6a])  # OP_RETURN
        script += self.push_data(data)
        
        return script
    
    def create_proof_of_existence(self, document_hash):
        """创建存在性证明"""
        
        # 使用OP_RETURN存储文档哈希
        prefix = b'DOCPROOF'  # 协议标识
        
        script = bytes([0x6a])  # OP_RETURN
        script += self.push_data(prefix + document_hash)
        
        return script
    
    def parse_op_return_data(self, script):
        """解析OP_RETURN数据"""
        
        if script[0] != 0x6a:
            raise ValueError("Not an OP_RETURN script")
        
        # 跳过OP_RETURN
        data_start = 1
        
        # 读取数据长度
        if script[data_start] <= 75:
            length = script[data_start]
            data = script[data_start + 1 : data_start + 1 + length]
        else:
            # 处理OP_PUSHDATA
            # ...
            pass
        
        return data
```

## 五、脚本安全与限制

### 5.1 安全机制

```python
class ScriptSecurity:
    """脚本安全机制"""
    
    def __init__(self):
        self.disabled_opcodes = [
            0x7e,  # OP_CAT
            0x7f,  # OP_SUBSTR
            0x80,  # OP_LEFT
            0x81,  # OP_RIGHT
            0x83,  # OP_INVERT
            0x84,  # OP_AND
            0x85,  # OP_OR
            0x86,  # OP_XOR
            0x8d,  # OP_2MUL
            0x8e,  # OP_2DIV
            0x95,  # OP_MUL
            0x96,  # OP_DIV
            0x97,  # OP_MOD
            0x98,  # OP_LSHIFT
            0x99,  # OP_RSHIFT
        ]
        
        self.limits = {
            'max_script_size': 10000,      # 最大脚本大小
            'max_script_element': 520,     # 最大元素大小
            'max_stack_size': 1000,        # 最大栈大小
            'max_ops_per_script': 201,     # 最大操作数
            'max_pubkeys_per_multisig': 20,  # 多签最大公钥数
            'max_script_number_length': 4,   # 最大数字长度
            'max_sig_checks': 3000         # 最大签名检查数
        }
    
    def validate_script(self, script):
        """验证脚本安全性"""
        
        # 检查脚本大小
        if len(script) > self.limits['max_script_size']:
            return False, "Script too large"
        
        # 检查禁用的操作码
        for byte in script:
            if byte in self.disabled_opcodes:
                return False, f"Disabled opcode: {hex(byte)}"
        
        # 统计操作码数量
        op_count = self.count_opcodes(script)
        if op_count > self.limits['max_ops_per_script']:
            return False, "Too many opcodes"
        
        # 模拟执行检查栈大小
        if not self.check_stack_limits(script):
            return False, "Stack size limit exceeded"
        
        return True, "Script valid"
```

### 5.2 脚本分析工具

```python
class ScriptAnalyzer:
    """脚本分析工具"""
    
    def decompile_script(self, script_bytes):
        """反编译脚本为可读格式"""
        
        opcodes = []
        pc = 0
        
        while pc < len(script_bytes):
            opcode = script_bytes[pc]
            
            # 数据推送
            if 1 <= opcode <= 75:
                data = script_bytes[pc + 1 : pc + 1 + opcode]
                opcodes.append(f"PUSH[{opcode}] {data.hex()}")
                pc += 1 + opcode
                
            # 操作码
            else:
                opcode_name = self.get_opcode_name(opcode)
                opcodes.append(opcode_name)
                pc += 1
        
        return opcodes
    
    def analyze_script_type(self, script):
        """分析脚本类型"""
        
        # P2PKH
        if (len(script) == 25 and
            script[0] == 0x76 and  # OP_DUP
            script[1] == 0xa9 and  # OP_HASH160
            script[2] == 0x14 and  # 20字节
            script[23] == 0x88 and  # OP_EQUALVERIFY
            script[24] == 0xac):    # OP_CHECKSIG
            return 'P2PKH'
        
        # P2SH
        if (len(script) == 23 and
            script[0] == 0xa9 and  # OP_HASH160
            script[1] == 0x14 and  # 20字节
            script[22] == 0x87):    # OP_EQUAL
            return 'P2SH'
        
        # P2WPKH
        if len(script) == 22 and script[0] == 0x00 and script[1] == 0x14:
            return 'P2WPKH'
        
        # P2WSH
        if len(script) == 34 and script[0] == 0x00 and script[1] == 0x20:
            return 'P2WSH'
        
        # P2TR
        if len(script) == 34 and script[0] == 0x51 and script[1] == 0x20:
            return 'P2TR'
        
        return 'Non-standard'
    
    def estimate_script_cost(self, script):
        """估算脚本执行成本"""
        
        cost = {
            'sig_ops': 0,
            'weight': len(script) * 4,
            'complexity': 'low'
        }
        
        # 统计签名操作
        for i, byte in enumerate(script):
            if byte == 0xac:  # OP_CHECKSIG
                cost['sig_ops'] += 1
            elif byte == 0xae:  # OP_CHECKMULTISIG
                # 获取n值
                if i > 0 and 0x51 <= script[i-1] <= 0x60:
                    n = script[i-1] - 0x50
                    cost['sig_ops'] += n
        
        # 评估复杂度
        if cost['sig_ops'] > 3:
            cost['complexity'] = 'high'
        elif cost['sig_ops'] > 1:
            cost['complexity'] = 'medium'
        
        return cost
```

## 六、脚本优化技巧

### 6.1 Gas优化

```python
class ScriptOptimization:
    """脚本优化"""
    
    def optimize_multisig(self, m, pubkeys):
        """优化多签脚本"""
        
        # 使用Schnorr签名聚合（Taproot）
        if len(pubkeys) > 3:
            # 对于大型多签，使用Taproot
            return self.create_taproot_multisig(m, pubkeys)
        else:
            # 小型多签使用传统方式
            return self.create_traditional_multisig(m, pubkeys)
    
    def minimize_script_size(self, script):
        """最小化脚本大小"""
        
        optimizations = []
        
        # 使用OP_1到OP_16代替推送小数字
        script = self.replace_small_numbers(script)
        
        # 合并重复操作
        script = self.merge_duplicate_ops(script)
        
        # 使用更短的哈希（如果安全）
        # P2WPKH比P2PKH短
        
        return script
    
    def batch_validation(self, scripts):
        """批量验证优化"""
        
        # 批量验证签名（BIP 340）
        signatures = []
        pubkeys = []
        messages = []
        
        for script in scripts:
            sig, pk, msg = self.extract_sig_data(script)
            signatures.append(sig)
            pubkeys.append(pk)
            messages.append(msg)
        
        # 批量验证
        return self.batch_verify_signatures(signatures, pubkeys, messages)
```

## 总结

比特币脚本语言虽然简单，但提供了强大的可编程性：

**核心特性：**
1. **栈基础**：所有操作基于栈
2. **图灵非完备**：无循环，确保可预测性
3. **确定性**：相同输入总是产生相同输出
4. **无状态**：脚本执行不依赖外部状态

**关键创新：**
- **多重签名**：实现共同控制
- **时间锁**：创建时间条件
- **哈希锁**：实现原子交换
- **见证分离**：提高效率和灵活性

**安全考虑：**
- 严格的大小和执行限制
- 禁用危险操作码
- 签名验证防止伪造
- 确定性执行防止攻击

**未来发展：**
- Taproot带来更多隐私和效率
- Schnorr签名支持签名聚合
- 可能的操作码软分叉升级

比特币脚本语言的设计体现了"简单即安全"的理念，通过有限但精心设计的功能集，实现了安全可靠的可编程货币。

---

*"Bitcoin's scripting language is intentionally not Turing-complete, with no loops."* - Satoshi Nakamoto

理解Script语言是深入理解比特币工作原理的关键。
