---
title: 闪电网络原理详解
date: 2025-09-29
permalink: /blockchain/lightning-network-explained.html
categories:
  - Technology
  - Learning
---

# 闪电网络原理详解

## 前言

闪电网络（Lightning Network）是比特币的第二层扩容解决方案，通过在链下建立支付通道网络，实现即时、低成本的微支付。本文将深入探讨闪电网络的技术原理、协议细节和实现机制。

## 一、闪电网络概述

### 1.1 核心概念

```python
import hashlib
import time
import secrets
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

class LightningConcepts:
    """闪电网络核心概念"""
    
    @dataclass
    class PaymentChannel:
        """支付通道"""
        alice_pubkey: str
        bob_pubkey: str
        funding_tx: str
        capacity: int  # 聪
        alice_balance: int
        bob_balance: int
        commitment_number: int = 0
        is_open: bool = True
        
        def validate_balance(self):
            """验证余额"""
            return self.alice_balance + self.bob_balance == self.capacity
    
    @dataclass
    class HTLC:
        """哈希时间锁定合约"""
        amount: int
        payment_hash: str
        timeout: int  # 区块高度
        preimage: Optional[str] = None
        
        def verify_preimage(self, preimage: str) -> bool:
            """验证原像"""
            hash_value = hashlib.sha256(preimage.encode()).hexdigest()
            return hash_value == self.payment_hash
    
    class NetworkTopology:
        """网络拓扑"""
        def __init__(self):
            self.nodes = {}  # 节点
            self.channels = {}  # 通道
            self.routing_table = {}  # 路由表
            
        def add_channel(self, node1: str, node2: str, capacity: int):
            """添加通道"""
            channel_id = f"{node1}:{node2}"
            self.channels[channel_id] = {
                'nodes': (node1, node2),
                'capacity': capacity,
                'base_fee': 1000,  # 毫聪
                'fee_rate': 1,  # 百万分之一
                'disabled': False
            }
```

### 1.2 设计目标

```python
class DesignGoals:
    """闪电网络设计目标"""
    
    def __init__(self):
        self.goals = {
            'instant_payments': {
                'description': '即时支付',
                'latency': '< 1 second',
                'confirmation': 'No blockchain confirmation needed'
            },
            'micropayments': {
                'description': '微支付',
                'minimum': '1 satoshi',
                'fee': 'Sub-satoshi fees possible'
            },
            'scalability': {
                'description': '可扩展性',
                'tps': 'Millions of transactions per second',
                'limit': 'Only limited by bandwidth and latency'
            },
            'privacy': {
                'description': '隐私性',
                'onion_routing': 'Tor-like privacy',
                'off_chain': 'Transactions not on blockchain'
            },
            'cross_chain': {
                'description': '跨链原子交换',
                'atomic_swaps': 'Trustless cross-chain payments'
            }
        }
    
    def compare_with_onchain(self):
        """与链上交易对比"""
        comparison = {
            'Feature': ['On-chain', 'Lightning'],
            'Confirmation Time': ['10-60 min', '< 1 sec'],
            'Transaction Fee': ['$0.5-50', '$0.001-0.01'],
            'Throughput': ['7 TPS', '1M+ TPS'],
            'Minimum Payment': ['~546 sats', '1 sat'],
            'Privacy': ['Pseudonymous', 'Onion routed'],
            'Finality': ['Probabilistic', 'Instant']
        }
        return comparison
```

## 二、支付通道机制

### 2.1 通道生命周期

```python
class ChannelLifecycle:
    """通道生命周期管理"""
    
    def __init__(self):
        self.state = 'INIT'
        
    def open_channel(self, alice_key, bob_key, funding_amount):
        """开启通道"""
        
        # 1. 创建2-of-2多签地址
        funding_script = self.create_funding_script(alice_key, bob_key)
        funding_address = self.script_to_address(funding_script)
        
        # 2. 构建注资交易
        funding_tx = {
            'inputs': [],  # Alice的UTXO
            'outputs': [{
                'address': funding_address,
                'amount': funding_amount,
                'script': funding_script
            }],
            'locktime': 0
        }
        
        # 3. 创建初始承诺交易
        commitment_tx_alice = self.create_commitment_tx(
            funding_tx['outputs'][0],
            alice_key,
            bob_key,
            funding_amount,
            0,  # Bob初始余额为0
            0   # 承诺编号
        )
        
        commitment_tx_bob = self.create_commitment_tx(
            funding_tx['outputs'][0],
            bob_key,
            alice_key,
            0,  # Alice从Bob视角的余额
            funding_amount,
            0
        )
        
        # 4. 交换签名
        alice_sig_for_bob = self.sign_commitment(commitment_tx_bob, alice_key)
        bob_sig_for_alice = self.sign_commitment(commitment_tx_alice, bob_key)
        
        # 5. 广播注资交易
        self.broadcast_transaction(funding_tx)
        
        self.state = 'OPEN'
        
        return {
            'funding_tx': funding_tx,
            'funding_address': funding_address,
            'channel_id': self.derive_channel_id(funding_tx)
        }
    
    def create_commitment_tx(self, funding_output, local_key, remote_key, 
                            local_balance, remote_balance, commitment_num):
        """创建承诺交易"""
        
        # 撤销密钥
        revocation_key = self.derive_revocation_key(local_key, commitment_num)
        
        commitment_tx = {
            'version': 2,
            'inputs': [{
                'txid': funding_output['txid'],
                'vout': funding_output['vout'],
                'script': '',  # 稍后填充
                'sequence': 0x80000000 | commitment_num
            }],
            'outputs': [],
            'locktime': 0
        }
        
        # 本地输出（带延迟）
        if local_balance > 0:
            local_script = self.create_delayed_output_script(
                local_key,
                revocation_key,
                144  # 1天延迟
            )
            commitment_tx['outputs'].append({
                'amount': local_balance,
                'script': local_script
            })
        
        # 远程输出（立即可花费）
        if remote_balance > 0:
            remote_script = self.create_p2wpkh_script(remote_key)
            commitment_tx['outputs'].append({
                'amount': remote_balance,
                'script': remote_script
            })
        
        return commitment_tx
    
    def update_channel(self, channel, payment_amount, direction):
        """更新通道状态"""
        
        # 1. 更新余额
        if direction == 'alice_to_bob':
            new_alice_balance = channel.alice_balance - payment_amount
            new_bob_balance = channel.bob_balance + payment_amount
        else:
            new_alice_balance = channel.alice_balance + payment_amount
            new_bob_balance = channel.bob_balance - payment_amount
        
        # 2. 创建新承诺交易
        new_commitment_num = channel.commitment_number + 1
        
        new_commitment_alice = self.create_commitment_tx(
            channel.funding_output,
            channel.alice_key,
            channel.bob_key,
            new_alice_balance,
            new_bob_balance,
            new_commitment_num
        )
        
        # 3. 交换撤销密钥
        old_revocation_alice = self.reveal_revocation_key(
            channel.alice_key,
            channel.commitment_number
        )
        
        # 4. 交换新承诺交易签名
        # ...
        
        # 5. 更新通道状态
        channel.alice_balance = new_alice_balance
        channel.bob_balance = new_bob_balance
        channel.commitment_number = new_commitment_num
        
        return channel
    
    def close_channel(self, channel, cooperative=True):
        """关闭通道"""
        
        if cooperative:
            # 协作关闭
            closing_tx = {
                'inputs': [{
                    'txid': channel.funding_tx,
                    'vout': 0
                }],
                'outputs': [
                    {
                        'address': channel.alice_address,
                        'amount': channel.alice_balance
                    },
                    {
                        'address': channel.bob_address,
                        'amount': channel.bob_balance
                    }
                ]
            }
            
            # 双方签名
            alice_sig = self.sign_transaction(closing_tx, channel.alice_key)
            bob_sig = self.sign_transaction(closing_tx, channel.bob_key)
            
            # 广播交易
            self.broadcast_transaction(closing_tx)
            
        else:
            # 单方面关闭
            # 广播最新的承诺交易
            self.broadcast_transaction(channel.latest_commitment_tx)
            
            # 等待延迟期后领取资金
            # ...
        
        self.state = 'CLOSED'
```

### 2.2 承诺交易机制

```python
class CommitmentTransaction:
    """承诺交易机制"""
    
    def __init__(self):
        self.csv_delay = 144  # 相对时间锁（区块数）
        
    def create_delayed_output_script(self, local_pubkey, revocation_pubkey, delay):
        """创建延迟输出脚本"""
        
        # OP_IF
        #     # 撤销路径
        #     <revocation_pubkey>
        # OP_ELSE
        #     # 延迟路径
        #     <delay>
        #     OP_CHECKSEQUENCEVERIFY
        #     OP_DROP
        #     <local_pubkey>
        # OP_ENDIF
        # OP_CHECKSIG
        
        script = (
            "OP_IF\n"
            f"    {revocation_pubkey}\n"
            "OP_ELSE\n"
            f"    {delay}\n"
            "    OP_CHECKSEQUENCEVERIFY\n"
            "    OP_DROP\n"
            f"    {local_pubkey}\n"
            "OP_ENDIF\n"
            "OP_CHECKSIG"
        )
        
        return script
    
    def revocation_mechanism(self):
        """撤销机制"""
        
        class RevocationKey:
            """撤销密钥管理"""
            
            def __init__(self):
                self.revocation_base_point = self.generate_base_point()
                self.per_commitment_point = {}
                
            def generate_base_point(self):
                """生成基点"""
                private_key = secrets.token_bytes(32)
                # 椭圆曲线点乘
                public_key = self.privkey_to_pubkey(private_key)
                return public_key
            
            def derive_per_commitment_point(self, commitment_number):
                """派生每个承诺的点"""
                # 使用承诺编号派生
                data = self.revocation_base_point + commitment_number.to_bytes(8, 'big')
                per_commitment_secret = hashlib.sha256(data).digest()
                per_commitment_point = self.privkey_to_pubkey(per_commitment_secret)
                
                self.per_commitment_point[commitment_number] = per_commitment_point
                return per_commitment_point
            
            def reveal_per_commitment_secret(self, commitment_number):
                """揭示每个承诺的秘密"""
                # 只在承诺被撤销时揭示
                data = self.revocation_base_point + commitment_number.to_bytes(8, 'big')
                return hashlib.sha256(data).digest()
        
        return RevocationKey()
    
    def punishment_transaction(self, revoked_commitment_tx, revocation_secret):
        """惩罚交易"""
        
        # 如果对方广播了已撤销的承诺交易
        # 可以使用撤销密钥立即花费所有资金
        
        punishment_tx = {
            'inputs': [{
                'txid': revoked_commitment_tx['txid'],
                'vout': 0,  # 对方的延迟输出
                'witness': [
                    revocation_secret,
                    '1'  # 选择IF分支
                ]
            }],
            'outputs': [{
                'address': self.justice_address,
                'amount': revoked_commitment_tx['outputs'][0]['amount']
            }]
        }
        
        return punishment_tx
```

### 2.3 HTLC实现

```python
class HTLCImplementation:
    """哈希时间锁定合约实现"""
    
    def __init__(self):
        self.htlc_timeout = 144  # 默认超时区块数
        
    def create_htlc_script(self, payment_hash, recipient_pubkey, 
                          sender_pubkey, timeout):
        """创建HTLC脚本
        
        接收方路径：提供原像
        发送方路径：超时后退款
        """
        
        script = f"""
        OP_IF
            # 接收方路径（揭示原像）
            OP_SHA256
            <{payment_hash}>
            OP_EQUALVERIFY
            <{recipient_pubkey}>
            OP_CHECKSIG
        OP_ELSE
            # 发送方路径（超时）
            <{timeout}>
            OP_CHECKLOCKTIMEVERIFY
            OP_DROP
            <{sender_pubkey}>
            OP_CHECKSIG
        OP_ENDIF
        """
        
        return script
    
    def add_htlc_to_channel(self, channel, htlc):
        """向通道添加HTLC"""
        
        # 1. 创建HTLC输出
        htlc_output = {
            'amount': htlc.amount,
            'script': self.create_htlc_script(
                htlc.payment_hash,
                channel.recipient_pubkey,
                channel.sender_pubkey,
                htlc.timeout
            ),
            'htlc_id': htlc.id
        }
        
        # 2. 更新承诺交易
        new_commitment = channel.latest_commitment.copy()
        
        # 减少发送方余额
        sender_output = next(o for o in new_commitment['outputs'] 
                           if o['type'] == 'sender')
        sender_output['amount'] -= htlc.amount
        
        # 添加HTLC输出
        new_commitment['outputs'].append(htlc_output)
        
        # 3. 交换签名
        # ...
        
        return new_commitment
    
    def settle_htlc(self, channel, htlc_id, preimage):
        """结算HTLC"""
        
        # 1. 验证原像
        htlc = channel.pending_htlcs[htlc_id]
        if not htlc.verify_preimage(preimage):
            raise ValueError("Invalid preimage")
        
        # 2. 创建新承诺交易
        new_commitment = channel.latest_commitment.copy()
        
        # 移除HTLC输出
        htlc_output = next(o for o in new_commitment['outputs'] 
                         if o.get('htlc_id') == htlc_id)
        new_commitment['outputs'].remove(htlc_output)
        
        # 增加接收方余额
        recipient_output = next(o for o in new_commitment['outputs'] 
                              if o['type'] == 'recipient')
        recipient_output['amount'] += htlc.amount
        
        # 3. 更新通道状态
        del channel.pending_htlcs[htlc_id]
        channel.settled_htlcs[htlc_id] = {
            'preimage': preimage,
            'settled_at': time.time()
        }
        
        return new_commitment
    
    def timeout_htlc(self, channel, htlc_id):
        """HTLC超时"""
        
        htlc = channel.pending_htlcs[htlc_id]
        current_height = self.get_block_height()
        
        if current_height < htlc.timeout:
            raise ValueError("HTLC not yet timed out")
        
        # 创建新承诺交易，退还HTLC金额给发送方
        new_commitment = channel.latest_commitment.copy()
        
        # 移除HTLC输出
        htlc_output = next(o for o in new_commitment['outputs'] 
                         if o.get('htlc_id') == htlc_id)
        new_commitment['outputs'].remove(htlc_output)
        
        # 增加发送方余额
        sender_output = next(o for o in new_commitment['outputs'] 
                           if o['type'] == 'sender')
        sender_output['amount'] += htlc.amount
        
        return new_commitment
```

## 三、路由协议

### 3.1 路由发现

```python
class RoutingProtocol:
    """路由协议"""
    
    def __init__(self):
        self.routing_table = {}
        self.channel_graph = {}
        
    def gossip_protocol(self):
        """Gossip协议"""
        
        class ChannelAnnouncement:
            """通道公告"""
            def __init__(self, channel_id, node1, node2, capacity):
                self.channel_id = channel_id
                self.node1 = node1
                self.node2 = node2
                self.capacity = capacity
                self.signatures = []
                
            def validate(self):
                """验证公告"""
                # 1. 验证通道存在于区块链上
                funding_tx = self.verify_funding_transaction()
                
                # 2. 验证双方签名
                if len(self.signatures) != 2:
                    return False
                
                # 3. 验证节点身份
                return self.verify_node_signatures()
        
        class ChannelUpdate:
            """通道更新"""
            def __init__(self, channel_id, timestamp, fee_base, fee_rate):
                self.channel_id = channel_id
                self.timestamp = timestamp
                self.fee_base = fee_base  # 基础费用
                self.fee_rate = fee_rate  # 费率
                self.htlc_minimum = 1
                self.htlc_maximum = None
                
            def apply_update(self, routing_table):
                """应用更新"""
                if self.channel_id in routing_table:
                    channel = routing_table[self.channel_id]
                    if self.timestamp > channel['last_update']:
                        channel['fee_base'] = self.fee_base
                        channel['fee_rate'] = self.fee_rate
                        channel['last_update'] = self.timestamp
        
        class NodeAnnouncement:
            """节点公告"""
            def __init__(self, node_id, alias, addresses):
                self.node_id = node_id
                self.alias = alias
                self.addresses = addresses  # IP地址列表
                self.features = []  # 支持的特性
    
    def build_channel_graph(self):
        """构建通道图"""
        
        class ChannelGraph:
            """通道图数据结构"""
            
            def __init__(self):
                self.nodes = {}
                self.edges = {}  # 通道
                
            def add_channel(self, announcement):
                """添加通道"""
                # 添加节点
                if announcement.node1 not in self.nodes:
                    self.nodes[announcement.node1] = {
                        'channels': [],
                        'capacity': 0
                    }
                if announcement.node2 not in self.nodes:
                    self.nodes[announcement.node2] = {
                        'channels': [],
                        'capacity': 0
                    }
                
                # 添加边（双向）
                edge_id = announcement.channel_id
                self.edges[edge_id] = {
                    'node1': announcement.node1,
                    'node2': announcement.node2,
                    'capacity': announcement.capacity,
                    'fee_base_1_to_2': 1000,
                    'fee_rate_1_to_2': 1,
                    'fee_base_2_to_1': 1000,
                    'fee_rate_2_to_1': 1
                }
                
                # 更新节点信息
                self.nodes[announcement.node1]['channels'].append(edge_id)
                self.nodes[announcement.node2]['channels'].append(edge_id)
                self.nodes[announcement.node1]['capacity'] += announcement.capacity
                self.nodes[announcement.node2]['capacity'] += announcement.capacity
            
            def find_path(self, source, destination, amount):
                """寻找路径（Dijkstra算法）"""
                import heapq
                
                # 初始化
                distances = {node: float('inf') for node in self.nodes}
                distances[source] = 0
                previous = {}
                pq = [(0, source, amount)]
                
                while pq:
                    current_fee, current_node, remaining_amount = heapq.heappop(pq)
                    
                    if current_node == destination:
                        # 重建路径
                        path = []
                        while current_node in previous:
                            prev_node, channel_id = previous[current_node]
                            path.append({
                                'channel': channel_id,
                                'node': current_node
                            })
                            current_node = prev_node
                        return list(reversed(path))
                    
                    if current_fee > distances[current_node]:
                        continue
                    
                    # 检查所有邻居
                    for channel_id in self.nodes[current_node]['channels']:
                        edge = self.edges[channel_id]
                        
                        # 确定邻居节点
                        if edge['node1'] == current_node:
                            neighbor = edge['node2']
                            fee_base = edge['fee_base_1_to_2']
                            fee_rate = edge['fee_rate_1_to_2']
                        else:
                            neighbor = edge['node1']
                            fee_base = edge['fee_base_2_to_1']
                            fee_rate = edge['fee_rate_2_to_1']
                        
                        # 计算费用
                        fee = fee_base + (remaining_amount * fee_rate // 1000000)
                        total_fee = current_fee + fee
                        
                        # 检查容量
                        if remaining_amount + fee > edge['capacity']:
                            continue
                        
                        # 更新最短路径
                        if total_fee < distances[neighbor]:
                            distances[neighbor] = total_fee
                            previous[neighbor] = (current_node, channel_id)
                            heapq.heappush(pq, (total_fee, neighbor, remaining_amount + fee))
                
                return None  # 无路径
        
        return ChannelGraph()
```

### 3.2 洋葱路由

```python
class OnionRouting:
    """洋葱路由实现"""
    
    def __init__(self):
        self.max_hops = 20
        self.packet_size = 1366  # 字节
        
    def create_onion_packet(self, path, payment_hash, amount):
        """创建洋葱数据包"""
        
        # 每一跳的载荷
        hop_payloads = []
        cumulative_fee = 0
        cumulative_cltv = 0
        
        # 反向构建（从目的地开始）
        for i in range(len(path) - 1, -1, -1):
            hop = path[i]
            
            if i == len(path) - 1:
                # 最终接收者
                hop_payload = {
                    'amount': amount,
                    'payment_hash': payment_hash,
                    'cltv_expiry': self.get_block_height() + 144,
                    'next_hop': None
                }
            else:
                # 中间节点
                next_hop = path[i + 1]
                hop_fee = self.calculate_hop_fee(hop, next_hop, amount + cumulative_fee)
                cumulative_fee += hop_fee
                
                hop_payload = {
                    'amount': amount + cumulative_fee,
                    'payment_hash': payment_hash,
                    'cltv_expiry': self.get_block_height() + 144 + cumulative_cltv,
                    'next_hop': next_hop['channel']
                }
                
                cumulative_cltv += 10  # 每跳增加10个区块
            
            hop_payloads.insert(0, hop_payload)
        
        # 构建洋葱层
        onion = self.build_onion_layers(hop_payloads, path)
        
        return onion
    
    def build_onion_layers(self, payloads, path):
        """构建洋葱层"""
        
        # 使用共享秘密加密每一层
        onion_packet = b'\x00' * self.packet_size
        
        # 从最后一跳开始，逐层加密
        for i in range(len(path) - 1, -1, -1):
            hop = path[i]
            payload = payloads[i]
            
            # 生成共享秘密（ECDH）
            ephemeral_key = self.generate_ephemeral_key()
            shared_secret = self.ecdh(ephemeral_key, hop['node_pubkey'])
            
            # 派生加密密钥
            rho = self.derive_key(shared_secret, b'rho')  # 加密密钥
            mu = self.derive_key(shared_secret, b'mu')   # MAC密钥
            
            # 序列化载荷
            serialized_payload = self.serialize_hop_payload(payload)
            
            # 移位和异或
            onion_packet = self.shift_and_xor(onion_packet, serialized_payload, rho)
            
            # 计算MAC
            mac = self.compute_mac(onion_packet, mu)
            
            # 添加MAC
            onion_packet = mac + onion_packet[32:]
        
        return {
            'version': 0,
            'public_key': ephemeral_key,
            'hop_payloads': onion_packet,
            'hmac': mac
        }
    
    def process_onion_packet(self, onion_packet, node_secret):
        """处理洋葱数据包"""
        
        # 1. 使用节点私钥和临时公钥计算共享秘密
        shared_secret = self.ecdh(node_secret, onion_packet['public_key'])
        
        # 2. 派生密钥
        rho = self.derive_key(shared_secret, b'rho')
        mu = self.derive_key(shared_secret, b'mu')
        
        # 3. 验证MAC
        expected_mac = self.compute_mac(onion_packet['hop_payloads'], mu)
        if expected_mac != onion_packet['hmac']:
            raise ValueError("Invalid MAC")
        
        # 4. 解密载荷
        decrypted = self.decrypt_layer(onion_packet['hop_payloads'], rho)
        
        # 5. 解析载荷
        hop_payload = self.parse_hop_payload(decrypted)
        
        # 6. 剥离当前层，准备下一跳
        if hop_payload['next_hop']:
            # 生成下一跳的临时密钥
            next_ephemeral = self.blind_ephemeral_key(
                onion_packet['public_key'],
                shared_secret
            )
            
            # 移位数据包
            next_packet = self.shift_packet(decrypted)
            
            return {
                'forward': True,
                'next_hop': hop_payload['next_hop'],
                'next_packet': {
                    'public_key': next_ephemeral,
                    'hop_payloads': next_packet
                },
                'amount': hop_payload['amount'],
                'cltv_expiry': hop_payload['cltv_expiry']
            }
        else:
            # 最终目的地
            return {
                'forward': False,
                'payment_hash': hop_payload['payment_hash'],
                'amount': hop_payload['amount']
            }
```

## 四、原子多路径支付（AMP）

### 4.1 支付分片

```python
class AtomicMultipathPayment:
    """原子多路径支付"""
    
    def __init__(self):
        self.payment_splits = []
        
    def split_payment(self, amount, available_paths):
        """分割支付"""
        
        # 使用最大流算法
        class MaxFlowSolver:
            """最大流求解器"""
            
            def ford_fulkerson(self, graph, source, sink, amount):
                """Ford-Fulkerson算法"""
                flow = {}
                total_flow = 0
                
                while total_flow < amount:
                    # 寻找增广路径
                    path = self.find_augmenting_path(
                        graph, source, sink, flow
                    )
                    
                    if not path:
                        break
                    
                    # 计算路径流量
                    path_flow = min(
                        amount - total_flow,
                        min(edge['capacity'] - flow.get(edge['id'], 0) 
                            for edge in path)
                    )
                    
                    # 更新流量
                    for edge in path:
                        flow[edge['id']] = flow.get(edge['id'], 0) + path_flow
                    
                    total_flow += path_flow
                
                return flow, total_flow
        
        solver = MaxFlowSolver()
        flow, total = solver.ford_fulkerson(
            self.channel_graph,
            self.source_node,
            self.destination_node,
            amount
        )
        
        # 将流转换为支付路径
        payment_paths = self.flow_to_payment_paths(flow)
        
        return payment_paths
    
    def create_amp_invoice(self, amount, description):
        """创建AMP发票"""
        
        # 生成支付秘密
        payment_secret = secrets.token_bytes(32)
        
        # 为每个分片生成子秘密
        num_splits = 3  # 假设分成3份
        split_secrets = []
        
        for i in range(num_splits):
            # 使用XOR确保原子性
            split_secret = secrets.token_bytes(32)
            split_secrets.append(split_secret)
        
        # 主秘密是所有子秘密的XOR
        main_secret = split_secrets[0]
        for secret in split_secrets[1:]:
            main_secret = bytes(a ^ b for a, b in zip(main_secret, secret))
        
        invoice = {
            'amount': amount,
            'description': description,
            'payment_hash': hashlib.sha256(main_secret).hexdigest(),
            'split_info': {
                'num_splits': num_splits,
                'split_amounts': [amount // num_splits] * num_splits
            },
            'timestamp': int(time.time()),
            'expiry': 3600  # 1小时
        }
        
        return invoice, split_secrets
    
    def send_amp_payment(self, invoice, paths):
        """发送AMP支付"""
        
        splits = []
        
        for i, path in enumerate(paths):
            split_amount = invoice['split_amounts'][i]
            split_secret = self.split_secrets[i]
            
            # 创建分片HTLC
            htlc = {
                'amount': split_amount,
                'payment_hash': hashlib.sha256(split_secret).digest(),
                'cltv_expiry': self.get_block_height() + 144,
                'amp_data': {
                    'payment_id': invoice['payment_id'],
                    'split_index': i,
                    'total_splits': len(paths)
                }
            }
            
            # 发送分片
            result = self.send_htlc_along_path(htlc, path)
            splits.append(result)
        
        # 等待所有分片完成
        return self.wait_for_splits(splits)
```

### 4.2 支付原子性保证

```python
class PaymentAtomicity:
    """支付原子性保证"""
    
    def __init__(self):
        self.pending_payments = {}
        
    def ensure_atomicity(self, payment_id, splits):
        """确保原子性"""
        
        class AtomicPaymentCoordinator:
            """原子支付协调器"""
            
            def __init__(self, payment_id):
                self.payment_id = payment_id
                self.splits = []
                self.state = 'PENDING'
                
            def add_split(self, split):
                """添加分片"""
                self.splits.append({
                    'split_id': split['id'],
                    'amount': split['amount'],
                    'path': split['path'],
                    'htlc': split['htlc'],
                    'status': 'PENDING'
                })
            
            def check_completion(self):
                """检查完成状态"""
                completed = [s for s in self.splits if s['status'] == 'COMPLETED']
                failed = [s for s in self.splits if s['status'] == 'FAILED']
                
                if len(completed) == len(self.splits):
                    # 所有分片成功
                    self.state = 'SUCCESS'
                    self.reveal_preimages()
                elif failed:
                    # 有分片失败
                    self.state = 'FAILED'
                    self.cancel_pending_splits()
            
            def reveal_preimages(self):
                """揭示原像（原子提交）"""
                for split in self.splits:
                    # 揭示每个分片的原像
                    self.reveal_split_preimage(split)
            
            def cancel_pending_splits(self):
                """取消待处理分片（原子回滚）"""
                for split in self.splits:
                    if split['status'] == 'PENDING':
                        self.cancel_htlc(split['htlc'])
        
        coordinator = AtomicPaymentCoordinator(payment_id)
        
        for split in splits:
            coordinator.add_split(split)
        
        # 监控支付状态
        while coordinator.state == 'PENDING':
            coordinator.check_completion()
            time.sleep(0.1)
        
        return coordinator.state == 'SUCCESS'
```

## 五、瞭望塔服务

### 5.1 瞭望塔协议

```python
class WatchtowerProtocol:
    """瞭望塔协议"""
    
    def __init__(self):
        self.watched_channels = {}
        self.breach_remedies = {}
        
    def register_channel(self, channel_id, client_pubkey):
        """注册通道监控"""
        
        # 客户端提供加密的惩罚交易
        registration = {
            'channel_id': channel_id,
            'client_pubkey': client_pubkey,
            'start_height': self.get_block_height(),
            'appointments': []  # 预约列表
        }
        
        self.watched_channels[channel_id] = registration
        
        return {
            'tower_pubkey': self.tower_pubkey,
            'registration_token': self.generate_token(channel_id)
        }
    
    def create_appointment(self, channel_id, commitment_tx, penalty_tx):
        """创建监控预约"""
        
        # 计算违约交易的标识符
        breach_txid = self.get_txid(commitment_tx)
        breach_hint = breach_txid[:16]  # 前16字节作为提示
        
        # 加密惩罚交易
        encryption_key = self.derive_encryption_key(breach_txid)
        encrypted_penalty = self.encrypt(penalty_tx, encryption_key)
        
        appointment = {
            'breach_hint': breach_hint,
            'encrypted_blob': encrypted_penalty,
            'reward_address': self.tower_reward_address,
            'reward_amount': 1000  # 聪
        }
        
        # 客户端签名
        appointment['signature'] = self.sign_appointment(appointment)
        
        return appointment
    
    def watch_for_breaches(self):
        """监控违约行为"""
        
        while True:
            # 获取新区块
            new_block = self.get_latest_block()
            
            for tx in new_block['transactions']:
                tx_hint = self.get_txid(tx)[:16]
                
                # 检查是否匹配任何预约
                for channel_id, registration in self.watched_channels.items():
                    for appointment in registration['appointments']:
                        if appointment['breach_hint'] == tx_hint:
                            # 发现违约！
                            self.handle_breach(tx, appointment)
            
            time.sleep(10)  # 等待下一个区块
    
    def handle_breach(self, breach_tx, appointment):
        """处理违约"""
        
        # 1. 解密惩罚交易
        breach_txid = self.get_txid(breach_tx)
        encryption_key = self.derive_encryption_key(breach_txid)
        penalty_tx = self.decrypt(appointment['encrypted_blob'], encryption_key)
        
        # 2. 验证惩罚交易
        if not self.validate_penalty_tx(penalty_tx, breach_tx):
            print("Invalid penalty transaction")
            return
        
        # 3. 广播惩罚交易
        self.broadcast_transaction(penalty_tx)
        
        # 4. 领取奖励
        self.claim_reward(appointment['reward_address'], appointment['reward_amount'])
        
        print(f"Breach remedied! Penalty tx broadcast: {self.get_txid(penalty_tx)}")
```

### 5.2 隐私保护瞭望塔

```python
class PrivacyWatchtower:
    """隐私保护瞭望塔"""
    
    def __init__(self):
        self.shachain = Shachain()
        
    class Shachain:
        """Shachain - 紧凑的撤销密钥存储"""
        
        def __init__(self):
            self.max_index = 2**48 - 1
            self.known_hashes = {}
            
        def derive_secret(self, seed, index):
            """派生秘密"""
            secret = seed
            for i in range(48):
                if index & (1 << i):
                    secret = hashlib.sha256(secret + b'1').digest()
                else:
                    secret = hashlib.sha256(secret + b'0').digest()
            return secret
        
        def can_derive(self, from_index, to_index):
            """检查是否可以派生"""
            # 只能从高索引派生到低索引
            return from_index > to_index and \
                   (from_index ^ to_index) == (1 << (from_index.bit_length() - 1))
        
        def store_secret(self, index, secret):
            """存储秘密"""
            # 只存储必要的秘密
            # 可以派生其他秘密
            self.known_hashes[index] = secret
            
            # 移除可以派生的秘密
            to_remove = []
            for idx in self.known_hashes:
                if idx != index and self.can_derive(index, idx):
                    to_remove.append(idx)
            
            for idx in to_remove:
                del self.known_hashes[idx]
    
    def create_encrypted_blob(self, penalty_tx, commitment_point):
        """创建加密数据块"""
        
        # 使用承诺点派生加密密钥
        encryption_key = hashlib.sha256(commitment_point).digest()
        
        # 序列化惩罚交易
        serialized_tx = self.serialize_transaction(penalty_tx)
        
        # 添加填充（固定大小）
        padded_tx = serialized_tx + b'\x00' * (1024 - len(serialized_tx))
        
        # ChaCha20加密
        from Crypto.Cipher import ChaCha20
        cipher = ChaCha20.new(key=encryption_key)
        encrypted = cipher.encrypt(padded_tx)
        
        return encrypted, cipher.nonce
```

## 六、高级特性

### 6.1 通道工厂

```python
class ChannelFactory:
    """通道工厂 - 多方通道"""
    
    def __init__(self, participants):
        self.participants = participants
        self.factory_utxo = None
        self.allocation_tx = None
        self.channels = []
        
    def create_factory(self, contributions):
        """创建通道工厂"""
        
        # 1. 创建多方多签地址
        n = len(self.participants)
        factory_script = self.create_n_of_n_multisig(
            [p['pubkey'] for p in self.participants]
        )
        
        # 2. 各方贡献资金
        factory_funding_tx = {
            'inputs': [],  # 各方的UTXO
            'outputs': [{
                'script': factory_script,
                'amount': sum(contributions.values())
            }]
        }
        
        # 3. 创建分配交易
        self.allocation_tx = self.create_allocation_tx(contributions)
        
        # 4. 交换签名
        signatures = self.collect_signatures(self.allocation_tx)
        
        # 5. 广播工厂创建交易
        self.factory_utxo = self.broadcast_transaction(factory_funding_tx)
        
        return self.factory_utxo
    
    def open_channel_in_factory(self, party1, party2, capacity):
        """在工厂内开通道"""
        
        # 1. 创建新的分配交易
        new_allocation = self.allocation_tx.copy()
        
        # 2. 减少双方在分配交易中的余额
        party1_output = next(o for o in new_allocation['outputs'] 
                           if o['address'] == party1['address'])
        party2_output = next(o for o in new_allocation['outputs'] 
                           if o['address'] == party2['address'])
        
        party1_contribution = capacity // 2
        party2_contribution = capacity - party1_contribution
        
        party1_output['amount'] -= party1_contribution
        party2_output['amount'] -= party2_contribution
        
        # 3. 添加通道输出
        channel_script = self.create_2_of_2_multisig(
            party1['pubkey'],
            party2['pubkey']
        )
        
        new_allocation['outputs'].append({
            'script': channel_script,
            'amount': capacity
        })
        
        # 4. 所有参与方签名新分配
        signatures = self.collect_all_signatures(new_allocation)
        
        # 5. 更新分配交易
        self.allocation_tx = new_allocation
        
        # 通道立即可用，无需链上交易
        channel = {
            'party1': party1,
            'party2': party2,
            'capacity': capacity,
            'factory': self.factory_utxo
        }
        
        self.channels.append(channel)
        return channel
```

### 6.2 潜水艇交换

```python
class SubmarineSwap:
    """潜水艇交换 - 链上链下原子交换"""
    
    def __init__(self):
        self.swap_timeout = 144  # 区块
        
    def create_submarine_swap(self, amount, direction='chain_to_ln'):
        """创建潜水艇交换"""
        
        # 生成交换秘密
        preimage = secrets.token_bytes(32)
        payment_hash = hashlib.sha256(preimage).digest()
        
        if direction == 'chain_to_ln':
            # 链上到闪电网络
            
            # 1. 创建链上HTLC
            onchain_htlc = {
                'script': self.create_htlc_script(
                    payment_hash,
                    self.receiver_pubkey,
                    self.sender_pubkey,
                    self.swap_timeout
                ),
                'amount': amount
            }
            
            # 2. 创建闪电网络发票
            ln_invoice = self.create_lightning_invoice(
                amount - self.swap_fee,
                payment_hash
            )
            
            # 3. 等待链上确认
            # 4. 通过闪电网络支付
            # 5. 使用原像赎回链上资金
            
        else:
            # 闪电网络到链上
            
            # 1. 接收闪电网络支付（带有HTLC）
            ln_payment = self.receive_lightning_payment(
                amount,
                payment_hash
            )
            
            # 2. 创建链上交易
            onchain_tx = self.create_onchain_payment(
                self.receiver_address,
                amount - self.swap_fee
            )
            
            # 3. 广播链上交易
            # 4. 揭示原像以接收闪电支付
        
        return {
            'swap_id': self.generate_swap_id(),
            'payment_hash': payment_hash.hex(),
            'timeout': self.swap_timeout,
            'fee': self.swap_fee
        }
```

### 6.3 跨链原子交换

```python
class CrossChainAtomicSwap:
    """跨链原子交换"""
    
    def __init__(self):
        self.supported_chains = ['BTC', 'LTC']
        
    def create_cross_chain_swap(self, chain1, chain2, amount1, amount2):
        """创建跨链交换"""
        
        # 生成共同秘密
        preimage = secrets.token_bytes(32)
        payment_hash = hashlib.sha256(preimage).digest()
        
        # 在两条链上创建HTLC
        htlc1 = self.create_chain_htlc(
            chain1,
            amount1,
            payment_hash,
            timeout=288  # 2天
        )
        
        htlc2 = self.create_chain_htlc(
            chain2,
            amount2,
            payment_hash,
            timeout=144  # 1天，比第一个短
        )
        
        swap_contract = {
            'chain1': {
                'chain': chain1,
                'htlc': htlc1,
                'amount': amount1
            },
            'chain2': {
                'chain': chain2,
                'htlc': htlc2,
                'amount': amount2
            },
            'payment_hash': payment_hash.hex(),
            'status': 'pending'
        }
        
        return swap_contract
```

## 七、性能优化

### 7.1 支付批处理

```python
class PaymentBatching:
    """支付批处理"""
    
    def __init__(self):
        self.payment_queue = []
        self.batch_interval = 1.0  # 秒
        
    def add_payment_to_batch(self, payment):
        """添加支付到批次"""
        self.payment_queue.append({
            'destination': payment['destination'],
            'amount': payment['amount'],
            'payment_hash': payment['payment_hash'],
            'added_at': time.time()
        })
    
    def process_batch(self):
        """处理批次支付"""
        
        if not self.payment_queue:
            return
        
        # 按目的地分组
        payments_by_dest = {}
        for payment in self.payment_queue:
            dest = payment['destination']
            if dest not in payments_by_dest:
                payments_by_dest[dest] = []
            payments_by_dest[dest].append(payment)
        
        # 合并相同目的地的支付
        batch_results = []
        
        for dest, payments in payments_by_dest.items():
            # 使用单个HTLC发送多笔支付
            total_amount = sum(p['amount'] for p in payments)
            
            # 创建批次HTLC
            batch_htlc = self.create_batch_htlc(
                dest,
                total_amount,
                payments
            )
            
            result = self.send_htlc(batch_htlc)
            batch_results.append(result)
        
        # 清空队列
        self.payment_queue = []
        
        return batch_results
```

### 7.2 通道再平衡

```python
class ChannelRebalancing:
    """通道再平衡"""
    
    def __init__(self):
        self.rebalance_threshold = 0.2  # 20%不平衡触发
        
    def check_channel_balance(self, channel):
        """检查通道平衡"""
        total = channel['capacity']
        local = channel['local_balance']
        remote = channel['remote_balance']
        
        local_ratio = local / total
        
        if local_ratio < self.rebalance_threshold:
            return 'need_inbound'
        elif local_ratio > (1 - self.rebalance_threshold):
            return 'need_outbound'
        else:
            return 'balanced'
    
    def circular_rebalance(self, channel):
        """循环再平衡"""
        
        # 寻找循环路径
        cycle_path = self.find_cycle_including_channel(channel)
        
        if not cycle_path:
            return False
        
        # 计算再平衡金额
        rebalance_amount = channel['capacity'] // 2 - channel['local_balance']
        
        # 创建自付款
        self_payment = {
            'source': self.node_id,
            'destination': self.node_id,
            'amount': abs(rebalance_amount),
            'path': cycle_path
        }
        
        # 发送支付
        result = self.send_payment(self_payment)
        
        return result['success']
```

## 总结

闪电网络通过以下核心技术实现了比特币的扩容：

1. **支付通道**：双方锁定资金，链下更新状态
2. **HTLC**：实现条件支付和多跳路由
3. **洋葱路由**：保护支付隐私
4. **原子性**：确保支付要么全部成功要么全部失败
5. **瞭望塔**：防止恶意关闭通道

关键创新：
- **即时确认**：支付在秒级完成
- **极低费用**：可以实现亚聪级费用
- **高吞吐量**：理论上无限扩展
- **隐私保护**：支付不记录在区块链上

技术挑战：
- **流动性管理**：需要预先锁定资金
- **路由效率**：寻找最优路径
- **通道平衡**：保持通道双向可用
- **在线要求**：需要保持在线接收支付

闪电网络代表了区块链扩容的重要方向，通过Layer 2解决方案在不牺牲去中心化的前提下实现了高性能支付。

---

*"The Lightning Network is Bitcoin's TCP/IP stack."* - Elizabeth Stark

闪电网络让比特币从数字黄金进化为真正的点对点电子现金系统。
