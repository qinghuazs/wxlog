---
title: 比特币钱包技术实现
date: 2025-09-29
permalink: /blockchain/bitcoin-wallet-implementation.html
categories:
  - Technology
  - Learning
---

# 比特币钱包技术实现

## 前言

比特币钱包是管理私钥、生成地址、创建和签名交易的核心工具。本文将深入探讨钱包的技术实现，包括HD钱包（分层确定性钱包）、多签钱包、硬件钱包等各种类型的实现原理和安全机制。

## 一、钱包基础架构

### 1.1 钱包类型概述

```python
import os
import hashlib
import hmac
import struct
import base58
import bip32utils
from mnemonic import Mnemonic
from ecdsa import SigningKey, SECP256k1
import binascii

class WalletTypes:
    """钱包类型定义"""
    
    class NonDeterministicWallet:
        """非确定性钱包（随机钱包）"""
        def __init__(self):
            self.private_keys = []
            self.key_pool_size = 100
            
        def generate_random_key(self):
            """生成随机私钥"""
            # 生成32字节随机数
            private_key_bytes = os.urandom(32)
            
            # 确保在有效范围内
            n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
            private_key_int = int.from_bytes(private_key_bytes, 'big')
            
            if private_key_int >= n:
                return self.generate_random_key()  # 重新生成
            
            return private_key_bytes.hex()
        
        def fill_key_pool(self):
            """填充密钥池"""
            while len(self.private_keys) < self.key_pool_size:
                key = self.generate_random_key()
                self.private_keys.append(key)
    
    class DeterministicWallet:
        """确定性钱包"""
        def __init__(self, seed):
            self.seed = seed
            self.master_key = self.generate_master_key(seed)
            
        def generate_master_key(self, seed):
            """从种子生成主密钥"""
            # 使用SHA256生成确定性密钥
            return hashlib.sha256(seed.encode()).digest()
        
        def derive_key(self, index):
            """派生子密钥"""
            data = self.master_key + struct.pack('>I', index)
            return hashlib.sha256(data).digest()
    
    class HDWallet:
        """分层确定性钱包（BIP32）"""
        def __init__(self, mnemonic=None):
            self.mnemonic = mnemonic or self.generate_mnemonic()
            self.seed = self.mnemonic_to_seed(self.mnemonic)
            self.master_key = self.generate_master_key(self.seed)
            
        def generate_mnemonic(self, strength=256):
            """生成助记词（BIP39）"""
            mnemo = Mnemonic("english")
            return mnemo.generate(strength=strength)
```

### 1.2 密钥生成与管理

```python
class KeyManagement:
    """密钥管理"""
    
    def __init__(self):
        self.curve_order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
        
    def generate_private_key(self):
        """生成私钥"""
        while True:
            # 生成256位随机数
            private_key = os.urandom(32)
            key_int = int.from_bytes(private_key, 'big')
            
            # 确保在有效范围内 (1, n-1)
            if 0 < key_int < self.curve_order:
                return private_key
    
    def private_key_to_public_key(self, private_key_bytes):
        """从私钥生成公钥"""
        # 创建签名密钥对象
        signing_key = SigningKey.from_string(
            private_key_bytes, 
            curve=SECP256k1
        )
        
        # 获取验证密钥（公钥）
        verifying_key = signing_key.get_verifying_key()
        
        # 获取公钥点
        public_key_point = verifying_key.to_string()
        
        # 添加前缀（未压缩格式）
        uncompressed_public_key = b'\x04' + public_key_point
        
        # 压缩格式
        x = public_key_point[:32]
        y = public_key_point[32:]
        y_int = int.from_bytes(y, 'big')
        
        if y_int % 2 == 0:
            compressed_public_key = b'\x02' + x
        else:
            compressed_public_key = b'\x03' + x
        
        return {
            'uncompressed': uncompressed_public_key.hex(),
            'compressed': compressed_public_key.hex()
        }
    
    def public_key_to_address(self, public_key_hex, address_type='p2pkh'):
        """从公钥生成地址"""
        public_key_bytes = bytes.fromhex(public_key_hex)
        
        if address_type == 'p2pkh':
            # P2PKH地址（传统地址）
            return self.generate_p2pkh_address(public_key_bytes)
        elif address_type == 'p2sh':
            # P2SH地址（多签地址）
            return self.generate_p2sh_address(public_key_bytes)
        elif address_type == 'p2wpkh':
            # P2WPKH地址（原生隔离见证）
            return self.generate_p2wpkh_address(public_key_bytes)
        elif address_type == 'p2tr':
            # P2TR地址（Taproot）
            return self.generate_p2tr_address(public_key_bytes)
    
    def generate_p2pkh_address(self, public_key_bytes):
        """生成P2PKH地址"""
        # 1. SHA256
        sha256_hash = hashlib.sha256(public_key_bytes).digest()
        
        # 2. RIPEMD160
        ripemd160 = hashlib.new('ripemd160')
        ripemd160.update(sha256_hash)
        public_key_hash = ripemd160.digest()
        
        # 3. 添加版本字节（主网：0x00，测试网：0x6F）
        versioned_hash = b'\x00' + public_key_hash
        
        # 4. 双SHA256计算校验和
        checksum = hashlib.sha256(
            hashlib.sha256(versioned_hash).digest()
        ).digest()[:4]
        
        # 5. Base58编码
        address_bytes = versioned_hash + checksum
        address = base58.b58encode(address_bytes).decode('ascii')
        
        return address
```

## 二、HD钱包实现（BIP32/44/49/84）

### 2.1 BIP32 分层确定性钱包

```python
class BIP32HDWallet:
    """BIP32 HD钱包实现"""
    
    def __init__(self, seed=None):
        self.seed = seed or os.urandom(64)
        self.master_private_key, self.master_chain_code = self.generate_master_key()
        
    def generate_master_key(self):
        """生成主密钥"""
        # HMAC-SHA512
        seed_hmac = hmac.new(
            b"Bitcoin seed",
            self.seed,
            hashlib.sha512
        ).digest()
        
        # 前32字节作为主私钥
        master_private_key = seed_hmac[:32]
        
        # 后32字节作为主链码
        master_chain_code = seed_hmac[32:]
        
        return master_private_key, master_chain_code
    
    def derive_child_key(self, parent_key, parent_chain_code, index):
        """派生子密钥"""
        
        # 判断是否为硬化派生
        hardened = index >= 0x80000000
        
        if hardened:
            # 硬化派生：使用父私钥
            data = b'\x00' + parent_key + struct.pack('>I', index)
        else:
            # 非硬化派生：使用父公钥
            parent_public_key = self.private_to_public(parent_key)
            data = parent_public_key + struct.pack('>I', index)
        
        # HMAC-SHA512
        child_hmac = hmac.new(
            parent_chain_code,
            data,
            hashlib.sha512
        ).digest()
        
        # 前32字节作为子私钥的调整值
        child_key_offset = child_hmac[:32]
        
        # 后32字节作为子链码
        child_chain_code = child_hmac[32:]
        
        # 计算子私钥
        child_private_key = self.add_private_keys(
            parent_key, 
            child_key_offset
        )
        
        return child_private_key, child_chain_code
    
    def add_private_keys(self, key1, key2):
        """私钥加法（模n）"""
        n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
        
        key1_int = int.from_bytes(key1, 'big')
        key2_int = int.from_bytes(key2, 'big')
        
        result = (key1_int + key2_int) % n
        
        return result.to_bytes(32, 'big')
    
    def get_extended_key(self, key, chain_code, depth, fingerprint, child_num, is_private=True):
        """获取扩展密钥"""
        # 版本字节
        if is_private:
            version = b'\x04\x88\xAD\xE4'  # xprv
        else:
            version = b'\x04\x88\xB2\x1E'  # xpub
        
        # 深度
        depth_bytes = depth.to_bytes(1, 'big')
        
        # 父密钥指纹（4字节）
        fingerprint_bytes = fingerprint.to_bytes(4, 'big')
        
        # 子密钥索引
        child_num_bytes = child_num.to_bytes(4, 'big')
        
        # 密钥数据
        if is_private:
            key_data = b'\x00' + key
        else:
            key_data = key
        
        # 组装扩展密钥
        extended_key = version + depth_bytes + fingerprint_bytes + \
                      child_num_bytes + chain_code + key_data
        
        # 计算校验和
        checksum = hashlib.sha256(
            hashlib.sha256(extended_key).digest()
        ).digest()[:4]
        
        # Base58编码
        return base58.b58encode(extended_key + checksum).decode('ascii')
```

### 2.2 BIP44 多币种钱包

```python
class BIP44Wallet:
    """BIP44 多币种HD钱包"""
    
    def __init__(self, master_key):
        self.master_key = master_key
        self.coin_types = {
            'BTC': 0,
            'BTC_TESTNET': 1,
            'LTC': 2,
            'ETH': 60,
            'ETC': 61,
            'BCH': 145
        }
    
    def get_derivation_path(self, coin='BTC', account=0, change=0, index=0):
        """获取派生路径
        
        路径格式：m/purpose'/coin_type'/account'/change/address_index
        """
        purpose = 44  # BIP44
        coin_type = self.coin_types.get(coin, 0)
        
        return f"m/{purpose}'/{coin_type}'/{account}'/{change}/{index}"
    
    def derive_address(self, path):
        """根据路径派生地址"""
        # 解析路径
        levels = path.strip('m/').split('/')
        
        current_key = self.master_key['private_key']
        current_chain_code = self.master_key['chain_code']
        
        for level in levels:
            # 检查是否为硬化派生
            if level.endswith("'"):
                index = int(level[:-1]) + 0x80000000
            else:
                index = int(level)
            
            # 派生子密钥
            current_key, current_chain_code = self.derive_child_key(
                current_key, 
                current_chain_code, 
                index
            )
        
        # 生成地址
        public_key = self.private_to_public(current_key)
        address = self.public_to_address(public_key)
        
        return {
            'path': path,
            'private_key': current_key.hex(),
            'public_key': public_key.hex(),
            'address': address
        }
    
    def generate_account_addresses(self, coin='BTC', account=0, count=20):
        """生成账户地址"""
        addresses = {
            'external': [],  # 外部地址（接收）
            'internal': []   # 内部地址（找零）
        }
        
        # 生成外部地址
        for i in range(count):
            path = self.get_derivation_path(coin, account, 0, i)
            addr_info = self.derive_address(path)
            addresses['external'].append(addr_info)
        
        # 生成内部地址
        for i in range(count):
            path = self.get_derivation_path(coin, account, 1, i)
            addr_info = self.derive_address(path)
            addresses['internal'].append(addr_info)
        
        return addresses
```

### 2.3 BIP39 助记词

```python
class BIP39Mnemonic:
    """BIP39 助记词实现"""
    
    def __init__(self):
        self.wordlist = self.load_wordlist()
        
    def load_wordlist(self):
        """加载词表"""
        # 这里使用简化的词表，实际应该加载完整的2048个单词
        return [
            "abandon", "ability", "able", "about", "above", "absent",
            "absorb", "abstract", "absurd", "abuse", "access", "accident",
            # ... 完整的2048个单词
        ]
    
    def generate_mnemonic(self, strength=256):
        """生成助记词
        
        strength: 熵的位数（128, 160, 192, 224, 256）
        对应助记词数量：12, 15, 18, 21, 24
        """
        if strength not in [128, 160, 192, 224, 256]:
            raise ValueError("Invalid strength")
        
        # 生成随机熵
        entropy = os.urandom(strength // 8)
        
        # 计算校验和
        checksum_length = strength // 32
        hash_bytes = hashlib.sha256(entropy).digest()
        checksum = bin(hash_bytes[0])[2:].zfill(8)[:checksum_length]
        
        # 熵 + 校验和
        bits = bin(int.from_bytes(entropy, 'big'))[2:].zfill(strength) + checksum
        
        # 分割为11位组
        words = []
        for i in range(0, len(bits), 11):
            index = int(bits[i:i+11], 2)
            words.append(self.wordlist[index])
        
        return ' '.join(words)
    
    def mnemonic_to_seed(self, mnemonic, passphrase=""):
        """助记词转种子"""
        # PBKDF2-HMAC-SHA512
        salt = ("mnemonic" + passphrase).encode('utf-8')
        seed = hashlib.pbkdf2_hmac(
            'sha512',
            mnemonic.encode('utf-8'),
            salt,
            2048,  # 迭代次数
            64     # 输出长度
        )
        
        return seed
    
    def validate_mnemonic(self, mnemonic):
        """验证助记词"""
        words = mnemonic.split()
        
        # 检查词数
        if len(words) not in [12, 15, 18, 21, 24]:
            return False
        
        # 检查每个词是否在词表中
        for word in words:
            if word not in self.wordlist:
                return False
        
        # 转换为位串
        bits = ''
        for word in words:
            index = self.wordlist.index(word)
            bits += bin(index)[2:].zfill(11)
        
        # 分离熵和校验和
        checksum_length = len(words) // 3
        entropy_bits = bits[:-checksum_length]
        checksum_bits = bits[-checksum_length:]
        
        # 重新计算校验和
        entropy_bytes = int(entropy_bits, 2).to_bytes(len(entropy_bits) // 8, 'big')
        hash_bytes = hashlib.sha256(entropy_bytes).digest()
        calculated_checksum = bin(hash_bytes[0])[2:].zfill(8)[:checksum_length]
        
        return checksum_bits == calculated_checksum
```

## 三、交易创建与签名

### 3.1 交易构建

```python
class TransactionBuilder:
    """交易构建器"""
    
    def __init__(self):
        self.version = 2
        self.locktime = 0
        
    def create_transaction(self, inputs, outputs):
        """创建交易"""
        tx = {
            'version': self.version,
            'inputs': [],
            'outputs': [],
            'locktime': self.locktime
        }
        
        # 添加输入
        for inp in inputs:
            tx_input = {
                'txid': inp['txid'],
                'vout': inp['vout'],
                'script_sig': '',  # 稍后填充
                'sequence': 0xFFFFFFFE if self.locktime > 0 else 0xFFFFFFFF
            }
            tx['inputs'].append(tx_input)
        
        # 添加输出
        for out in outputs:
            tx_output = {
                'value': out['value'],
                'script_pubkey': self.create_script_pubkey(out['address'])
            }
            tx['outputs'].append(tx_output)
        
        return tx
    
    def create_script_pubkey(self, address):
        """创建输出脚本"""
        # 解码地址
        address_bytes = base58.b58decode(address.encode())
        
        # 移除校验和
        address_payload = address_bytes[:-4]
        
        # 获取版本和哈希
        version = address_payload[0]
        pubkey_hash = address_payload[1:]
        
        if version == 0x00:  # P2PKH
            # OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG
            script = bytes([0x76, 0xA9, 0x14]) + pubkey_hash + bytes([0x88, 0xAC])
        elif version == 0x05:  # P2SH
            # OP_HASH160 <script_hash> OP_EQUAL
            script = bytes([0xA9, 0x14]) + pubkey_hash + bytes([0x87])
        
        return script.hex()
    
    def serialize_transaction(self, tx):
        """序列化交易"""
        serialized = b''
        
        # 版本
        serialized += struct.pack('<I', tx['version'])
        
        # 输入数量
        serialized += self.encode_varint(len(tx['inputs']))
        
        # 输入
        for inp in tx['inputs']:
            # Previous output
            serialized += bytes.fromhex(inp['txid'])[::-1]
            serialized += struct.pack('<I', inp['vout'])
            
            # Script
            script = bytes.fromhex(inp['script_sig'])
            serialized += self.encode_varint(len(script))
            serialized += script
            
            # Sequence
            serialized += struct.pack('<I', inp['sequence'])
        
        # 输出数量
        serialized += self.encode_varint(len(tx['outputs']))
        
        # 输出
        for out in tx['outputs']:
            # Value
            serialized += struct.pack('<Q', out['value'])
            
            # Script
            script = bytes.fromhex(out['script_pubkey'])
            serialized += self.encode_varint(len(script))
            serialized += script
        
        # Locktime
        serialized += struct.pack('<I', tx['locktime'])
        
        return serialized
    
    def encode_varint(self, n):
        """编码变长整数"""
        if n < 0xFD:
            return bytes([n])
        elif n <= 0xFFFF:
            return bytes([0xFD]) + struct.pack('<H', n)
        elif n <= 0xFFFFFFFF:
            return bytes([0xFE]) + struct.pack('<I', n)
        else:
            return bytes([0xFF]) + struct.pack('<Q', n)
```

### 3.2 交易签名

```python
class TransactionSigner:
    """交易签名器"""
    
    def __init__(self):
        self.sighash_types = {
            'ALL': 0x01,
            'NONE': 0x02,
            'SINGLE': 0x03,
            'ALL|ANYONECANPAY': 0x81,
            'NONE|ANYONECANPAY': 0x82,
            'SINGLE|ANYONECANPAY': 0x83
        }
    
    def sign_transaction(self, tx, input_index, private_key, prev_script, sighash_type='ALL'):
        """签名交易"""
        # 1. 创建签名哈希
        sighash = self.create_sighash(
            tx, 
            input_index, 
            prev_script, 
            self.sighash_types[sighash_type]
        )
        
        # 2. 使用私钥签名
        signature = self.sign_with_key(sighash, private_key)
        
        # 3. 添加签名类型
        signature += bytes([self.sighash_types[sighash_type]])
        
        # 4. 创建scriptSig
        public_key = self.private_to_public(private_key)
        script_sig = self.create_script_sig(signature, public_key)
        
        # 5. 更新交易
        tx['inputs'][input_index]['script_sig'] = script_sig.hex()
        
        return tx
    
    def create_sighash(self, tx, input_index, prev_script, sighash_type):
        """创建签名哈希"""
        # 复制交易
        tx_copy = tx.copy()
        
        # 清空所有输入的scriptSig
        for i, inp in enumerate(tx_copy['inputs']):
            if i == input_index:
                # 当前输入使用前一个输出的脚本
                inp['script_sig'] = prev_script
            else:
                # 其他输入清空
                inp['script_sig'] = ''
        
        # 根据签名类型处理
        if sighash_type & 0x1F == 0x02:  # NONE
            # 清空所有输出
            tx_copy['outputs'] = []
            # 其他输入的sequence设为0
            for i, inp in enumerate(tx_copy['inputs']):
                if i != input_index:
                    inp['sequence'] = 0
                    
        elif sighash_type & 0x1F == 0x03:  # SINGLE
            # 只保留对应的输出
            if input_index >= len(tx_copy['outputs']):
                raise ValueError("Input index exceeds outputs")
            tx_copy['outputs'] = tx_copy['outputs'][:input_index+1]
            # 清空之前的输出
            for i in range(input_index):
                tx_copy['outputs'][i] = {'value': -1, 'script_pubkey': ''}
        
        if sighash_type & 0x80:  # ANYONECANPAY
            # 只包含当前输入
            tx_copy['inputs'] = [tx_copy['inputs'][input_index]]
        
        # 序列化交易
        serialized = self.serialize_transaction(tx_copy)
        
        # 添加签名类型
        serialized += struct.pack('<I', sighash_type)
        
        # 双SHA256
        return hashlib.sha256(hashlib.sha256(serialized).digest()).digest()
    
    def sign_with_key(self, message_hash, private_key):
        """使用私钥签名"""
        # 创建签名密钥
        signing_key = SigningKey.from_string(private_key, curve=SECP256k1)
        
        # 签名
        signature = signing_key.sign_digest(
            message_hash,
            sigencode=self.encode_der
        )
        
        return signature
    
    def encode_der(self, r, s, order):
        """DER编码签名"""
        # 确保r和s为正数
        if r > order // 2:
            r = order - r
        if s > order // 2:
            s = order - s
        
        # 编码r
        r_bytes = r.to_bytes((r.bit_length() + 7) // 8, 'big')
        if r_bytes[0] & 0x80:
            r_bytes = b'\x00' + r_bytes
        r_encoded = bytes([0x02, len(r_bytes)]) + r_bytes
        
        # 编码s
        s_bytes = s.to_bytes((s.bit_length() + 7) // 8, 'big')
        if s_bytes[0] & 0x80:
            s_bytes = b'\x00' + s_bytes
        s_encoded = bytes([0x02, len(s_bytes)]) + s_bytes
        
        # 组合
        sequence = r_encoded + s_encoded
        return bytes([0x30, len(sequence)]) + sequence
    
    def create_script_sig(self, signature, public_key):
        """创建输入脚本"""
        # P2PKH: <signature> <public_key>
        script = bytes([len(signature)]) + signature
        script += bytes([len(public_key)]) + public_key
        
        return script
```

## 四、多签钱包实现

### 4.1 多签地址生成

```python
class MultiSigWallet:
    """多签钱包"""
    
    def __init__(self, m, n):
        """
        m: 需要的签名数量
        n: 总密钥数量
        """
        if not (1 <= m <= n <= 15):
            raise ValueError("Invalid m-of-n parameters")
        
        self.m = m
        self.n = n
        self.public_keys = []
    
    def create_multisig_script(self, public_keys):
        """创建多签脚本"""
        if len(public_keys) != self.n:
            raise ValueError(f"Need exactly {self.n} public keys")
        
        # OP_M
        script = bytes([0x50 + self.m])
        
        # 公钥
        for pubkey in public_keys:
            pubkey_bytes = bytes.fromhex(pubkey)
            script += bytes([len(pubkey_bytes)]) + pubkey_bytes
        
        # OP_N
        script += bytes([0x50 + self.n])
        
        # OP_CHECKMULTISIG
        script += bytes([0xAE])
        
        return script
    
    def create_p2sh_address(self, redeem_script):
        """创建P2SH地址"""
        # 1. SHA256
        sha256_hash = hashlib.sha256(redeem_script).digest()
        
        # 2. RIPEMD160
        ripemd160 = hashlib.new('ripemd160')
        ripemd160.update(sha256_hash)
        script_hash = ripemd160.digest()
        
        # 3. 添加P2SH版本字节（主网：0x05）
        versioned_hash = b'\x05' + script_hash
        
        # 4. 计算校验和
        checksum = hashlib.sha256(
            hashlib.sha256(versioned_hash).digest()
        ).digest()[:4]
        
        # 5. Base58编码
        address = base58.b58encode(versioned_hash + checksum).decode('ascii')
        
        return address
    
    def sign_multisig_transaction(self, tx, input_index, signatures, redeem_script):
        """签名多签交易"""
        # 创建scriptSig
        script_sig = b'\x00'  # OP_0 (多签bug)
        
        # 添加签名
        for sig in signatures[:self.m]:  # 只需要m个签名
            script_sig += bytes([len(sig)]) + sig
        
        # 添加赎回脚本
        script_sig += bytes([len(redeem_script)]) + redeem_script
        
        # 更新交易
        tx['inputs'][input_index]['script_sig'] = script_sig.hex()
        
        return tx
```

### 4.2 门限签名方案

```python
class ThresholdSignature:
    """门限签名（Shamir秘密共享）"""
    
    def __init__(self, threshold, total):
        self.threshold = threshold
        self.total = total
        self.prime = 2**256 - 2**32 - 977  # secp256k1的p
    
    def split_secret(self, secret):
        """分割秘密"""
        # 生成多项式系数
        coefficients = [secret]
        for _ in range(self.threshold - 1):
            coef = int.from_bytes(os.urandom(32), 'big') % self.prime
            coefficients.append(coef)
        
        # 计算份额
        shares = []
        for i in range(1, self.total + 1):
            y = self.evaluate_polynomial(coefficients, i)
            shares.append((i, y))
        
        return shares
    
    def evaluate_polynomial(self, coefficients, x):
        """计算多项式在x点的值"""
        result = 0
        for i, coef in enumerate(coefficients):
            result = (result + coef * pow(x, i, self.prime)) % self.prime
        return result
    
    def recover_secret(self, shares):
        """恢复秘密（拉格朗日插值）"""
        if len(shares) < self.threshold:
            raise ValueError(f"Need at least {self.threshold} shares")
        
        secret = 0
        shares = shares[:self.threshold]
        
        for i, (x_i, y_i) in enumerate(shares):
            numerator = 1
            denominator = 1
            
            for j, (x_j, _) in enumerate(shares):
                if i != j:
                    numerator = (numerator * (-x_j)) % self.prime
                    denominator = (denominator * (x_i - x_j)) % self.prime
            
            # 计算拉格朗日基函数
            lagrange = (y_i * numerator * pow(denominator, -1, self.prime)) % self.prime
            secret = (secret + lagrange) % self.prime
        
        return secret
```

## 五、硬件钱包接口

### 5.1 硬件钱包协议

```python
class HardwareWalletInterface:
    """硬件钱包接口"""
    
    def __init__(self):
        self.protocols = {
            'hid': self.HIDProtocol(),
            'u2f': self.U2FProtocol(),
            'webusb': self.WebUSBProtocol()
        }
    
    class HIDProtocol:
        """HID协议（Ledger, Trezor）"""
        def __init__(self):
            self.vendor_id = None
            self.product_id = None
            
        def connect(self):
            """连接硬件钱包"""
            import hid
            
            # 枚举HID设备
            devices = hid.enumerate()
            
            for device in devices:
                if self.is_hardware_wallet(device):
                    self.device = hid.Device(
                        device['vendor_id'],
                        device['product_id']
                    )
                    return True
            
            return False
        
        def send_apdu(self, cla, ins, p1, p2, data=None):
            """发送APDU命令"""
            # 构建APDU
            apdu = bytes([cla, ins, p1, p2])
            
            if data:
                apdu += bytes([len(data)]) + data
            
            # 发送命令
            self.device.write(apdu)
            
            # 接收响应
            response = self.device.read(64)
            
            return response
    
    class TrezorProtocol:
        """Trezor协议实现"""
        def __init__(self):
            self.session_id = None
            
        def get_public_key(self, path):
            """获取公钥"""
            # 发送GetPublicKey消息
            message = self.create_message('GetPublicKey', {
                'address_n': self.parse_path(path),
                'ecdsa_curve_name': 'secp256k1',
                'show_display': False
            })
            
            response = self.send_message(message)
            
            return response['public_key']
        
        def sign_transaction(self, tx, paths):
            """签名交易"""
            # 1. 发送SignTx消息
            sign_tx = self.create_message('SignTx', {
                'inputs_count': len(tx['inputs']),
                'outputs_count': len(tx['outputs']),
                'coin_name': 'Bitcoin',
                'version': tx['version'],
                'lock_time': tx['locktime']
            })
            
            self.send_message(sign_tx)
            
            # 2. 发送输入
            for i, inp in enumerate(tx['inputs']):
                tx_input = self.create_message('TxInput', {
                    'address_n': self.parse_path(paths[i]),
                    'prev_hash': inp['txid'],
                    'prev_index': inp['vout'],
                    'script_type': 'SPENDADDRESS',
                    'sequence': inp['sequence']
                })
                
                response = self.send_message(tx_input)
            
            # 3. 发送输出
            for out in tx['outputs']:
                tx_output = self.create_message('TxOutput', {
                    'amount': out['value'],
                    'script_type': 'PAYTOADDRESS',
                    'address': out['address']
                })
                
                response = self.send_message(tx_output)
            
            # 4. 获取签名
            signatures = []
            for i in range(len(tx['inputs'])):
                sig_response = self.receive_message()
                signatures.append(sig_response['signature'])
            
            return signatures
```

### 5.2 安全元件交互

```python
class SecureElement:
    """安全元件交互"""
    
    def __init__(self):
        self.pin_attempts = 3
        self.locked = False
        
    def verify_pin(self, pin):
        """验证PIN码"""
        if self.locked:
            raise Exception("Device is locked")
        
        # 发送PIN验证命令
        response = self.send_command('VERIFY_PIN', pin)
        
        if not response['success']:
            self.pin_attempts -= 1
            if self.pin_attempts == 0:
                self.locked = True
                raise Exception("Device locked: too many failed attempts")
            
            raise Exception(f"Invalid PIN. {self.pin_attempts} attempts remaining")
        
        return True
    
    def derive_key_in_secure_element(self, path):
        """在安全元件内派生密钥"""
        # 密钥永不离开安全元件
        response = self.send_command('DERIVE_KEY', {
            'path': path,
            'return_public_only': True
        })
        
        return response['public_key']
    
    def sign_in_secure_element(self, message_hash, path):
        """在安全元件内签名"""
        response = self.send_command('SIGN', {
            'hash': message_hash,
            'path': path
        })
        
        return response['signature']
```

## 六、钱包安全机制

### 6.1 密钥加密存储

```python
class WalletEncryption:
    """钱包加密"""
    
    def __init__(self):
        self.kdf_iterations = 100000
        
    def encrypt_wallet(self, wallet_data, password):
        """加密钱包"""
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.primitives import padding
        from cryptography.hazmat.backends import default_backend
        
        # 1. 派生加密密钥
        salt = os.urandom(32)
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            salt,
            self.kdf_iterations,
            32
        )
        
        # 2. 生成IV
        iv = os.urandom(16)
        
        # 3. AES-256-CBC加密
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        
        encryptor = cipher.encryptor()
        
        # 填充数据
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(wallet_data) + padder.finalize()
        
        # 加密
        encrypted = encryptor.update(padded_data) + encryptor.finalize()
        
        # 4. 计算MAC
        mac_key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode() + b'mac',
            salt,
            self.kdf_iterations,
            32
        )
        
        mac = hmac.new(
            mac_key,
            encrypted,
            hashlib.sha256
        ).digest()
        
        # 5. 组装加密钱包
        encrypted_wallet = {
            'version': 1,
            'salt': salt.hex(),
            'iterations': self.kdf_iterations,
            'iv': iv.hex(),
            'encrypted_data': encrypted.hex(),
            'mac': mac.hex()
        }
        
        return encrypted_wallet
    
    def decrypt_wallet(self, encrypted_wallet, password):
        """解密钱包"""
        # 1. 验证MAC
        salt = bytes.fromhex(encrypted_wallet['salt'])
        
        mac_key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode() + b'mac',
            salt,
            encrypted_wallet['iterations'],
            32
        )
        
        expected_mac = hmac.new(
            mac_key,
            bytes.fromhex(encrypted_wallet['encrypted_data']),
            hashlib.sha256
        ).digest()
        
        if expected_mac.hex() != encrypted_wallet['mac']:
            raise ValueError("Invalid password or corrupted wallet")
        
        # 2. 派生解密密钥
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            salt,
            encrypted_wallet['iterations'],
            32
        )
        
        # 3. 解密
        # ... AES解密实现
        
        return decrypted_data
```

### 6.2 密钥备份与恢复

```python
class WalletBackup:
    """钱包备份与恢复"""
    
    def __init__(self):
        self.backup_formats = ['mnemonic', 'json', 'qr']
    
    def create_paper_backup(self, mnemonic):
        """创建纸质备份"""
        import qrcode
        
        # 1. 分割助记词
        words = mnemonic.split()
        
        # 2. 创建打印格式
        backup = {
            'header': '=== BITCOIN WALLET BACKUP ===',
            'warning': 'KEEP THIS SAFE! ANYONE WITH THIS CAN ACCESS YOUR FUNDS!',
            'date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'mnemonic': []
        }
        
        # 3. 格式化助记词（带序号）
        for i, word in enumerate(words, 1):
            backup['mnemonic'].append(f"{i:2d}. {word}")
        
        # 4. 生成QR码
        qr = qrcode.QRCode(
            version=None,
            error_correction=qrcode.constants.ERROR_CORRECT_H,
            box_size=10,
            border=4
        )
        
        qr.add_data(mnemonic)
        qr.make(fit=True)
        
        # 5. 创建备份文档
        return backup, qr
    
    def shamir_backup(self, mnemonic, threshold=3, shares=5):
        """Shamir秘密共享备份"""
        # 将助记词转换为熵
        entropy = self.mnemonic_to_entropy(mnemonic)
        
        # 分割秘密
        secret_shares = self.split_secret(entropy, threshold, shares)
        
        # 编码为助记词格式
        share_mnemonics = []
        for share in secret_shares:
            share_mnemonic = self.entropy_to_mnemonic(share)
            share_mnemonics.append(share_mnemonic)
        
        return share_mnemonics
    
    def recover_from_shamir(self, share_mnemonics):
        """从Shamir份额恢复"""
        # 转换为熵
        shares = []
        for share_mnemonic in share_mnemonics:
            share = self.mnemonic_to_entropy(share_mnemonic)
            shares.append(share)
        
        # 恢复秘密
        entropy = self.recover_secret(shares)
        
        # 转换为助记词
        mnemonic = self.entropy_to_mnemonic(entropy)
        
        return mnemonic
```

## 七、钱包性能优化

### 7.1 地址缓存与索引

```python
class AddressIndexer:
    """地址索引器"""
    
    def __init__(self):
        self.address_index = {}  # 地址到路径的映射
        self.gap_limit = 20      # 地址间隙限制
        
    def build_address_index(self, xpub, account=0):
        """构建地址索引"""
        external_index = 0
        internal_index = 0
        
        # 扫描外部地址
        consecutive_unused = 0
        while consecutive_unused < self.gap_limit:
            path = f"m/44'/0'/{account}'/0/{external_index}"
            address = self.derive_address_from_xpub(xpub, path)
            
            is_used = self.check_address_used(address)
            
            if is_used:
                consecutive_unused = 0
                self.address_index[address] = {
                    'path': path,
                    'type': 'external',
                    'index': external_index
                }
            else:
                consecutive_unused += 1
            
            external_index += 1
        
        # 扫描内部地址（找零）
        # ... 类似的逻辑
        
        return self.address_index
    
    def check_address_used(self, address):
        """检查地址是否使用过"""
        # 查询区块链或本地数据库
        # 这里使用简化的实现
        return self.query_blockchain_api(address)
```

### 7.2 UTXO管理

```python
class UTXOManager:
    """UTXO管理器"""
    
    def __init__(self):
        self.utxos = []
        self.spent_outputs = set()
        
    def update_utxos(self, address_list):
        """更新UTXO集"""
        new_utxos = []
        
        for address in address_list:
            # 查询地址的UTXO
            address_utxos = self.fetch_utxos(address)
            
            for utxo in address_utxos:
                # 检查是否已花费
                outpoint = f"{utxo['txid']}:{utxo['vout']}"
                if outpoint not in self.spent_outputs:
                    new_utxos.append(utxo)
        
        self.utxos = new_utxos
        return self.utxos
    
    def select_coins(self, target_amount, fee_rate):
        """币选择算法"""
        
        class CoinSelector:
            """币选择器"""
            
            def branch_and_bound(self, utxos, target):
                """分支定界算法"""
                # 最优化选择，最小化找零
                best_selection = None
                best_waste = float('inf')
                
                def search(depth, selected, remaining):
                    nonlocal best_selection, best_waste
                    
                    if depth >= len(utxos):
                        return
                    
                    # 计算当前值
                    current_value = sum(u['value'] for u in selected)
                    
                    if current_value >= target:
                        waste = current_value - target
                        if waste < best_waste:
                            best_waste = waste
                            best_selection = selected.copy()
                        return
                    
                    # 尝试包含当前UTXO
                    if depth < len(utxos):
                        selected.append(utxos[depth])
                        search(depth + 1, selected, remaining - utxos[depth]['value'])
                        selected.pop()
                        
                        # 尝试不包含
                        search(depth + 1, selected, remaining)
                
                search(0, [], target)
                return best_selection
            
            def largest_first(self, utxos, target):
                """最大优先算法"""
                sorted_utxos = sorted(utxos, key=lambda x: x['value'], reverse=True)
                selected = []
                total = 0
                
                for utxo in sorted_utxos:
                    selected.append(utxo)
                    total += utxo['value']
                    if total >= target:
                        break
                
                return selected
        
        selector = CoinSelector()
        
        # 计算目标金额（包括费用）
        estimated_size = 250  # 字节（估计）
        fee = fee_rate * estimated_size
        total_target = target_amount + fee
        
        # 选择算法
        if len(self.utxos) < 10:
            # UTXO较少时使用最优算法
            selected = selector.branch_and_bound(self.utxos, total_target)
        else:
            # UTXO较多时使用贪婪算法
            selected = selector.largest_first(self.utxos, total_target)
        
        return selected
```

## 八、实际应用示例

### 8.1 完整钱包实现

```python
class BitcoinWallet:
    """完整的比特币钱包实现"""
    
    def __init__(self, mnemonic=None):
        # 初始化组件
        self.mnemonic = mnemonic or self.generate_mnemonic()
        self.hd_wallet = BIP44Wallet(self.mnemonic_to_seed(self.mnemonic))
        self.utxo_manager = UTXOManager()
        self.tx_builder = TransactionBuilder()
        self.tx_signer = TransactionSigner()
        
        # 钱包状态
        self.addresses = {}
        self.balance = 0
        self.transactions = []
        
    def create_new_address(self, label=""):
        """创建新地址"""
        # 获取下一个未使用的地址索引
        index = len(self.addresses)
        
        # 派生地址
        path = f"m/44'/0'/0'/0/{index}"
        addr_info = self.hd_wallet.derive_address(path)
        
        # 保存地址信息
        self.addresses[addr_info['address']] = {
            'path': path,
            'label': label,
            'private_key': addr_info['private_key'],
            'public_key': addr_info['public_key'],
            'balance': 0
        }
        
        return addr_info['address']
    
    def send_bitcoin(self, to_address, amount, fee_rate=1):
        """发送比特币"""
        # 1. 选择UTXO
        utxos = self.utxo_manager.select_coins(amount, fee_rate)
        
        if not utxos:
            raise ValueError("Insufficient funds")
        
        # 2. 计算找零
        total_input = sum(u['value'] for u in utxos)
        fee = fee_rate * 250  # 估计交易大小
        change = total_input - amount - fee
        
        # 3. 创建交易
        inputs = []
        for utxo in utxos:
            inputs.append({
                'txid': utxo['txid'],
                'vout': utxo['vout'],
                'address': utxo['address']
            })
        
        outputs = [
            {'address': to_address, 'value': amount}
        ]
        
        if change > 546:  # 粉尘限制
            change_address = self.create_new_address("change")
            outputs.append({'address': change_address, 'value': change})
        
        tx = self.tx_builder.create_transaction(inputs, outputs)
        
        # 4. 签名交易
        for i, inp in enumerate(inputs):
            addr_info = self.addresses[inp['address']]
            private_key = bytes.fromhex(addr_info['private_key'])
            
            # 获取前一个输出的脚本
            prev_script = self.get_prev_script(inp['txid'], inp['vout'])
            
            tx = self.tx_signer.sign_transaction(
                tx, i, private_key, prev_script
            )
        
        # 5. 广播交易
        tx_hex = self.tx_builder.serialize_transaction(tx).hex()
        txid = self.broadcast_transaction(tx_hex)
        
        return txid
    
    def sync_wallet(self):
        """同步钱包"""
        # 更新所有地址的UTXO
        address_list = list(self.addresses.keys())
        self.utxo_manager.update_utxos(address_list)
        
        # 计算余额
        self.balance = sum(u['value'] for u in self.utxo_manager.utxos)
        
        # 获取交易历史
        self.update_transaction_history()
        
        return {
            'balance': self.balance,
            'utxos': len(self.utxo_manager.utxos),
            'addresses': len(self.addresses)
        }
```

## 总结

比特币钱包技术实现涉及多个关键组件：

1. **密钥管理**：安全生成、存储和使用私钥
2. **地址派生**：支持多种地址格式和HD钱包标准
3. **交易构建**：正确构建和签名交易
4. **UTXO管理**：高效管理和选择币
5. **安全机制**：加密存储、备份恢复、硬件钱包支持

关键安全原则：
- **私钥永不触网**：私钥应该离线生成和存储
- **使用HD钱包**：便于备份和恢复
- **多重备份**：助记词、纸质备份、分片备份
- **硬件钱包**：高价值资产使用硬件钱包

钱包开发最佳实践：
- 遵循BIP标准确保互操作性
- 实现完善的错误处理
- 提供清晰的用户界面
- 定期安全审计
- 支持多种备份方式

理解钱包技术对于安全管理比特币资产至关重要，也是开发区块链应用的基础技能。

---

*"Not your keys, not your coins."* - 比特币社区谚语

掌握钱包技术，真正掌控你的数字资产。
