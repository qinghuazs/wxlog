---
title: 最长回文字符串
date: 2025-11-17
permalink: /docs/leetcode/字符串/01.最长回文字符串/
categories:
  - Algorithm
  - LeetCode
---

# 最长回文字符串（Longest Palindromic Substring）

## 1. 问题描述

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**
```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**
```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**
```
输入：s = "a"
输出："a"
```

**示例 4：**
```
输入：s = "ac"
输出："a"
```

**约束条件：**
- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## 2. 核心难点分析

### 2.1 回文字符串的特性
- **对称性**：回文字符串从左到右和从右到左读取结果相同
- **中心性**：每个回文字符串都有一个中心点（奇数长度）或中心轴（偶数长度）
- **递归性**：如果一个字符串是回文，去掉首尾字符后仍然是回文

### 2.2 主要挑战
1. **长度不确定**：回文子串可能是奇数长度或偶数长度
2. **位置不确定**：回文子串可能出现在字符串的任何位置
3. **效率要求**：需要在合理时间内找到最长的回文子串
4. **边界处理**：单字符、空字符串等特殊情况

## 3. 解法分析

### 3.1 暴力解法
**思路**：枚举所有可能的子串，逐一检查是否为回文

**优点**：
- 思路简单直观
- 容易实现
- 空间复杂度低

**缺点**：
- 时间复杂度高 O(n³)
- 效率低下
- 不适合大规模数据

### 3.2 中心扩展法（推荐）
**思路**：以每个字符（或字符间隙）为中心，向两边扩展寻找回文

**优点**：
- 时间复杂度 O(n²)
- 空间复杂度 O(1)
- 实现相对简单
- 易于理解和调试

**缺点**：
- 需要分别处理奇数和偶数长度的回文
- 仍然不是最优解

### 3.3 动态规划
**思路**：利用回文的递归性质，通过状态转移求解

**优点**：
- 思路清晰
- 可以记录所有回文子串信息
- 时间复杂度 O(n²)

**缺点**：
- 空间复杂度 O(n²)
- 内存消耗较大

### 3.4 Manacher算法（最优）
**思路**：通过预处理和利用回文的对称性，实现线性时间复杂度

**优点**：
- 时间复杂度 O(n)
- 最优解法
- 处理奇偶长度统一

**缺点**：
- 实现复杂
- 理解难度大
- 面试中不常要求

## 4. 详细代码实现

### 4.1 中心扩展法（Java实现）

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        
        int start = 0, end = 0;
        
        for (int i = 0; i < s.length(); i++) {
            // 以i为中心的奇数长度回文
            int len1 = expandAroundCenter(s, i, i);
            // 以i和i+1为中心的偶数长度回文
            int len2 = expandAroundCenter(s, i, i + 1);
            
            int len = Math.max(len1, len2);
            
            // 更新最长回文的起始和结束位置
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.substring(start, end + 1);
    }
    
    /**
     * 从中心向两边扩展，返回回文长度
     */
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
```

### 4.2 中心扩展法（Python实现）

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s or len(s) < 1:
            return ""
        
        start, end = 0, 0
        
        for i in range(len(s)):
            # 以i为中心的奇数长度回文
            len1 = self.expand_around_center(s, i, i)
            # 以i和i+1为中心的偶数长度回文
            len2 = self.expand_around_center(s, i, i + 1)
            
            max_len = max(len1, len2)
            
            # 更新最长回文的起始和结束位置
            if max_len > end - start:
                start = i - (max_len - 1) // 2
                end = i + max_len // 2
        
        return s[start:end + 1]
    
    def expand_around_center(self, s: str, left: int, right: int) -> int:
        """从中心向两边扩展，返回回文长度"""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
```

### 4.3 动态规划实现（Python）

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        n = len(s)
        # dp[i][j] 表示 s[i:j+1] 是否为回文
        dp = [[False] * n for _ in range(n)]
        
        start = 0
        max_len = 1
        
        # 单个字符都是回文
        for i in range(n):
            dp[i][i] = True
        
        # 检查长度为2的子串
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start = i
                max_len = 2
        
        # 检查长度大于2的子串
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    start = i
                    max_len = length
        
        return s[start:start + max_len]
```

### 4.4 Manacher算法实现（Python）

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        # 预处理：在每个字符间插入'#'
        processed = '#'.join('^{}$'.format(s))
        n = len(processed)
        
        # P[i] 表示以i为中心的回文半径
        P = [0] * n
        center = right = 0  # 当前回文的中心和右边界
        
        for i in range(1, n - 1):
            # 利用对称性初始化P[i]
            if i < right:
                P[i] = min(right - i, P[2 * center - i])
            
            # 尝试扩展回文
            while processed[i + P[i] + 1] == processed[i - P[i] - 1]:
                P[i] += 1
            
            # 更新中心和右边界
            if i + P[i] > right:
                center, right = i, i + P[i]
        
        # 找到最长回文
        max_len = max(P)
        center_index = P.index(max_len)
        
        # 转换回原字符串的索引
        start = (center_index - max_len) // 2
        return s[start:start + max_len]
```

## 5. 复杂度分析

### 5.1 时间复杂度对比

| 算法 | 时间复杂度 | 说明 |
|------|------------|------|
| 暴力解法 | O(n³) | 枚举O(n²)个子串，每次检查O(n) |
| 中心扩展 | O(n²) | n个中心，每次最多扩展n次 |
| 动态规划 | O(n²) | 填充n²个状态 |
| Manacher | O(n) | 线性扫描，每个位置最多访问常数次 |

### 5.2 空间复杂度对比

| 算法 | 空间复杂度 | 说明 |
|------|------------|------|
| 暴力解法 | O(1) | 只需常数额外空间 |
| 中心扩展 | O(1) | 只需常数额外空间 |
| 动态规划 | O(n²) | 需要二维DP表 |
| Manacher | O(n) | 需要预处理字符串和辅助数组 |

## 6. 边界情况处理

### 6.1 特殊输入
```python
# 空字符串
s = ""
# 预期输出：""

# 单字符
s = "a"
# 预期输出："a"

# 两个相同字符
s = "aa"
# 预期输出："aa"

# 两个不同字符
s = "ab"
# 预期输出："a" 或 "b"

# 全部相同字符
s = "aaaa"
# 预期输出："aaaa"
```

### 6.2 边界检查要点
1. **空字符串检查**：避免空指针异常
2. **单字符处理**：单字符本身就是回文
3. **数组越界**：扩展时注意边界
4. **起始位置计算**：确保索引计算正确

## 7. 相关变种问题

### 7.1 最长回文子序列（LeetCode 516）
**区别**：子序列不要求连续，子串要求连续

```python
def longestPalindromeSubseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = 1
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    
    return dp[0][n - 1]
```

### 7.2 回文数（LeetCode 9）
**思路**：将数字转换为字符串或直接反转数字

```python
def isPalindrome(x: int) -> bool:
    if x < 0:
        return False
    
    original = x
    reversed_num = 0
    
    while x > 0:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    
    return original == reversed_num
```

### 7.3 验证回文字符串（LeetCode 125）
**思路**：双指针，忽略非字母数字字符

```python
def isPalindrome(s: str) -> bool:
    left, right = 0, len(s) - 1
    
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True
```

### 7.4 分割回文串（LeetCode 131）
**思路**：回溯 + 动态规划预处理

```python
def partition(s: str) -> List[List[str]]:
    n = len(s)
    # 预处理：判断所有子串是否为回文
    is_palindrome = [[False] * n for _ in range(n)]
    
    for i in range(n):
        is_palindrome[i][i] = True
    
    for i in range(n - 1):
        is_palindrome[i][i + 1] = (s[i] == s[i + 1])
    
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i + 1][j - 1])
    
    result = []
    
    def backtrack(start, path):
        if start == n:
            result.append(path[:])
            return
        
        for end in range(start, n):
            if is_palindrome[start][end]:
                path.append(s[start:end + 1])
                backtrack(end + 1, path)
                path.pop()
    
    backtrack(0, [])
    return result
```

## 8. 性能优化技巧

### 8.1 中心扩展法优化
```python
def longestPalindrome(s: str) -> str:
    if not s:
        return ""
    
    start, max_len = 0, 1
    
    for i in range(len(s)):
        # 早期剪枝：如果剩余长度不足以产生更长回文，直接跳出
        if len(s) - i <= max_len // 2:
            break
        
        # 合并奇偶长度的处理
        left, right = i, i
        
        # 跳过重复字符（优化偶数长度回文的处理）
        while right < len(s) - 1 and s[right] == s[right + 1]:
            right += 1
        
        # 向两边扩展
        while left > 0 and right < len(s) - 1 and s[left - 1] == s[right + 1]:
            left -= 1
            right += 1
        
        # 更新最长回文
        if right - left + 1 > max_len:
            start = left
            max_len = right - left + 1
    
    return s[start:start + max_len]
```

### 8.2 内存优化
```python
# 对于动态规划，可以使用滚动数组优化空间
def longestPalindrome(s: str) -> str:
    if not s:
        return ""
    
    n = len(s)
    start, max_len = 0, 1
    
    # 只保存当前和上一行的状态
    prev = [False] * n
    curr = [False] * n
    
    # 初始化单字符回文
    for i in range(n):
        prev[i] = True
    
    # 检查长度为2的回文
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            curr[i] = True
            start, max_len = i, 2
        else:
            curr[i] = False
    
    # 检查长度大于2的回文
    for length in range(3, n + 1):
        prev, curr = curr, [False] * n
        
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and prev[i + 1]:
                curr[i] = True
                start, max_len = i, length
    
    return s[start:start + max_len]
```

## 9. 实际应用场景

### 9.1 文本处理
- **DNA序列分析**：寻找回文序列用于基因研究
- **文本编辑器**：实现回文检测功能
- **数据压缩**：利用回文特性进行压缩

### 9.2 字符串匹配
- **模式识别**：识别对称模式
- **数据验证**：验证特定格式的数据
- **密码学**：某些加密算法中的应用

### 9.3 算法竞赛
- **编程竞赛**：经典的字符串处理问题
- **面试题目**：考察算法设计能力
- **教学示例**：动态规划和字符串算法的典型例子

## 10. 常见错误与调试

### 10.1 常见错误

1. **索引计算错误**
```python
# 错误：起始位置计算错误
start = i - len // 2  # 可能导致负数索引

# 正确：考虑奇偶长度的不同
start = i - (len - 1) // 2
```

2. **边界检查遗漏**
```python
# 错误：没有检查边界
while s[left] == s[right]:  # 可能越界
    left -= 1
    right += 1

# 正确：添加边界检查
while left >= 0 and right < len(s) and s[left] == s[right]:
    left -= 1
    right += 1
```

3. **奇偶长度处理不当**
```python
# 错误：只考虑奇数长度
for i in range(len(s)):
    length = expand_around_center(s, i, i)

# 正确：同时考虑奇偶长度
for i in range(len(s)):
    len1 = expand_around_center(s, i, i)      # 奇数长度
    len2 = expand_around_center(s, i, i + 1)  # 偶数长度
    max_len = max(len1, len2)
```

### 10.2 调试技巧

1. **添加调试输出**
```python
def longestPalindrome(s: str) -> str:
    print(f"输入字符串: {s}")
    
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        print(f"位置 {i}: 奇数长度={len1}, 偶数长度={len2}")
```

2. **单元测试**
```python
def test_longest_palindrome():
    solution = Solution()
    
    # 测试用例
    test_cases = [
        ("", ""),
        ("a", "a"),
        ("aa", "aa"),
        ("ab", "a"),
        ("babad", "bab"),
        ("cbbd", "bb"),
        ("racecar", "racecar"),
        ("abcdef", "a")
    ]
    
    for input_str, expected in test_cases:
        result = solution.longestPalindrome(input_str)
        print(f"输入: {input_str}, 期望: {expected}, 实际: {result}")
        assert len(result) == len(expected), f"长度不匹配: {input_str}"
```

## 11. 面试要点总结

### 11.1 核心考点
1. **算法选择**：能够分析不同算法的优缺点
2. **代码实现**：熟练实现中心扩展法
3. **复杂度分析**：准确分析时间和空间复杂度
4. **边界处理**：考虑各种特殊情况
5. **优化思路**：能够提出性能优化方案

### 11.2 面试回答策略

**第一步：理解题意**
- 明确什么是回文字符串
- 确认是子串还是子序列
- 询问边界条件和约束

**第二步：分析解法**
- 从暴力解法开始分析
- 逐步优化到中心扩展法
- 如果时间允许，可以提及Manacher算法

**第三步：编码实现**
- 选择中心扩展法实现
- 注意处理奇偶长度的回文
- 添加必要的边界检查

**第四步：测试验证**
- 使用给定的示例测试
- 考虑边界情况
- 分析时间和空间复杂度

### 11.3 加分项
- 能够快速想到多种解法
- 代码简洁且易读
- 主动考虑边界情况
- 能够分析算法的适用场景
- 提出优化建议

### 11.4 常见面试问题

**Q: 为什么选择中心扩展法而不是动态规划？**
A: 中心扩展法的空间复杂度是O(1)，而动态规划需要O(n²)的空间。在这个问题中，我们只需要找到最长回文子串，不需要记录所有回文子串的信息，所以中心扩展法更优。

**Q: 如何处理奇数和偶数长度的回文？**
A: 对于每个位置i，我们需要检查两种情况：以i为中心的奇数长度回文（i,i）和以i和i+1为中心的偶数长度回文（i,i+1）。

**Q: 能否进一步优化算法？**
A: 可以使用Manacher算法实现O(n)的时间复杂度，但实现较为复杂。在实际应用中，中心扩展法已经足够高效。

## 12. 总结

最长回文字符串问题是字符串处理中的经典问题，考察了多种算法思想：

### 12.1 核心要点
1. **理解回文特性**：对称性是解决问题的关键
2. **掌握中心扩展法**：最实用的解法，平衡了效率和实现复杂度
3. **注意边界处理**：奇偶长度、数组越界等问题
4. **复杂度权衡**：根据实际需求选择合适的算法

### 12.2 学习建议
1. **从简单开始**：先理解暴力解法，再优化到中心扩展
2. **多练习实现**：熟练掌握中心扩展法的编码
3. **理解原理**：深入理解每种算法的思想和适用场景
4. **扩展学习**：学习相关的回文问题变种

### 12.3 扩展学习
- 学习Manacher算法的原理和实现
- 研究其他字符串匹配算法（KMP、Boyer-Moore等）
- 练习更多回文相关的问题
- 了解字符串算法在实际项目中的应用

通过深入学习这个问题，可以提升字符串处理能力，为解决更复杂的算法问题打下坚实基础。