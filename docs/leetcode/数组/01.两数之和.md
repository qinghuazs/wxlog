---
title: 两数之和
date: 2025-11-17
categories:
  - Algorithm
  - LeetCode
---

# 两数之和

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

## 解题思路

### 方法一：暴力解法

最直观的方法是使用两层循环，对于每个元素，遍历数组中的其他元素，看是否存在两个数的和等于目标值。

**时间复杂度：** O(n²)
**空间复杂度：** O(1)

```java
public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return new int[]{i, j};
            }
        }
    }
    return new int[0];
}
```

### 方法二：哈希表（推荐）

使用哈希表可以将查找时间从 O(n) 降低到 O(1)。我们遍历数组，对于每个元素，检查哈希表中是否存在 `target - nums[i]`。

**核心思想：**
- 遍历数组，对于当前元素 `nums[i]`
- 计算需要的另一个数：`complement = target - nums[i]`
- 检查哈希表中是否存在 `complement`
- 如果存在，返回两个数的索引
- 如果不存在，将当前数和索引存入哈希表

**时间复杂度：** O(n)
**空间复杂度：** O(n)

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        
        map.put(nums[i], i);
    }
    
    return new int[0];
}
```

## 算法步骤详解

1. **初始化哈希表**：创建一个空的哈希表用于存储数组元素和对应的索引

2. **遍历数组**：从左到右遍历数组中的每个元素

3. **计算补数**：对于当前元素 `nums[i]`，计算需要的另一个数 `complement = target - nums[i]`

4. **查找补数**：在哈希表中查找是否存在这个补数
   - 如果存在，说明找到了两个数，返回它们的索引
   - 如果不存在，将当前数和索引存入哈希表

5. **返回结果**：返回找到的两个数的索引

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| 暴力解法 | O(n²) | O(1) | 简单直观，但效率低 |
| 哈希表 | O(n) | O(n) | 效率高，是最优解 |

## 关键点总结

1. **哈希表的使用**：将查找时间从 O(n) 优化到 O(1)
2. **一次遍历**：边遍历边查找，无需预处理
3. **索引处理**：注意返回的是索引而不是数值
4. **边界条件**：题目保证有解，无需考虑无解情况

## 扩展思考

1. **如果数组已排序**：可以使用双指针法，时间复杂度 O(n)，空间复杂度 O(1)
2. **如果要求返回所有可能的组合**：需要修改算法逻辑
3. **如果允许重复使用元素**：需要调整哈希表的使用方式

---

## 文生视频提示词

### Kling AI 提示词

**场景1：算法讲解动画**
```
创建一个教育性动画视频，展示LeetCode两数之和算法的解题过程。画面中央是一个干净的白板，上面显示数组[2,7,11,15]和目标值9。一只虚拟的手拿着彩色马克笔，首先用暴力解法演示：手指依次指向数组元素，用红色圆圈标记正在比较的两个数字，当找到2+7=9时，用绿色高亮显示答案。然后切换到哈希表解法，画面右侧出现一个透明的哈希表结构，随着算法进行，数字和索引逐个飞入表格。整个过程配合柔和的背景音乐，动画流畅自然，适合编程学习。
```

**场景2：代码执行可视化**
```
制作一个代码执行可视化动画，屏幕分为左右两部分。左侧显示Java代码，代码行会随着执行过程高亮显示。右侧是数据结构的动态演示：数组元素用彩色方块表示，哈希表用现代化的表格展示。当代码执行到关键步骤时，相应的数据结构会有动画效果：数组元素会闪烁，哈希表中的键值对会以动画形式插入。背景是深蓝色渐变，给人专业的编程环境感觉。整个视频时长60秒，节奏适中。
```

### 即梦 APP 提示词

**场景1：抽象概念可视化**
```
创建一个充满科技感的3D动画场景，展示两数之和算法的核心思想。画面中心是一个发光的数字阵列，每个数字都是立体的蓝色水晶块，悬浮在虚拟空间中。当算法开始时，目标数字9在空中闪烁金色光芒。随着哈希表算法的进行，相关的数字会被彩色光束连接，最终找到答案时，2和7会被绿色光环包围，并缓缓旋转。整个场景有粒子特效和柔和的光影变化，营造出未来科技的氛围。
```

**场景2：教学情境动画**
```
设计一个温馨的学习场景：一个现代化的教室里，一位年轻的程序员老师站在智能黑板前讲解两数之和问题。黑板上的内容会随着讲解动态变化，数组和哈希表以卡通化的形式呈现。学生的视角看向黑板，可以看到算法步骤一步步展开。当找到正确答案时，黑板上会出现庆祝的小动画效果。整个场景光线柔和，色彩温暖，营造出良好的学习氛围。视频时长90秒，适合教学使用。
```

**场景3：游戏化演示**
```
创建一个游戏风格的动画：将两数之和问题包装成一个寻宝游戏。画面是一个神秘的数字迷宫，每个数组元素都是一个发光的宝石。主角是一个可爱的机器人，它需要找到两个宝石，使它们的数值之和等于目标值。机器人首先尝试暴力搜索，在迷宫中来回奔跑，然后学会使用"记忆水晶"（哈希表）来快速定位目标。当找到正确答案时，宝石会合并成一个更大的钻石，机器人欢快地庆祝。整个动画充满趣味性和互动感。
```