---
title: Spring Cloud Gateway的使用
date: 2025-11-17
categories:
  - SpringCloud
  - Spring
---

# Spring Cloud Gateway 使用指南

## 1. 项目搭建与基础配置

### 1.1 Maven 依赖配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>gateway-demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
        <relativePath/>
    </parent>
    
    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.3</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Spring Cloud Gateway 核心依赖 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        
        <!-- 服务发现 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        
        <!-- 配置中心 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        
        <!-- 熔断器 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>
        
        <!-- 限流 Redis 支持 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>
        
        <!-- 监控 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- 安全 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

### 1.2 启动类配置

```java
package com.example.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * Gateway 启动类
 * @author example
 */
@SpringBootApplication
@EnableEurekaClient
public class GatewayApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
```

## 2. 路由配置

### 2.1 YAML 配置方式

```yaml
server:
  port: 8080

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      # 全局跨域配置
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOriginPatterns: "*"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600
      
      # 路由配置
      routes:
        # 用户服务路由
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=2  # 去掉前缀 /api/user
            - AddRequestHeader=X-Request-Source, gateway
            - AddResponseHeader=X-Response-Time, #{T(System).currentTimeMillis()}
        
        # 订单服务路由
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/order/**
            - Method=GET,POST
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10  # 令牌桶每秒填充平均速率
                redis-rate-limiter.burstCapacity: 20  # 令牌桶总容量
                redis-rate-limiter.requestedTokens: 1 # 每个请求需要的令牌数
                key-resolver: "#{@ipKeyResolver}"     # 限流键解析器
        
        # 商品服务路由（带权重负载均衡）
        - id: product-service-v1
          uri: lb://product-service
          predicates:
            - Path=/api/product/**
            - Weight=product, 80  # 80% 流量
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Version, v1
        
        - id: product-service-v2
          uri: lb://product-service-v2
          predicates:
            - Path=/api/product/**
            - Weight=product, 20  # 20% 流量
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Version, v2
        
        # 支付服务路由（带熔断器）
        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payment/**
          filters:
            - StripPrefix=2
            - name: CircuitBreaker
              args:
                name: payment-circuit-breaker
                fallbackUri: forward:/fallback/payment
        
        # 静态资源路由
        - id: static-resources
          uri: http://static.example.com
          predicates:
            - Path=/static/**
          filters:
            - AddResponseHeader=Cache-Control, max-age=3600
  
  # Redis 配置（用于限流）
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0

# Eureka 配置
eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_SERVER:http://localhost:8761/eureka/}
    fetch-registry: true
    register-with-eureka: true
    registry-fetch-interval-seconds: 30
  instance:
    prefer-ip-address: true
    instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port}
    lease-renewal-interval-in-seconds: 30
    lease-expiration-duration-in-seconds: 90

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: "*"
      base-path: /actuator
  endpoint:
    health:
      show-details: always
      show-components: always
    gateway:
      enabled: true
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.9, 0.95, 0.99

# 日志配置
logging:
  level:
    root: INFO
    org.springframework.cloud.gateway: DEBUG
    org.springframework.web.reactive: DEBUG
    reactor.netty: INFO
    com.example.gateway: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{requestId}] %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{requestId}] %logger{36} - %msg%n"
  file:
    name: logs/gateway.log
    max-size: 100MB
    max-history: 30

# 自定义配置
gateway:
  security:
    jwt:
      secret: ${JWT_SECRET:mySecretKey}
      expiration: 86400
    cors:
      allowed-origins:
        - "http://localhost:3000"
        - "https://*.example.com"
      allowed-methods:
        - GET
        - POST
        - PUT
        - DELETE
        - OPTIONS
      allowed-headers: "*"
      allow-credentials: true
      max-age: 3600
  rate-limit:
    default:
      replenish-rate: 10
      burst-capacity: 20
    user-service:
      replenish-rate: 50
      burst-capacity: 100
    payment-service:
      replenish-rate: 5
      burst-capacity: 10
```

### 8.2 application-dev.yml

```yaml
spring:
  redis:
    host: localhost
    port: 6379
    password: 
  cloud:
    gateway:
      routes:
        # 开发环境特定路由
        - id: dev-tools
          uri: http://localhost:8082
          predicates:
            - Path=/dev/**
          filters:
            - StripPrefix=1

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/

logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    reactor.netty: DEBUG
```

### 8.3 application-prod.yml

```yaml
spring:
  redis:
    host: ${REDIS_HOST}
    port: ${REDIS_PORT}
    password: ${REDIS_PASSWORD}
    ssl: true
  cloud:
    gateway:
      routes:
        # 生产环境路由配置
        - id: health-check
          uri: http://health-service
          predicates:
            - Path=/health
          filters:
            - AddResponseHeader=Cache-Control, no-cache

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_SERVERS}

logging:
  level:
    root: WARN
    org.springframework.cloud.gateway: INFO
    com.example.gateway: INFO
  file:
    name: /var/log/gateway/gateway.log
```

## 9. 测试与验证

### 9.1 单元测试

```java
package com.example.gateway.filter;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.http.HttpStatus;
import org.springframework.mock.http.server.reactive.MockServerHttpRequest;
import org.springframework.mock.web.server.MockServerWebExchange;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.mockito.Mockito.*;

/**
 * 认证过滤器测试
 */
@SpringBootTest
class AuthenticationFilterTest {
    
    private AuthenticationFilter authenticationFilter;
    private GatewayFilterChain filterChain;
    
    @BeEach
    void setUp() {
        authenticationFilter = new AuthenticationFilter();
        filterChain = mock(GatewayFilterChain.class);
    }
    
    @Test
    void testWhiteListPath() {
        // 准备测试数据
        MockServerHttpRequest request = MockServerHttpRequest
                .get("/api/auth/login")
                .build();
        ServerWebExchange exchange = MockServerWebExchange.from(request);
        
        when(filterChain.filter(exchange)).thenReturn(Mono.empty());
        
        // 执行测试
        Mono<Void> result = authenticationFilter.filter(exchange, filterChain);
        
        // 验证结果
        StepVerifier.create(result)
                .verifyComplete();
        
        verify(filterChain).filter(exchange);
    }
    
    @Test
    void testMissingAuthorizationHeader() {
        // 准备测试数据
        MockServerHttpRequest request = MockServerHttpRequest
                .get("/api/user/profile")
                .build();
        ServerWebExchange exchange = MockServerWebExchange.from(request);
        
        // 执行测试
        Mono<Void> result = authenticationFilter.filter(exchange, filterChain);
        
        // 验证结果
        StepVerifier.create(result)
                .verifyComplete();
        
        // 验证响应状态
        assert exchange.getResponse().getStatusCode() == HttpStatus.UNAUTHORIZED;
    }
    
    @Test
    void testValidToken() {
        // 准备测试数据
        MockServerHttpRequest request = MockServerHttpRequest
                .get("/api/user/profile")
                .header("Authorization", "Bearer valid.jwt.token")
                .build();
        ServerWebExchange exchange = MockServerWebExchange.from(request);
        
        when(filterChain.filter(any())).thenReturn(Mono.empty());
        
        // 执行测试
        Mono<Void> result = authenticationFilter.filter(exchange, filterChain);
        
        // 验证结果
        StepVerifier.create(result)
                .verifyComplete();
        
        verify(filterChain).filter(any());
    }
}
```

### 9.2 集成测试

```java
package com.example.gateway;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cloud.contract.wiremock.AutoConfigureWireMock;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.reactive.server.WebTestClient;

import static com.github.tomakehurst.wiremock.client.WireMock.*;

/**
 * Gateway 集成测试
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
@TestPropertySource(properties = {
        "spring.cloud.gateway.routes[0].id=user-service",
        "spring.cloud.gateway.routes[0].uri=http://localhost:${wiremock.server.port}",
        "spring.cloud.gateway.routes[0].predicates[0]=Path=/api/user/**",
        "spring.cloud.gateway.routes[0].filters[0]=StripPrefix=2"
})
class GatewayIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    void testUserServiceRouting() {
        // 配置 WireMock
        stubFor(get(urlEqualTo("/profile"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"id\":1,\"name\":\"John\"}"))
        );
        
        // 执行测试
        webTestClient.get()
                .uri("/api/user/profile")
                .header("Authorization", "Bearer valid.token")
                .exchange()
                .expectStatus().isOk()
                .expectHeader().contentType("application/json")
                .expectBody()
                .jsonPath("$.id").isEqualTo(1)
                .jsonPath("$.name").isEqualTo("John");
    }
    
    @Test
    void testRateLimiting() {
        // 配置 WireMock
        stubFor(get(urlEqualTo("/profile"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"id\":1,\"name\":\"John\"}"))
        );
        
        // 快速发送多个请求测试限流
        for (int i = 0; i < 25; i++) {
            webTestClient.get()
                    .uri("/api/user/profile")
                    .header("Authorization", "Bearer valid.token")
                    .exchange();
        }
        
        // 验证限流生效
        webTestClient.get()
                .uri("/api/user/profile")
                .header("Authorization", "Bearer valid.token")
                .exchange()
                .expectStatus().isEqualTo(429); // Too Many Requests
    }
}
```

## 10. 部署与运维

### 10.1 Docker 配置

```dockerfile
# Dockerfile
FROM openjdk:11-jre-slim

# 设置工作目录
WORKDIR /app

# 复制 jar 文件
COPY target/gateway-demo-1.0.0.jar app.jar

# 创建日志目录
RUN mkdir -p /var/log/gateway

# 设置 JVM 参数
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC -XX:+PrintGCDetails"

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 10.2 Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  gateway:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - EUREKA_SERVER=http://eureka:8761/eureka/
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - redis
      - eureka
    networks:
      - microservice-network
    volumes:
      - ./logs:/var/log/gateway
    restart: unless-stopped
  
  redis:
    image: redis:6.2-alpine
    ports:
      - "6379:6379"
    networks:
      - microservice-network
    restart: unless-stopped
  
  eureka:
    image: springcloud/eureka:latest
    ports:
      - "8761:8761"
    networks:
      - microservice-network
    restart: unless-stopped

networks:
  microservice-network:
    driver: bridge
```

### 10.3 Kubernetes 部署配置

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway-deployment
  labels:
    app: gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: gateway
  template:
    metadata:
      labels:
        app: gateway
    spec:
      containers:
      - name: gateway
        image: gateway-demo:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: EUREKA_SERVER
          value: "http://eureka-service:8761/eureka/"
        - name: REDIS_HOST
          value: "redis-service"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: gateway-service
spec:
  selector:
    app: gateway
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

## 11. 性能调优

### 11.1 JVM 调优参数

```bash
# 生产环境 JVM 参数
JAVA_OPTS="
-Xms2g 
-Xmx4g 
-XX:+UseG1GC 
-XX:MaxGCPauseMillis=200 
-XX:+UnlockExperimentalVMOptions 
-XX:+UseStringDeduplication 
-XX:+PrintGC 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-Xloggc:/var/log/gateway/gc.log 
-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=5 
-XX:GCLogFileSize=100M 
-Dspring.profiles.active=prod
"
```

### 11.2 Netty 调优配置

```yaml
spring:
  cloud:
    gateway:
      httpclient:
        # 连接池配置
        pool:
          type: elastic
          max-connections: 1000
          max-idle-time: 30s
          max-life-time: 60s
          acquire-timeout: 45s
        # 连接超时
        connect-timeout: 2000
        # 响应超时
        response-timeout: 30s
        # SSL 配置
        ssl:
          use-insecure-trust-manager: false
          trusted-x509-certificates:
            - /path/to/certificate.crt
      
      # Netty 配置
      netty:
        # 事件循环线程数
        event-loop-threads: 16
        # 工作线程数
        worker-threads: 32
```

## 12. 监控与告警

### 12.1 Prometheus 监控配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'gateway'
    static_configs:
      - targets: ['gateway:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 10s
```

### 12.2 Grafana 仪表板配置

```json
{
  "dashboard": {
    "title": "Spring Cloud Gateway Dashboard",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(gateway_requests_total[5m])",
            "legendFormat": "{{method}} {{path}}"
          }
        ]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(gateway_requests_duration_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(gateway_errors_total[5m])",
            "legendFormat": "{{status}}"
          }
        ]
      }
    ]
  }
}
```

## 总结

本指南详细介绍了 Spring Cloud Gateway 的使用方法，包括：

1. **项目搭建**：Maven 依赖配置和启动类设置
2. **路由配置**：YAML 和 Java 代码两种配置方式
3. **自定义过滤器**：全局过滤器、认证过滤器和自定义过滤器工厂
4. **限流配置**：基于 Redis 的限流实现和自定义限流算法
5. **熔断配置**：Resilience4J 熔断器配置和降级处理
6. **监控健康检查**：自定义健康检查和指标收集
7. **安全配置**：CORS 配置和安全头设置
8. **完整配置**：生产环境配置文件示例
9. **测试验证**：单元测试和集成测试
10. **部署运维**：Docker、Kubernetes 部署配置
11. **性能调优**：JVM 和 Netty 调优参数
12. **监控告警**：Prometheus 和 Grafana 配置

通过这些配置和代码示例，可以快速搭建一个功能完整、性能优良的 API 网关服务。在实际使用中，需要根据具体的业务需求和环境特点进行相应的调整和优化。置
```yaml
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true
    instance-id: ${spring.application.name}:${server.port}

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always
    gateway:
      enabled: true

# 日志配置
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.web.reactive: DEBUG
    reactor.netty: DEBUG
```

### 2.2 Java 配置方式

```java
package com.example.gateway.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;

/**
 * 路由配置类
 * 使用 Java 代码方式配置路由规则
 */
@Configuration
public class GatewayRouteConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                // 基础路由配置
                .route("user-service", r -> r
                        .path("/api/user/**")
                        .and()
                        .method(HttpMethod.GET, HttpMethod.POST)
                        .uri("lb://user-service")
                        .filters(f -> f
                                .stripPrefix(2)
                                .addRequestHeader("X-Request-Source", "gateway")
                                .addResponseHeader("X-Response-Time", String.valueOf(System.currentTimeMillis()))
                        )
                )
                
                // 带条件的路由
                .route("order-service-vip", r -> r
                        .path("/api/order/**")
                        .and()
                        .header("X-User-Type", "VIP")
                        .uri("lb://order-service-vip")
                        .filters(f -> f
                                .stripPrefix(2)
                                .addRequestHeader("X-Priority", "HIGH")
                        )
                )
                
                // 时间条件路由
                .route("promotion-service", r -> r
                        .path("/api/promotion/**")
                        .and()
                        .between(
                                java.time.ZonedDateTime.now(),
                                java.time.ZonedDateTime.now().plusDays(7)
                        )
                        .uri("lb://promotion-service")
                        .filters(f -> f.stripPrefix(2))
                )
                
                // Cookie 条件路由
                .route("mobile-service", r -> r
                        .path("/api/**")
                        .and()
                        .cookie("device", "mobile")
                        .uri("lb://mobile-service")
                        .filters(f -> f.stripPrefix(1))
                )
                
                // 查询参数条件路由
                .route("beta-service", r -> r
                        .path("/api/**")
                        .and()
                        .query("version", "beta")
                        .uri("lb://beta-service")
                        .filters(f -> f
                                .stripPrefix(1)
                                .addRequestHeader("X-Beta-User", "true")
                        )
                )
                
                .build();
    }
}
```

## 3. 自定义过滤器

### 3.1 全局过滤器

```java
package com.example.gateway.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * 全局请求日志过滤器
 * 记录所有请求的基本信息和响应时间
 */
@Slf4j
@Component
public class GlobalLoggingFilter implements GlobalFilter, Ordered {
    
    private static final String START_TIME = "startTime";
    private static final String REQUEST_ID = "requestId";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();
        
        // 生成请求ID
        String requestId = UUID.randomUUID().toString();
        exchange.getAttributes().put(REQUEST_ID, requestId);
        
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        exchange.getAttributes().put(START_TIME, startTime);
        
        // 添加请求ID到响应头
        response.getHeaders().add("X-Request-Id", requestId);
        
        log.info("[{}] Request started: {} {} from {}", 
                requestId, 
                request.getMethod(), 
                request.getURI(), 
                request.getRemoteAddress());
        
        return chain.filter(exchange).then(
                Mono.fromRunnable(() -> {
                    Long start = exchange.getAttribute(START_TIME);
                    if (start != null) {
                        long duration = System.currentTimeMillis() - start;
                        log.info("[{}] Request completed: {} {} - Status: {} - Duration: {}ms",
                                requestId,
                                request.getMethod(),
                                request.getURI(),
                                response.getStatusCode(),
                                duration);
                    }
                })
        );
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

### 3.2 认证过滤器

```java
package com.example.gateway.filter;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * JWT 认证过滤器
 * 验证请求中的 JWT Token
 */
@Slf4j
@Component
public class AuthenticationFilter implements GlobalFilter, Ordered {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    // 白名单路径，不需要认证
    private final List<String> whiteList = Arrays.asList(
            "/api/auth/login",
            "/api/auth/register",
            "/api/health",
            "/actuator/**",
            "/static/**"
    );
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();
        
        // 检查是否在白名单中
        if (isWhiteListed(path)) {
            return chain.filter(exchange);
        }
        
        // 获取 Authorization 头
        String authHeader = request.getHeaders().getFirst("Authorization");
        
        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
            return handleUnauthorized(exchange, "Missing or invalid Authorization header");
        }
        
        String token = authHeader.substring(7);
        
        // 验证 Token（这里简化处理，实际应该调用认证服务）
        if (!isValidToken(token)) {
            return handleUnauthorized(exchange, "Invalid token");
        }
        
        // 从 Token 中提取用户信息并添加到请求头
        String userId = extractUserIdFromToken(token);
        String userRole = extractUserRoleFromToken(token);
        
        ServerHttpRequest mutatedRequest = request.mutate()
                .header("X-User-Id", userId)
                .header("X-User-Role", userRole)
                .build();
        
        return chain.filter(exchange.mutate().request(mutatedRequest).build());
    }
    
    /**
     * 检查路径是否在白名单中
     */
    private boolean isWhiteListed(String path) {
        return whiteList.stream().anyMatch(pattern -> {
            if (pattern.endsWith("/**")) {
                return path.startsWith(pattern.substring(0, pattern.length() - 3));
            }
            return path.equals(pattern);
        });
    }
    
    /**
     * 验证 Token（简化实现）
     */
    private boolean isValidToken(String token) {
        // 实际实现中应该:
        // 1. 验证 JWT 签名
        // 2. 检查过期时间
        // 3. 验证 Token 格式
        // 4. 可能需要调用认证服务验证
        
        try {
            // 这里只是简单检查 Token 格式
            return token.length() > 10 && token.contains(".");
        } catch (Exception e) {
            log.error("Token validation error", e);
            return false;
        }
    }
    
    /**
     * 从 Token 中提取用户ID（简化实现）
     */
    private String extractUserIdFromToken(String token) {
        // 实际实现中应该解析 JWT payload
        return "user123"; // 模拟返回
    }
    
    /**
     * 从 Token 中提取用户角色（简化实现）
     */
    private String extractUserRoleFromToken(String token) {
        // 实际实现中应该解析 JWT payload
        return "USER"; // 模拟返回
    }
    
    /**
     * 处理未授权请求
     */
    private Mono<Void> handleUnauthorized(ServerWebExchange exchange, String message) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        response.getHeaders().add("Content-Type", MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 401);
        result.put("message", message);
        result.put("timestamp", System.currentTimeMillis());
        
        try {
            String body = objectMapper.writeValueAsString(result);
            DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));
            return response.writeWith(Mono.just(buffer));
        } catch (JsonProcessingException e) {
            log.error("Error writing unauthorized response", e);
            return response.setComplete();
        }
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE + 1;
    }
}
```

### 3.3 自定义 GatewayFilter

```java
package com.example.gateway.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.List;

/**
 * 自定义请求头过滤器工厂
 * 可以通过配置添加自定义请求头
 */
@Slf4j
@Component
public class CustomHeaderGatewayFilterFactory 
        extends AbstractGatewayFilterFactory<CustomHeaderGatewayFilterFactory.Config> {
    
    public CustomHeaderGatewayFilterFactory() {
        super(Config.class);
    }
    
    @Override
    public List<String> shortcutFieldOrder() {
        return Arrays.asList("headerName", "headerValue");
    }
    
    @Override
    public GatewayFilter apply(Config config) {
        return new GatewayFilter() {
            @Override
            public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                ServerHttpRequest request = exchange.getRequest().mutate()
                        .header(config.getHeaderName(), config.getHeaderValue())
                        .build();
                
                log.debug("Added custom header: {} = {}", 
                        config.getHeaderName(), config.getHeaderValue());
                
                return chain.filter(exchange.mutate().request(request).build());
            }
        };
    }
    
    /**
     * 配置类
     */
    public static class Config {
        private String headerName;
        private String headerValue;
        
        public String getHeaderName() {
            return headerName;
        }
        
        public void setHeaderName(String headerName) {
            this.headerName = headerName;
        }
        
        public String getHeaderValue() {
            return headerValue;
        }
        
        public void setHeaderValue(String headerValue) {
            this.headerValue = headerValue;
        }
    }
}
```

## 4. 限流配置

### 4.1 限流键解析器

```java
package com.example.gateway.config;

import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import reactor.core.publisher.Mono;

import java.util.Objects;

/**
 * 限流键解析器配置
 * 定义不同的限流策略
 */
@Configuration
public class RateLimitConfig {
    
    /**
     * 基于 IP 地址的限流
     */
    @Bean
    @Primary
    public KeyResolver ipKeyResolver() {
        return exchange -> {
            String clientIp = exchange.getRequest().getRemoteAddress() != null ?
                    Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress() :
                    "unknown";
            return Mono.just(clientIp);
        };
    }
    
    /**
     * 基于用户ID的限流
     */
    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> {
            String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
            return Mono.just(userId != null ? userId : "anonymous");
        };
    }
    
    /**
     * 基于 API 路径的限流
     */
    @Bean
    public KeyResolver apiKeyResolver() {
        return exchange -> {
            String path = exchange.getRequest().getURI().getPath();
            return Mono.just(path);
        };
    }
    
    /**
     * 组合限流键（IP + 用户ID）
     */
    @Bean
    public KeyResolver compositeKeyResolver() {
        return exchange -> {
            String clientIp = exchange.getRequest().getRemoteAddress() != null ?
                    Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress() :
                    "unknown";
            String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
            String key = clientIp + ":" + (userId != null ? userId : "anonymous");
            return Mono.just(key);
        };
    }
}
```

### 4.2 自定义限流过滤器

```java
package com.example.gateway.filter;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 自定义滑动窗口限流过滤器
 * 基于 Redis 实现滑动窗口限流算法
 */
@Slf4j
@Component
public class SlidingWindowRateLimitGatewayFilterFactory 
        extends AbstractGatewayFilterFactory<SlidingWindowRateLimitGatewayFilterFactory.Config> {
    
    @Autowired
    private ReactiveStringRedisTemplate redisTemplate;
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    // Lua 脚本实现滑动窗口限流
    private static final String SLIDING_WINDOW_SCRIPT = 
            "local key = KEYS[1]\n" +
            "local window = tonumber(ARGV[1])\n" +
            "local limit = tonumber(ARGV[2])\n" +
            "local current = tonumber(ARGV[3])\n" +
            "\n" +
            "-- 清理过期的记录\n" +
            "redis.call('zremrangebyscore', key, '-inf', current - window * 1000)\n" +
            "\n" +
            "-- 获取当前窗口内的请求数\n" +
            "local count = redis.call('zcard', key)\n" +
            "\n" +
            "if count < limit then\n" +
            "    -- 添加当前请求\n" +
            "    redis.call('zadd', key, current, current)\n" +
            "    redis.call('expire', key, window + 1)\n" +
            "    return {1, limit - count - 1}\n" +
            "else\n" +
            "    return {0, 0}\n" +
            "end";
    
    public SlidingWindowRateLimitGatewayFilterFactory() {
        super(Config.class);
    }
    
    @Override
    public List<String> shortcutFieldOrder() {
        return Arrays.asList("limit", "windowSize", "keyResolver");
    }
    
    @Override
    public GatewayFilter apply(Config config) {
        return new GatewayFilter() {
            @Override
            public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                return resolveKey(exchange, config.getKeyResolver())
                        .flatMap(key -> checkRateLimit(key, config))
                        .flatMap(allowed -> {
                            if (allowed) {
                                return chain.filter(exchange);
                            } else {
                                return handleRateLimitExceeded(exchange);
                            }
                        });
            }
        };
    }
    
    /**
     * 解析限流键
     */
    private Mono<String> resolveKey(ServerWebExchange exchange, String keyResolver) {
        switch (keyResolver) {
            case "ip":
                String clientIp = exchange.getRequest().getRemoteAddress() != null ?
                        exchange.getRequest().getRemoteAddress().getAddress().getHostAddress() :
                        "unknown";
                return Mono.just("rate_limit:ip:" + clientIp);
            case "user":
                String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
                return Mono.just("rate_limit:user:" + (userId != null ? userId : "anonymous"));
            case "api":
                String path = exchange.getRequest().getURI().getPath();
                return Mono.just("rate_limit:api:" + path);
            default:
                return Mono.just("rate_limit:default");
        }
    }
    
    /**
     * 检查限流
     */
    private Mono<Boolean> checkRateLimit(String key, Config config) {
        long currentTime = System.currentTimeMillis();
        
        RedisScript<List> script = RedisScript.of(SLIDING_WINDOW_SCRIPT, List.class);
        
        return redisTemplate.execute(script, 
                        Arrays.asList(key),
                        String.valueOf(config.getWindowSize()),
                        String.valueOf(config.getLimit()),
                        String.valueOf(currentTime))
                .cast(List.class)
                .map(result -> {
                    Long allowed = (Long) result.get(0);
                    Long remaining = (Long) result.get(1);
                    
                    log.debug("Rate limit check for key {}: allowed={}, remaining={}", 
                            key, allowed, remaining);
                    
                    return allowed == 1;
                })
                .onErrorReturn(false);
    }
    
    /**
     * 处理限流超出
     */
    private Mono<Void> handleRateLimitExceeded(ServerWebExchange exchange) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        response.getHeaders().add("Content-Type", MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 429);
        result.put("message", "Too many requests");
        result.put("timestamp", System.currentTimeMillis());
        
        try {
            String body = objectMapper.writeValueAsString(result);
            DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));
            return response.writeWith(Mono.just(buffer));
        } catch (JsonProcessingException e) {
            log.error("Error writing rate limit response", e);
            return response.setComplete();
        }
    }
    
    /**
     * 配置类
     */
    public static class Config {
        private int limit = 10;           // 限流次数
        private int windowSize = 60;      // 窗口大小（秒）
        private String keyResolver = "ip"; // 键解析器类型
        
        // Getters and Setters
        public int getLimit() {
            return limit;
        }
        
        public void setLimit(int limit) {
            this.limit = limit;
        }
        
        public int getWindowSize() {
            return windowSize;
        }
        
        public void setWindowSize(int windowSize) {
            this.windowSize = windowSize;
        }
        
        public String getKeyResolver() {
            return keyResolver;
        }
        
        public void setKeyResolver(String keyResolver) {
            this.keyResolver = keyResolver;
        }
    }
}
```

## 5. 熔断配置

### 5.1 熔断器配置

```java
package com.example.gateway.config;

import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.timelimiter.TimeLimiterConfig;
import org.springframework.cloud.circuitbreaker.resilience4j.ReactiveResilience4JCircuitBreakerFactory;
import org.springframework.cloud.circuitbreaker.resilience4j.Resilience4JConfigBuilder;
import org.springframework.cloud.client.circuitbreaker.Customizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

/**
 * 熔断器配置
 */
@Configuration
public class CircuitBreakerConfiguration {
    
    /**
     * 默认熔断器配置
     */
    @Bean
    public Customizer<ReactiveResilience4JCircuitBreakerFactory> defaultCustomizer() {
        return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
                .circuitBreakerConfig(CircuitBreakerConfig.custom()
                        .slidingWindowSize(10)                    // 滑动窗口大小
                        .minimumNumberOfCalls(5)                  // 最小调用次数
                        .failureRateThreshold(50)                 // 失败率阈值 50%
                        .waitDurationInOpenState(Duration.ofSeconds(30)) // 熔断器打开状态等待时间
                        .permittedNumberOfCallsInHalfOpenState(3) // 半开状态允许的调用次数
                        .automaticTransitionFromOpenToHalfOpenEnabled(true) // 自动从打开状态转换到半开状态
                        .build())
                .timeLimiterConfig(TimeLimiterConfig.custom()
                        .timeoutDuration(Duration.ofSeconds(5))    // 超时时间
                        .build())
                .build());
    }
    
    /**
     * 支付服务专用熔断器配置
     */
    @Bean
    public Customizer<ReactiveResilience4JCircuitBreakerFactory> paymentServiceCustomizer() {
        return factory -> factory.configure(builder -> builder
                .circuitBreakerConfig(CircuitBreakerConfig.custom()
                        .slidingWindowSize(20)
                        .minimumNumberOfCalls(10)
                        .failureRateThreshold(30)  // 支付服务更严格的失败率阈值
                        .waitDurationInOpenState(Duration.ofSeconds(60))
                        .permittedNumberOfCallsInHalfOpenState(5)
                        .build())
                .timeLimiterConfig(TimeLimiterConfig.custom()
                        .timeoutDuration(Duration.ofSeconds(10)) // 支付服务更长的超时时间
                        .build()), "payment-circuit-breaker");
    }
}
```

### 5.2 降级处理器

```java
package com.example.gateway.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.Map;

/**
 * 降级处理控制器
 * 当服务熔断时返回降级响应
 */
@Slf4j
@RestController
@RequestMapping("/fallback")
public class FallbackController {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * 支付服务降级处理
     */
    @PostMapping("/payment")
    public Mono<ResponseEntity<String>> paymentFallback() {
        log.warn("Payment service is unavailable, returning fallback response");
        
        Map<String, Object> response = new HashMap<>();
        response.put("code", 503);
        response.put("message", "支付服务暂时不可用，请稍后重试");
        response.put("data", null);
        response.put("timestamp", System.currentTimeMillis());
        
        try {
            String json = objectMapper.writeValueAsString(response);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.SERVICE_UNAVAILABLE)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(json));
        } catch (JsonProcessingException e) {
            log.error("Error creating fallback response", e);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("{\"error\":\"Internal server error\"}"));
        }
    }
    
    /**
     * 用户服务降级处理
     */
    @GetMapping("/user")
    public Mono<ResponseEntity<String>> userFallback() {
        log.warn("User service is unavailable, returning fallback response");
        
        Map<String, Object> response = new HashMap<>();
        response.put("code", 503);
        response.put("message", "用户服务暂时不可用");
        response.put("data", createDefaultUserData());
        response.put("timestamp", System.currentTimeMillis());
        
        try {
            String json = objectMapper.writeValueAsString(response);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.OK) // 用户服务可以返回默认数据
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(json));
        } catch (JsonProcessingException e) {
            log.error("Error creating user fallback response", e);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("{\"error\":\"Internal server error\"}"));
        }
    }
    
    /**
     * 订单服务降级处理
     */
    @GetMapping("/order")
    public Mono<ResponseEntity<String>> orderFallback() {
        log.warn("Order service is unavailable, returning fallback response");
        
        Map<String, Object> response = new HashMap<>();
        response.put("code", 503);
        response.put("message", "订单服务暂时不可用，请稍后查询");
        response.put("data", null);
        response.put("timestamp", System.currentTimeMillis());
        
        try {
            String json = objectMapper.writeValueAsString(response);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.SERVICE_UNAVAILABLE)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(json));
        } catch (JsonProcessingException e) {
            log.error("Error creating order fallback response", e);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("{\"error\":\"Internal server error\"}"));
        }
    }
    
    /**
     * 通用降级处理
     */
    @GetMapping("/default")
    public Mono<ResponseEntity<String>> defaultFallback() {
        log.warn("Service is unavailable, returning default fallback response");
        
        Map<String, Object> response = new HashMap<>();
        response.put("code", 503);
        response.put("message", "服务暂时不可用，请稍后重试");
        response.put("timestamp", System.currentTimeMillis());
        
        try {
            String json = objectMapper.writeValueAsString(response);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.SERVICE_UNAVAILABLE)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(json));
        } catch (JsonProcessingException e) {
            log.error("Error creating default fallback response", e);
            return Mono.just(ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("{\"error\":\"Internal server error\"}"));
        }
    }
    
    /**
     * 创建默认用户数据
     */
    private Map<String, Object> createDefaultUserData() {
        Map<String, Object> userData = new HashMap<>();
        userData.put("id", "guest");
        userData.put("name", "访客用户");
        userData.put("avatar", "/static/default-avatar.png");
        userData.put("level", "guest");
        return userData;
    }
}
```

## 6. 监控与健康检查

### 6.1 自定义健康检查

```java
package com.example.gateway.health;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuator.health.Health;
import org.springframework.boot.actuator.health.HealthIndicator;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

/**
 * Gateway 自定义健康检查
 */
@Slf4j
@Component
public class GatewayHealthIndicator implements HealthIndicator {
    
    @Autowired
    private RouteLocator routeLocator;
    
    @Autowired
    private ReactiveStringRedisTemplate redisTemplate;
    
    @Override
    public Health health() {
        try {
            Map<String, Object> details = new HashMap<>();
            
            // 检查路由数量
            long routeCount = routeLocator.getRoutes().count().block(Duration.ofSeconds(5));
            details.put("routeCount", routeCount);
            
            // 检查 Redis 连接
            boolean redisHealthy = checkRedisHealth();
            details.put("redisHealthy", redisHealthy);
            
            // 检查内存使用情况
            Runtime runtime = Runtime.getRuntime();
            long totalMemory = runtime.totalMemory();
            long freeMemory = runtime.freeMemory();
            long usedMemory = totalMemory - freeMemory;
            double memoryUsagePercent = (double) usedMemory / totalMemory * 100;
            
            details.put("memoryUsage", String.format("%.2f%%", memoryUsagePercent));
            details.put("totalMemory", totalMemory / 1024 / 1024 + "MB");
            details.put("usedMemory", usedMemory / 1024 / 1024 + "MB");
            
            // 判断整体健康状态
            if (routeCount > 0 && redisHealthy && memoryUsagePercent < 90) {
                return Health.up().withDetails(details).build();
            } else {
                return Health.down().withDetails(details).build();
            }
            
        } catch (Exception e) {
            log.error("Health check failed", e);
            return Health.down().withException(e).build();
        }
    }
    
    /**
     * 检查 Redis 健康状态
     */
    private boolean checkRedisHealth() {
        try {
            String result = redisTemplate.opsForValue()
                    .get("health:check")
                    .timeout(Duration.ofSeconds(2))
                    .onErrorReturn("error")
                    .block();
            return !"error".equals(result);
        } catch (Exception e) {
            log.warn("Redis health check failed", e);
            return false;
        }
    }
}
```

### 6.2 自定义指标收集

```java
package com.example.gateway.metrics;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.concurrent.TimeUnit;

/**
 * Gateway 指标收集过滤器
 */
@Slf4j
@Component
public class MetricsCollectorFilter implements GlobalFilter, Ordered {
    
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer requestTimer;
    
    public MetricsCollectorFilter(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.requestCounter = Counter.builder("gateway.requests.total")
                .description("Total number of requests")
                .register(meterRegistry);
        this.requestTimer = Timer.builder("gateway.requests.duration")
                .description("Request duration")
                .register(meterRegistry);
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        long startTime = System.nanoTime();
        
        return chain.filter(exchange)
                .doFinally(signalType -> {
                    long duration = System.nanoTime() - startTime;
                    ServerHttpResponse response = exchange.getResponse();
                    
                    // 记录请求计数
                    requestCounter.increment(
                            "method", request.getMethod().name(),
                            "status", String.valueOf(response.getStatusCode().value()),
                            "path", getPathPattern(request.getURI().getPath())
                    );
                    
                    // 记录请求耗时
                    requestTimer.record(duration, TimeUnit.NANOSECONDS,
                            "method", request.getMethod().name(),
                            "status", String.valueOf(response.getStatusCode().value()),
                            "path", getPathPattern(request.getURI().getPath())
                    );
                    
                    // 记录错误率
                    if (response.getStatusCode().is5xxServerError()) {
                        Counter.builder("gateway.errors.total")
                                .description("Total number of errors")
                                .tag("status", String.valueOf(response.getStatusCode().value()))
                                .tag("path", getPathPattern(request.getURI().getPath()))
                                .register(meterRegistry)
                                .increment();
                    }
                });
    }
    
    /**
     * 获取路径模式（用于指标聚合）
     */
    private String getPathPattern(String path) {
        if (path.startsWith("/api/user/")) {
            return "/api/user/**";
        } else if (path.startsWith("/api/order/")) {
            return "/api/order/**";
        } else if (path.startsWith("/api/product/")) {
            return "/api/product/**";
        } else if (path.startsWith("/api/payment/")) {
            return "/api/payment/**";
        } else {
            return path;
        }
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE + 2;
    }
}
```

## 7. 安全配置

### 7.1 CORS 配置

```java
package com.example.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

/**
 * CORS 跨域配置
 */
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration corsConfig = new CorsConfiguration();
        
        // 允许的源
        corsConfig.setAllowedOriginPatterns(Arrays.asList(
                "http://localhost:*",
                "https://*.example.com",
                "https://example.com"
        ));
        
        // 允许的方法
        corsConfig.setAllowedMethods(Arrays.asList(
                "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"
        ));
        
        // 允许的头
        corsConfig.setAllowedHeaders(Arrays.asList(
                "*"
        ));
        
        // 允许携带凭证
        corsConfig.setAllowCredentials(true);
        
        // 预检请求缓存时间
        corsConfig.setMaxAge(3600L);
        
        // 暴露的头
        corsConfig.setExposedHeaders(Arrays.asList(
                "X-Request-Id",
                "X-Response-Time"
        ));
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfig);
        
        return new CorsWebFilter(source);
    }
}
```

### 7.2 安全头过滤器

```java
package com.example.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * 安全头过滤器
 * 添加安全相关的 HTTP 头
 */
@Component
public class SecurityHeadersFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return chain.filter(exchange).then(
                Mono.fromRunnable(() -> {
                    ServerHttpResponse response = exchange.getResponse();
                    
                    // 防止点击劫持
                    response.getHeaders().add("X-Frame-Options", "DENY");
                    
                    // 防止 MIME 类型嗅探
                    response.getHeaders().add("X-Content-Type-Options", "nosniff");
                    
                    // XSS 保护
                    response.getHeaders().add("X-XSS-Protection", "1; mode=block");
                    
                    // 严格传输安全
                    response.getHeaders().add("Strict-Transport-Security", 
                            "max-age=31536000; includeSubDomains");
                    
                    // 内容安全策略
                    response.getHeaders().add("Content-Security-Policy", 
                            "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'");
                    
                    // 引用策略
                    response.getHeaders().add("Referrer-Policy", "strict-origin-when-cross-origin");
                    
                    // 权限策略
                    response.getHeaders().add("Permissions-Policy", 
                            "geolocation=(), microphone=(), camera=()");
                })
        );
    }
    
    @Override
    public int getOrder() {
        return Ordered.LOWEST_PRECEDENCE;
    }
}
```

## 8. 完整的应用配置文件

### 8.1 application.yml

```yaml
server:
  port: 8080
  netty:
    connection-timeout: 2s
    idle-timeout: 15s

spring:
  application:
    name: api-gateway
  
  profiles:
    active: dev
  
  cloud:
    gateway:
      # 发现定位器配置
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
          filters:
            - StripPrefix=1
      
      # 全局过滤器配置
      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin
        - AddResponseHeader=X-Response-Default-Foo, Default-Bar
      
      # 路由配置
      routes:
        # 用户服务
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                key-resolver: "#{@ipKeyResolver}"
            - name: CircuitBreaker
              args:
                name: user-circuit-breaker
                fallbackUri: forward:/fallback/user
        
        # 订单服务
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/order/**
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 5
                redis-rate-limiter.burstCapacity: 10
                key-resolver: "#{@userKeyResolver}"
            - name: CircuitBreaker
              args:
                name: order-circuit-breaker
                fallbackUri: forward:/fallback/order
        
        # 支付服务
        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payment/**
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 2
                redis-rate-limiter.burstCapacity: 5
                key-resolver: "#{@userKeyResolver}"
            - name: CircuitBreaker
              args:
                name: payment-circuit-breaker
                fallbackUri: forward:/fallback/payment
        
        # 商品服务
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/product/**
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 20
                redis-rate-limiter.burstCapacity: 50
                key-resolver: "#{@ipKeyResolver}"
  
  # Redis 配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: 0
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
  
  # 安全配置
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${JWT_ISSUER_URI:http://localhost:8081/auth/realms/gateway}

# Eureka 配