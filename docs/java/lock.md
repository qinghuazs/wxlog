---
title: 锁
date: 2024/10/26
permalink: /docs/java/lock/
categories:
  - Java
  - Technology
---

`ReentrantLock` 和 `synchronized` 都是Java中用于实现线程同步的手段，它们都可以保证在同一时刻最多只有一个线程可以访问某个特定资源。不过，它们之间还是存在一些差异的：

1. **锁的实现方式**：
   - `synchronized` 是一种内置的语言关键字，它的锁是非公平的，并且无法明确地获取锁的持有情况。
   - `ReentrantLock` 是 `java.util.concurrent.locks` 包下的一个类，它是显式的锁。需要用户手动获取和释放锁。
2. **锁的公平性**：
   - `synchronized` 默认是非公平锁，它不保证等待时间最长的线程会首先获得锁。
   - `ReentrantLock` 可以是公平的也可以是非公平的，取决于在创建 `ReentrantLock` 对象时的参数设置。
3. **锁的尝试**：
   - `synchronized` 不支持尝试获取锁的操作，一旦获取不到锁，线程将会被阻塞。
   - `ReentrantLock` 支持尝试获取锁（`tryLock()` 方法），如果获取不到锁，线程可以不用阻塞，而是执行其他操作。
4. **锁的中断**：
   - `synchronized` 不能响应中断，一个线程在获取不到锁时，如果被中断，它依然会在锁释放后继续获取锁。
   - `ReentrantLock` 可以响应中断，当尝试获取锁的线程在等待时被中断，它会抛出 `InterruptedException`，可以由调用者决定如何处理这个异常。
5. **条件变量**：
   - `synchronized` 可以使用条件变量（通过 `Object` 的 `wait()`, `notify()`, `notifyAll()` 方法），但需要手动控制条件变量的逻辑。
   - `ReentrantLock` 提供了更灵活的条件变量支持（`Condition` 接口），可以有多个条件变量，并且自动处理条件变量的线程唤醒。
6. **锁的可重入性**：
   - `synchronized` 是可重入的，同一个线程可以多次获取同一个锁。
   - `ReentrantLock` 也是可重入的，它的名字（Reentrant）本身就表明了这个特性。
7. **性能**：
   - 在JDK 5之前，`synchronized` 的性能通常比使用 `ReentrantLock` 差，因为它依赖于操作系统的互斥锁来实现，涉及到用户态和内核态的切换。
   - 从JDK 6开始，引入了轻量级锁和偏向锁，优化了 `synchronized` 的性能，使得其在很多场景下性能接近甚至优于 `ReentrantLock`。
8. **使用场景**：
   - 对于简单的同步需求，使用 `synchronized` 可能更简单，因为它不需要显式地获取和释放锁。
   - 对于更复杂的同步需求，比如需要尝试获取锁、可中断的锁获取、超时获取锁等，`ReentrantLock` 提供了更多的灵活性。

总的来说，`ReentrantLock` 提供了比 `synchronized` 更多的控制和灵活性，但同时也要求使用者正确地管理锁的获取和释放，否则可能会造成死锁或资源泄露。而 `synchronized` 使用起来更简单，但在需要复杂锁控制的场景下可能不够用。

## synchronized

### 锁升级

锁的状态从低到高分别是：无锁、偏向锁、轻量级锁和重量级锁。

1. **偏向锁**：当一个线程第一次访问同步代码块时，JVM会在这个线程的栈帧中创建一个锁记录（Lock Record），并将对象头中的Mark Word复制到锁记录中。如果这个线程再次访问同步代码块，并且对象的Mark Word没有变化，说明没有其他线程竞争锁，那么这个线程就可以直接获取到锁，而不需要进行任何同步操作。这种状态下，锁是非公平的，因为它偏向于第一个获取它的线程。
2. **轻量级锁**：如果存在多个线程竞争同一个锁，JVM会将锁升级为轻量级锁。在轻量级锁状态下，JVM会使用CAS（Compare-And-Swap）操作尝试获取锁。如果CAS操作成功，线程就可以获取到锁；如果失败，说明有其他线程竞争，JVM会让当前线程自旋等待一段时间，再次尝试获取锁。
3. **重量级锁**：如果自旋等待一定次数后仍然无法获取锁，或者有第三个线程尝试获取锁，JVM会将轻量级锁升级为重量级锁。在重量级锁状态下，JVM会将竞争失败的线程阻塞，避免它们无休止地自旋等待，从而浪费CPU资源。当持有锁的线程释放锁后，JVM会唤醒被阻塞的线程，让它们再次尝试获取锁。

锁升级的过程是自动的，JVM会根据线程竞争的情况动态地在不同锁状态之间进行转换，以减少获取锁的成本，提高程序的并发性能。这种锁升级机制使得`synchronized`在面对不同竞争程度的场景时，都能保持较高的性能。

需要注意的是，从Java 9开始，偏向锁被默认关闭，因为现代CPU的快速发展使得获取锁的成本降低，而偏向锁的撤销和升级操作带来的开销可能超过了其带来的性能提升。因此，在Java 9及以后的版本中，锁通常直接从无锁状态升级到轻量级锁，然后根据需要升级到重量级锁。

### 轻量级锁的自旋

轻量级锁的自旋（Spinning）机制是指当一个线程尝试获取一个已经被其他线程持有的轻量级锁时，它不会立即阻塞，而是在一定时间内进行循环等待，也就是自旋，以期望持有锁的线程能够尽快释放锁。这种机制可以减少线程上下文切换的开销，特别是在锁被持有时间很短的情况下，自旋可以提高程序的整体性能。

轻量级锁的自旋过程大致如下：

1. **锁请求**：当一个线程尝试获取一个对象的锁时，如果该对象的锁状态为轻量级锁，JVM会首先在当前线程的栈帧中创建一个名为锁记录（Lock Record）的空间。
2. **拷贝Mark Word**：JVM会尝试拷贝对象头中的Mark Word到刚刚创建的锁记录中。
3. **CAS操作**：如果拷贝成功，JVM会使用CAS操作尝试将对象头的Mark Word更新为指向锁记录的指针。如果这个CAS操作成功，那么线程就成功获取了轻量级锁。
4. **自旋等待**：如果CAS操作失败，说明有其他线程竞争锁，当前线程会进入自旋状态。在自旋状态下，线程会执行一段空循环，周期性地检查锁是否可用。这个过程中，线程不会进入阻塞状态，因此不会涉及到操作系统的线程调度。
5. **自旋次数**：自旋并不是无限期的。JVM会设定一个自旋次数的上限（JDK1.6 自旋的次数是可以通过 -XX:PreBlockSpin配置的，默认情况下是10次， JDK 1.7 之后不再支持用户配置，自旋次数由虚拟机自动调整），超过这个上限后，如果锁仍然没有被获取，轻量级锁可能会升级为重量级锁，然后线程会被阻塞。
6. **锁释放**：如果持有锁的线程释放了锁，那么自旋等待的线程可以再次尝试获取锁。如果成功，它将退出自旋状态并继续执行。如果失败，它将继续自旋。
7. **锁升级**：如果自旋一定次数后仍然无法获取锁，或者系统检测到有多于一个线程在自旋，可能会导致轻量级锁升级为重量级锁，竞争失败的线程将被操作系统挂起。

自旋的目的是为了避免线程在锁竞争不激烈的情况下进入阻塞状态，这样可以减少由于线程阻塞和唤醒而带来的开销。但是，自旋也会消耗CPU资源，因此JVM需要合理地设置自旋的次数，以平衡自旋带来的CPU消耗和线程阻塞的开销。在一些情况下，例如锁持有时间非常短，自旋可以显著提高性能；而在锁竞争激烈或者锁持有时间较长的情况下，自旋可能不会带来性能上的提升，甚至可能因为过多的CPU消耗而降低性能。

## ReentrantLock



## 公平锁和非公平锁

`ReentrantLock` 提供了公平锁（Fair）和非公平锁（Nonfair）两种模式，它们的主要区别在于线程获取锁的顺序.

### 公平锁（Fari）

公平锁是指多个线程按照申请锁的顺序来获取锁。如果一个线程获取了锁，那么其他线程必须等待，直到锁被释放。在释放锁之后，下一个按照顺序申请锁的线程将获得锁。

公平锁的优点是可以保证线程获取锁的顺序，避免饥饿现象（即某个线程长时间无法获取锁）。

公平锁的缺点是可能会牺牲一些性能，因为它需要维护一个等待队列来保持线程的顺序，这可能会增加锁的开销。

### 非公平锁（Nonfair）

非公平锁不保证线程获取锁的顺序。当一个线程尝试获取锁时，如果锁可用，它将立即获取锁，而不管其他线程已经等待了多长时间。

非公平锁的优点是它的性能通常比公平锁更好，因为它避免了维护等待队列的开销。

非公平锁的缺点是可能会导致饥饿现象，特别是如果有很多线程竞争同一个锁时，一些线程可能会长时间得不到执行。

在实际应用中，选择公平锁还是非公平锁取决于具体的应用场景和性能要求。如果系统中的线程数量不多，或者线程的执行时间比较短，使用非公平锁可能更合适，因为它可以提供更好的性能。但如果线程需要长时间执行，或者线程的数量很多，为了避免饥饿现象，可能需要使用公平锁。

在 `ReentrantLock` 中，默认情况下构造的是非公平锁。如果需要创建公平锁，可以在构造 `ReentrantLock` 对象时传递 `true` 作为参数：

```java
ReentrantLock fairLock = new ReentrantLock(true); // 公平锁
ReentrantLock nonFairLock = new ReentrantLock(false); // 非公平锁
```

如果未指定，`ReentrantLock` 默认为非公平锁。

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

