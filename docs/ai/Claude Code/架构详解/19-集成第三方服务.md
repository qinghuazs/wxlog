---
title: 集成第三方服务
date: 2025-01-13
permalink: /claudecode/architecture/third-party-integration.html
categories:
  - AI
  - Claude Code
---

# 集成第三方服务

## 1. 引言：第三方服务集成的价值

在现代软件开发中，第三方服务集成已成为提升开发效率的关键能力。Claude Code 通过 MCP（Model Context Protocol）机制，提供了强大的第三方服务集成能力，使 AI 助手能够无缝对接各类开发工具和云服务。

### 1.1 集成服务的价值

第三方服务集成为 Claude Code 带来了以下核心价值：

**开发效率提升**：通过集成 GitHub、Jira 等项目管理工具，AI 助手可以直接创建 Issue、提交 PR、更新任务状态，大幅减少开发者在工具间切换的时间成本。

**工作流自动化**：集成 Slack、Discord 等通讯工具，实现代码评审通知、构建状态推送等自动化流程，让团队协作更加高效。

**数据访问能力**：通过数据库连接，AI 助手可以查询生产数据、分析数据模式、生成数据迁移脚本，提供更精准的技术建议。

**云资源管理**：集成 AWS、Azure 等云服务，支持文件上传下载、资源配置查询等操作，实现基础设施即代码的智能化管理。

### 1.2 MCP 集成架构

Claude Code 的第三方服务集成基于 MCP 协议实现，采用标准化的工具调用接口：

```
┌─────────────────┐
│  Claude Model   │
└────────┬────────┘
         │
    ┌────▼─────┐
    │   MCP    │
    │ Protocol │
    └────┬─────┘
         │
    ┌────▼──────────────────────────┐
    │   Service Providers          │
    ├──────────────────────────────┤
    │ GitHub │ Jira │ Slack │ AWS  │
    └──────────────────────────────┘
```

通过统一的 MCP 接口，各类服务以插件形式接入，保证了架构的可扩展性和维护性。

## 2. GitHub API 集成

GitHub 是开发者最常用的代码托管平台，Claude Code 提供了全面的 GitHub API 集成能力。

### 2.1 GitHub REST API 使用

GitHub API 集成的核心是通过 Personal Access Token 进行身份认证，然后调用 REST API 完成各类操作。

#### 2.1.1 认证配置

```typescript
// github-service.ts
import { Octokit } from '@octokit/rest';

export class GitHubService {
  private octokit: Octokit;

  constructor(token: string) {
    this.octokit = new Octokit({
      auth: token,
      userAgent: 'claude-code-mcp/1.0.0',
      baseUrl: 'https://api.github.com',
      // 请求超时配置
      request: {
        timeout: 10000
      }
    });
  }

  /**
   * 验证 Token 有效性
   */
  async validateToken(): Promise<boolean> {
    try {
      await this.octokit.users.getAuthenticated();
      return true;
    } catch (error) {
      console.error('Token validation failed:', error);
      return false;
    }
  }
}
```

#### 2.1.2 仓库操作

```typescript
export class GitHubService {
  /**
   * 获取仓库信息
   */
  async getRepository(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.get({
        owner,
        repo
      });

      return {
        id: data.id,
        name: data.name,
        fullName: data.full_name,
        description: data.description,
        defaultBranch: data.default_branch,
        language: data.language,
        stars: data.stargazers_count,
        forks: data.forks_count,
        openIssues: data.open_issues_count,
        createdAt: data.created_at,
        updatedAt: data.updated_at
      };
    } catch (error) {
      throw new Error(`Failed to get repository: ${error.message}`);
    }
  }

  /**
   * 列出仓库分支
   */
  async listBranches(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.listBranches({
        owner,
        repo,
        per_page: 100
      });

      return data.map(branch => ({
        name: branch.name,
        commit: {
          sha: branch.commit.sha,
          url: branch.commit.url
        },
        protected: branch.protected
      }));
    } catch (error) {
      throw new Error(`Failed to list branches: ${error.message}`);
    }
  }

  /**
   * 创建分支
   */
  async createBranch(
    owner: string,
    repo: string,
    branchName: string,
    fromBranch: string
  ) {
    try {
      // 获取源分支的 SHA
      const { data: refData } = await this.octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${fromBranch}`
      });

      // 创建新分支
      const { data } = await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${branchName}`,
        sha: refData.object.sha
      });

      return {
        ref: data.ref,
        sha: data.object.sha
      };
    } catch (error) {
      throw new Error(`Failed to create branch: ${error.message}`);
    }
  }
}
```

### 2.2 Issues、PRs、Actions 管理

#### 2.2.1 Issue 管理

```typescript
export class GitHubService {
  /**
   * 创建 Issue
   */
  async createIssue(
    owner: string,
    repo: string,
    options: {
      title: string;
      body?: string;
      assignees?: string[];
      labels?: string[];
      milestone?: number;
    }
  ) {
    try {
      const { data } = await this.octokit.issues.create({
        owner,
        repo,
        ...options
      });

      return {
        number: data.number,
        id: data.id,
        title: data.title,
        state: data.state,
        url: data.html_url,
        createdAt: data.created_at
      };
    } catch (error) {
      throw new Error(`Failed to create issue: ${error.message}`);
    }
  }

  /**
   * 列出 Issues
   */
  async listIssues(
    owner: string,
    repo: string,
    options?: {
      state?: 'open' | 'closed' | 'all';
      labels?: string[];
      assignee?: string;
      since?: string;
    }
  ) {
    try {
      const { data } = await this.octokit.issues.listForRepo({
        owner,
        repo,
        state: options?.state || 'open',
        labels: options?.labels?.join(','),
        assignee: options?.assignee,
        since: options?.since,
        per_page: 100
      });

      return data.map(issue => ({
        number: issue.number,
        title: issue.title,
        state: issue.state,
        labels: issue.labels.map(l =>
          typeof l === 'string' ? l : l.name
        ),
        assignees: issue.assignees?.map(a => a.login) || [],
        createdAt: issue.created_at,
        updatedAt: issue.updated_at,
        url: issue.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list issues: ${error.message}`);
    }
  }

  /**
   * 更新 Issue
   */
  async updateIssue(
    owner: string,
    repo: string,
    issueNumber: number,
    options: {
      title?: string;
      body?: string;
      state?: 'open' | 'closed';
      labels?: string[];
      assignees?: string[];
    }
  ) {
    try {
      const { data } = await this.octokit.issues.update({
        owner,
        repo,
        issue_number: issueNumber,
        ...options
      });

      return {
        number: data.number,
        title: data.title,
        state: data.state,
        url: data.html_url
      };
    } catch (error) {
      throw new Error(`Failed to update issue: ${error.message}`);
    }
  }

  /**
   * 添加 Issue 评论
   */
  async addIssueComment(
    owner: string,
    repo: string,
    issueNumber: number,
    body: string
  ) {
    try {
      const { data } = await this.octokit.issues.createComment({
        owner,
        repo,
        issue_number: issueNumber,
        body
      });

      return {
        id: data.id,
        body: data.body,
        createdAt: data.created_at,
        url: data.html_url
      };
    } catch (error) {
      throw new Error(`Failed to add comment: ${error.message}`);
    }
  }
}
```

#### 2.2.2 Pull Request 管理

```typescript
export class GitHubService {
  /**
   * 创建 Pull Request
   */
  async createPullRequest(
    owner: string,
    repo: string,
    options: {
      title: string;
      head: string;
      base: string;
      body?: string;
      draft?: boolean;
      maintainerCanModify?: boolean;
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.create({
        owner,
        repo,
        ...options,
        maintainer_can_modify: options.maintainerCanModify
      });

      return {
        number: data.number,
        id: data.id,
        title: data.title,
        state: data.state,
        draft: data.draft,
        url: data.html_url,
        diffUrl: data.diff_url,
        patchUrl: data.patch_url
      };
    } catch (error) {
      throw new Error(`Failed to create PR: ${error.message}`);
    }
  }

  /**
   * 列出 Pull Requests
   */
  async listPullRequests(
    owner: string,
    repo: string,
    options?: {
      state?: 'open' | 'closed' | 'all';
      head?: string;
      base?: string;
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.list({
        owner,
        repo,
        state: options?.state || 'open',
        head: options?.head,
        base: options?.base,
        per_page: 100
      });

      return data.map(pr => ({
        number: pr.number,
        title: pr.title,
        state: pr.state,
        draft: pr.draft,
        head: pr.head.ref,
        base: pr.base.ref,
        createdAt: pr.created_at,
        updatedAt: pr.updated_at,
        url: pr.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list PRs: ${error.message}`);
    }
  }

  /**
   * 合并 Pull Request
   */
  async mergePullRequest(
    owner: string,
    repo: string,
    pullNumber: number,
    options?: {
      commitTitle?: string;
      commitMessage?: string;
      mergeMethod?: 'merge' | 'squash' | 'rebase';
    }
  ) {
    try {
      const { data } = await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number: pullNumber,
        commit_title: options?.commitTitle,
        commit_message: options?.commitMessage,
        merge_method: options?.mergeMethod || 'merge'
      });

      return {
        merged: data.merged,
        sha: data.sha,
        message: data.message
      };
    } catch (error) {
      throw new Error(`Failed to merge PR: ${error.message}`);
    }
  }

  /**
   * 请求 PR 评审
   */
  async requestReviewers(
    owner: string,
    repo: string,
    pullNumber: number,
    reviewers: string[],
    teamReviewers?: string[]
  ) {
    try {
      const { data } = await this.octokit.pulls.requestReviewers({
        owner,
        repo,
        pull_number: pullNumber,
        reviewers,
        team_reviewers: teamReviewers
      });

      return {
        requestedReviewers: data.requested_reviewers?.map(r => r.login) || [],
        requestedTeams: data.requested_teams?.map(t => t.name) || []
      };
    } catch (error) {
      throw new Error(`Failed to request reviewers: ${error.message}`);
    }
  }
}
```

#### 2.2.3 GitHub Actions 管理

```typescript
export class GitHubService {
  /**
   * 列出 Workflow Runs
   */
  async listWorkflowRuns(
    owner: string,
    repo: string,
    workflowId?: string | number
  ) {
    try {
      const params = workflowId
        ? { owner, repo, workflow_id: workflowId, per_page: 100 }
        : { owner, repo, per_page: 100 };

      const { data } = workflowId
        ? await this.octokit.actions.listWorkflowRuns(params)
        : await this.octokit.actions.listWorkflowRunsForRepo(params);

      return data.workflow_runs.map(run => ({
        id: run.id,
        name: run.name,
        headBranch: run.head_branch,
        status: run.status,
        conclusion: run.conclusion,
        createdAt: run.created_at,
        updatedAt: run.updated_at,
        url: run.html_url
      }));
    } catch (error) {
      throw new Error(`Failed to list workflow runs: ${error.message}`);
    }
  }

  /**
   * 触发 Workflow
   */
  async triggerWorkflow(
    owner: string,
    repo: string,
    workflowId: string | number,
    ref: string,
    inputs?: Record<string, any>
  ) {
    try {
      await this.octokit.actions.createWorkflowDispatch({
        owner,
        repo,
        workflow_id: workflowId,
        ref,
        inputs
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to trigger workflow: ${error.message}`);
    }
  }

  /**
   * 取消 Workflow Run
   */
  async cancelWorkflowRun(
    owner: string,
    repo: string,
    runId: number
  ) {
    try {
      await this.octokit.actions.cancelWorkflowRun({
        owner,
        repo,
        run_id: runId
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to cancel workflow: ${error.message}`);
    }
  }
}
```

### 2.3 MCP 工具封装

```typescript
// github-mcp-tools.ts
import { GitHubService } from './github-service';

export const githubTools = {
  github_create_issue: {
    description: 'Create a new GitHub issue',
    parameters: {
      type: 'object',
      properties: {
        owner: { type: 'string', description: 'Repository owner' },
        repo: { type: 'string', description: 'Repository name' },
        title: { type: 'string', description: 'Issue title' },
        body: { type: 'string', description: 'Issue body' },
        labels: {
          type: 'array',
          items: { type: 'string' },
          description: 'Issue labels'
        }
      },
      required: ['owner', 'repo', 'title']
    },
    handler: async (params: any) => {
      const service = new GitHubService(process.env.GITHUB_TOKEN!);
      return await service.createIssue(
        params.owner,
        params.repo,
        {
          title: params.title,
          body: params.body,
          labels: params.labels
        }
      );
    }
  },

  github_create_pr: {
    description: 'Create a new pull request',
    parameters: {
      type: 'object',
      properties: {
        owner: { type: 'string', description: 'Repository owner' },
        repo: { type: 'string', description: 'Repository name' },
        title: { type: 'string', description: 'PR title' },
        head: { type: 'string', description: 'Head branch' },
        base: { type: 'string', description: 'Base branch' },
        body: { type: 'string', description: 'PR body' },
        draft: { type: 'boolean', description: 'Create as draft' }
      },
      required: ['owner', 'repo', 'title', 'head', 'base']
    },
    handler: async (params: any) => {
      const service = new GitHubService(process.env.GITHUB_TOKEN!);
      return await service.createPullRequest(
        params.owner,
        params.repo,
        {
          title: params.title,
          head: params.head,
          base: params.base,
          body: params.body,
          draft: params.draft
        }
      );
    }
  }
};
```

## 3. Jira/Linear 集成

项目管理工具集成是团队协作的关键，Claude Code 支持主流的 Jira 和 Linear 平台。

### 3.1 Jira API 集成

```typescript
// jira-service.ts
import axios, { AxiosInstance } from 'axios';

export class JiraService {
  private client: AxiosInstance;

  constructor(
    domain: string,
    email: string,
    apiToken: string
  ) {
    this.client = axios.create({
      baseURL: `https://${domain}/rest/api/3`,
      auth: {
        username: email,
        password: apiToken
      },
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      timeout: 10000
    });
  }

  /**
   * 创建 Issue
   */
  async createIssue(options: {
    projectKey: string;
    summary: string;
    description?: string;
    issueType: string;
    priority?: string;
    assignee?: string;
    labels?: string[];
  }) {
    try {
      const payload = {
        fields: {
          project: {
            key: options.projectKey
          },
          summary: options.summary,
          description: options.description ? {
            type: 'doc',
            version: 1,
            content: [
              {
                type: 'paragraph',
                content: [
                  {
                    type: 'text',
                    text: options.description
                  }
                ]
              }
            ]
          } : undefined,
          issuetype: {
            name: options.issueType
          },
          priority: options.priority ? {
            name: options.priority
          } : undefined,
          assignee: options.assignee ? {
            accountId: options.assignee
          } : undefined,
          labels: options.labels
        }
      };

      const response = await this.client.post('/issue', payload);

      return {
        id: response.data.id,
        key: response.data.key,
        url: `${this.client.defaults.baseURL?.replace('/rest/api/3', '')}/browse/${response.data.key}`
      };
    } catch (error) {
      throw new Error(`Failed to create Jira issue: ${error.message}`);
    }
  }

  /**
   * 搜索 Issues
   */
  async searchIssues(jql: string, fields?: string[]) {
    try {
      const response = await this.client.post('/search', {
        jql,
        fields: fields || ['summary', 'status', 'assignee', 'created', 'updated'],
        maxResults: 100
      });

      return response.data.issues.map((issue: any) => ({
        id: issue.id,
        key: issue.key,
        summary: issue.fields.summary,
        status: issue.fields.status.name,
        assignee: issue.fields.assignee?.displayName,
        created: issue.fields.created,
        updated: issue.fields.updated
      }));
    } catch (error) {
      throw new Error(`Failed to search Jira issues: ${error.message}`);
    }
  }

  /**
   * 更新 Issue 状态
   */
  async transitionIssue(issueKey: string, transitionId: string) {
    try {
      await this.client.post(`/issue/${issueKey}/transitions`, {
        transition: {
          id: transitionId
        }
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to transition issue: ${error.message}`);
    }
  }

  /**
   * 添加评论
   */
  async addComment(issueKey: string, body: string) {
    try {
      const response = await this.client.post(
        `/issue/${issueKey}/comment`,
        {
          body: {
            type: 'doc',
            version: 1,
            content: [
              {
                type: 'paragraph',
                content: [
                  {
                    type: 'text',
                    text: body
                  }
                ]
              }
            ]
          }
        }
      );

      return {
        id: response.data.id,
        created: response.data.created
      };
    } catch (error) {
      throw new Error(`Failed to add comment: ${error.message}`);
    }
  }
}
```

### 3.2 Linear API 集成

```typescript
// linear-service.ts
import { LinearClient } from '@linear/sdk';

export class LinearService {
  private client: LinearClient;

  constructor(apiKey: string) {
    this.client = new LinearClient({
      apiKey
    });
  }

  /**
   * 创建 Issue
   */
  async createIssue(options: {
    teamId: string;
    title: string;
    description?: string;
    priority?: number;
    assigneeId?: string;
    labelIds?: string[];
  }) {
    try {
      const issue = await this.client.createIssue({
        teamId: options.teamId,
        title: options.title,
        description: options.description,
        priority: options.priority,
        assigneeId: options.assigneeId,
        labelIds: options.labelIds
      });

      return {
        id: issue.issue?.id,
        identifier: issue.issue?.identifier,
        url: issue.issue?.url
      };
    } catch (error) {
      throw new Error(`Failed to create Linear issue: ${error.message}`);
    }
  }

  /**
   * 搜索 Issues
   */
  async searchIssues(filter: {
    teamId?: string;
    assigneeId?: string;
    state?: string;
  }) {
    try {
      const issues = await this.client.issues({
        filter: {
          team: filter.teamId ? { id: { eq: filter.teamId } } : undefined,
          assignee: filter.assigneeId ? { id: { eq: filter.assigneeId } } : undefined,
          state: filter.state ? { name: { eq: filter.state } } : undefined
        }
      });

      const nodes = await issues.nodes;

      return nodes.map(issue => ({
        id: issue.id,
        identifier: issue.identifier,
        title: issue.title,
        state: issue.state?.name,
        assignee: issue.assignee?.name,
        priority: issue.priority,
        url: issue.url
      }));
    } catch (error) {
      throw new Error(`Failed to search Linear issues: ${error.message}`);
    }
  }

  /**
   * 更新 Issue
   */
  async updateIssue(
    issueId: string,
    updates: {
      title?: string;
      description?: string;
      stateId?: string;
      assigneeId?: string;
      priority?: number;
    }
  ) {
    try {
      const result = await this.client.updateIssue(issueId, updates);

      return {
        success: result.success,
        issue: result.issue
      };
    } catch (error) {
      throw new Error(`Failed to update Linear issue: ${error.message}`);
    }
  }
}
```

### 3.3 工作流自动化示例

```typescript
// workflow-automation.ts
import { GitHubService } from './github-service';
import { JiraService } from './jira-service';

export class WorkflowAutomation {
  constructor(
    private github: GitHubService,
    private jira: JiraService
  ) {}

  /**
   * PR 创建时自动创建 Jira Issue
   */
  async onPullRequestCreated(
    owner: string,
    repo: string,
    prNumber: number
  ) {
    try {
      // 获取 PR 信息
      const pr = await this.github.octokit.pulls.get({
        owner,
        repo,
        pull_number: prNumber
      });

      // 创建 Jira Issue
      const issue = await this.jira.createIssue({
        projectKey: 'DEV',
        summary: `[PR-${prNumber}] ${pr.data.title}`,
        description: pr.data.body || '',
        issueType: 'Task',
        labels: ['code-review']
      });

      // 在 PR 中添加评论，链接 Jira Issue
      await this.github.addIssueComment(
        owner,
        repo,
        prNumber,
        `Jira Issue created: ${issue.url}`
      );

      return issue;
    } catch (error) {
      console.error('Workflow automation failed:', error);
      throw error;
    }
  }

  /**
   * PR 合并后自动更新 Jira Issue 状态
   */
  async onPullRequestMerged(
    owner: string,
    repo: string,
    prNumber: number,
    jiraIssueKey: string
  ) {
    try {
      // 添加 Jira 评论
      await this.jira.addComment(
        jiraIssueKey,
        `Pull Request #${prNumber} has been merged into ${repo}`
      );

      // 转换 Issue 状态到 "Done"
      await this.jira.transitionIssue(jiraIssueKey, '31'); // 31 = Done

      return { success: true };
    } catch (error) {
      console.error('Failed to update Jira issue:', error);
      throw error;
    }
  }
}
```

## 4. Slack/Discord 集成

通讯工具集成是团队协作通知的重要渠道。

### 4.1 Slack Webhook 集成

```typescript
// slack-service.ts
import axios from 'axios';

export class SlackService {
  constructor(private webhookUrl: string) {}

  /**
   * 发送简单消息
   */
  async sendMessage(text: string) {
    try {
      await axios.post(this.webhookUrl, {
        text
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send Slack message: ${error.message}`);
    }
  }

  /**
   * 发送格式化消息
   */
  async sendFormattedMessage(options: {
    text: string;
    blocks?: any[];
    attachments?: any[];
  }) {
    try {
      await axios.post(this.webhookUrl, {
        text: options.text,
        blocks: options.blocks,
        attachments: options.attachments
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send formatted message: ${error.message}`);
    }
  }

  /**
   * 发送代码评审通知
   */
  async sendCodeReviewNotification(options: {
    prTitle: string;
    prUrl: string;
    author: string;
    reviewers: string[];
  }) {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '新的代码评审请求'
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*PR 标题:*\n${options.prTitle}`
          },
          {
            type: 'mrkdwn',
            text: `*作者:*\n${options.author}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*评审人:*\n${options.reviewers.join(', ')}`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: '查看 PR'
            },
            url: options.prUrl,
            style: 'primary'
          }
        ]
      }
    ];

    return this.sendFormattedMessage({
      text: `新的代码评审: ${options.prTitle}`,
      blocks
    });
  }

  /**
   * 发送构建状态通知
   */
  async sendBuildNotification(options: {
    repo: string;
    branch: string;
    status: 'success' | 'failure' | 'cancelled';
    buildUrl: string;
  }) {
    const statusEmoji = {
      success: '✅',
      failure: '❌',
      cancelled: '⏸️'
    };

    const statusColor = {
      success: 'good',
      failure: 'danger',
      cancelled: 'warning'
    };

    const attachments = [
      {
        color: statusColor[options.status],
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `${statusEmoji[options.status]} *构建 ${options.status}*`
            }
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*仓库:*\n${options.repo}`
              },
              {
                type: 'mrkdwn',
                text: `*分支:*\n${options.branch}`
              }
            ]
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: '查看构建'
                },
                url: options.buildUrl
              }
            ]
          }
        ]
      }
    ];

    return this.sendFormattedMessage({
      text: `构建 ${options.status}: ${options.repo}`,
      attachments
    });
  }
}
```

### 4.2 Slack Bot 开发

```typescript
// slack-bot.ts
import { App } from '@slack/bolt';

export class SlackBot {
  private app: App;

  constructor(token: string, signingSecret: string) {
    this.app = new App({
      token,
      signingSecret
    });

    this.setupHandlers();
  }

  private setupHandlers() {
    // 监听 /deploy 命令
    this.app.command('/deploy', async ({ command, ack, say }) => {
      await ack();

      try {
        const [env, branch] = command.text.split(' ');

        await say({
          text: `正在部署 ${branch} 到 ${env} 环境...`,
          thread_ts: command.ts
        });

        // 触发部署流程
        // await deployService.deploy(env, branch);

        await say({
          text: `✅ 部署成功！`,
          thread_ts: command.ts
        });
      } catch (error) {
        await say({
          text: `❌ 部署失败: ${error.message}`,
          thread_ts: command.ts
        });
      }
    });

    // 监听消息事件
    this.app.message(/code review/i, async ({ message, say }) => {
      await say({
        text: '需要代码评审吗？请使用 `/review <pr-url>` 命令。',
        thread_ts: (message as any).ts
      });
    });

    // 监听快捷方式
    this.app.shortcut('approve_pr', async ({ shortcut, ack, client }) => {
      await ack();

      // 处理 PR 批准逻辑
      await client.views.open({
        trigger_id: shortcut.trigger_id,
        view: {
          type: 'modal',
          title: {
            type: 'plain_text',
            text: '批准 PR'
          },
          blocks: [
            {
              type: 'input',
              block_id: 'comment_block',
              label: {
                type: 'plain_text',
                text: '评论'
              },
              element: {
                type: 'plain_text_input',
                action_id: 'comment',
                multiline: true
              }
            }
          ],
          submit: {
            type: 'plain_text',
            text: '提交'
          }
        }
      });
    });
  }

  async start(port: number = 3000) {
    await this.app.start(port);
    console.log(`⚡️ Slack bot is running on port ${port}`);
  }
}
```

### 4.3 Discord Webhook 集成

```typescript
// discord-service.ts
import axios from 'axios';

export class DiscordService {
  constructor(private webhookUrl: string) {}

  /**
   * 发送消息
   */
  async sendMessage(options: {
    content?: string;
    embeds?: any[];
    username?: string;
    avatarUrl?: string;
  }) {
    try {
      await axios.post(this.webhookUrl, {
        content: options.content,
        embeds: options.embeds,
        username: options.username,
        avatar_url: options.avatarUrl
      });

      return { success: true };
    } catch (error) {
      throw new Error(`Failed to send Discord message: ${error.message}`);
    }
  }

  /**
   * 发送 PR 通知
   */
  async sendPRNotification(options: {
    prTitle: string;
    prUrl: string;
    author: string;
    description: string;
  }) {
    const embed = {
      title: options.prTitle,
      url: options.prUrl,
      description: options.description,
      color: 0x0099ff,
      author: {
        name: options.author
      },
      fields: [
        {
          name: '状态',
          value: '待评审',
          inline: true
        }
      ],
      timestamp: new Date().toISOString()
    };

    return this.sendMessage({
      content: '@here 新的 PR 需要评审',
      embeds: [embed]
    });
  }

  /**
   * 发送部署通知
   */
  async sendDeploymentNotification(options: {
    environment: string;
    version: string;
    status: 'started' | 'success' | 'failed';
    deployedBy: string;
  }) {
    const statusColors = {
      started: 0xffa500, // Orange
      success: 0x00ff00, // Green
      failed: 0xff0000   // Red
    };

    const statusEmojis = {
      started: '🚀',
      success: '✅',
      failed: '❌'
    };

    const embed = {
      title: `${statusEmojis[options.status]} 部署 ${options.status}`,
      color: statusColors[options.status],
      fields: [
        {
          name: '环境',
          value: options.environment,
          inline: true
        },
        {
          name: '版本',
          value: options.version,
          inline: true
        },
        {
          name: '部署人',
          value: options.deployedBy,
          inline: true
        }
      ],
      timestamp: new Date().toISOString()
    };

    return this.sendMessage({
      embeds: [embed]
    });
  }
}
```

## 5. 数据库连接

数据库集成使 AI 助手能够查询和分析数据。

### 5.1 MySQL/PostgreSQL 连接

```typescript
// mysql-service.ts
import mysql from 'mysql2/promise';

export class MySQLService {
  private pool: mysql.Pool;

  constructor(config: {
    host: string;
    port?: number;
    user: string;
    password: string;
    database: string;
  }) {
    this.pool = mysql.createPool({
      ...config,
      port: config.port || 3306,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0
    });
  }

  /**
   * 执行查询
   */
  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {
    try {
      const [rows] = await this.pool.execute(sql, params);
      return rows as T[];
    } catch (error) {
      throw new Error(`Query failed: ${error.message}`);
    }
  }

  /**
   * 获取表结构
   */
  async getTableSchema(tableName: string) {
    const columns = await this.query(`
      SELECT
        COLUMN_NAME as name,
        DATA_TYPE as type,
        IS_NULLABLE as nullable,
        COLUMN_KEY as key,
        COLUMN_DEFAULT as defaultValue,
        EXTRA as extra
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = ?
      ORDER BY ORDINAL_POSITION
    `, [tableName]);

    return columns;
  }

  /**
   * 列出所有表
   */
  async listTables() {
    const tables = await this.query(`
      SELECT TABLE_NAME as name
      FROM INFORMATION_SCHEMA.TABLES
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_TYPE = 'BASE TABLE'
      ORDER BY TABLE_NAME
    `);

    return tables;
  }

  /**
   * 获取表索引
   */
  async getTableIndexes(tableName: string) {
    const indexes = await this.query(`
      SELECT
        INDEX_NAME as name,
        COLUMN_NAME as column,
        NON_UNIQUE as nonUnique,
        INDEX_TYPE as type
      FROM INFORMATION_SCHEMA.STATISTICS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = ?
      ORDER BY INDEX_NAME, SEQ_IN_INDEX
    `, [tableName]);

    return indexes;
  }

  /**
   * 关闭连接池
   */
  async close() {
    await this.pool.end();
  }
}
```

```typescript
// postgres-service.ts
import { Pool } from 'pg';

export class PostgresService {
  private pool: Pool;

  constructor(config: {
    host: string;
    port?: number;
    user: string;
    password: string;
    database: string;
  }) {
    this.pool = new Pool({
      ...config,
      port: config.port || 5432,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
  }

  /**
   * 执行查询
   */
  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {
    try {
      const result = await this.pool.query(sql, params);
      return result.rows;
    } catch (error) {
      throw new Error(`Query failed: ${error.message}`);
    }
  }

  /**
   * 获取表结构
   */
  async getTableSchema(tableName: string) {
    const columns = await this.query(`
      SELECT
        column_name as name,
        data_type as type,
        is_nullable as nullable,
        column_default as "defaultValue"
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = $1
      ORDER BY ordinal_position
    `, [tableName]);

    return columns;
  }

  /**
   * 列出所有表
   */
  async listTables() {
    const tables = await this.query(`
      SELECT tablename as name
      FROM pg_tables
      WHERE schemaname = 'public'
      ORDER BY tablename
    `);

    return tables;
  }

  /**
   * 关闭连接池
   */
  async close() {
    await this.pool.end();
  }
}
```

### 5.2 MongoDB 集成

```typescript
// mongodb-service.ts
import { MongoClient, Db, Collection } from 'mongodb';

export class MongoDBService {
  private client: MongoClient;
  private db: Db | null = null;

  constructor(private uri: string, private dbName: string) {
    this.client = new MongoClient(uri);
  }

  /**
   * 连接数据库
   */
  async connect() {
    try {
      await this.client.connect();
      this.db = this.client.db(this.dbName);
      console.log(`Connected to MongoDB: ${this.dbName}`);
    } catch (error) {
      throw new Error(`MongoDB connection failed: ${error.message}`);
    }
  }

  /**
   * 获取集合
   */
  getCollection<T = any>(name: string): Collection<T> {
    if (!this.db) {
      throw new Error('Database not connected');
    }
    return this.db.collection<T>(name);
  }

  /**
   * 查询文档
   */
  async find<T = any>(
    collectionName: string,
    filter: any = {},
    options?: {
      limit?: number;
      skip?: number;
      sort?: any;
    }
  ): Promise<T[]> {
    const collection = this.getCollection<T>(collectionName);

    let cursor = collection.find(filter);

    if (options?.sort) {
      cursor = cursor.sort(options.sort);
    }
    if (options?.skip) {
      cursor = cursor.skip(options.skip);
    }
    if (options?.limit) {
      cursor = cursor.limit(options.limit);
    }

    return cursor.toArray();
  }

  /**
   * 插入文档
   */
  async insertOne<T = any>(
    collectionName: string,
    document: T
  ) {
    const collection = this.getCollection<T>(collectionName);
    const result = await collection.insertOne(document as any);

    return {
      insertedId: result.insertedId,
      acknowledged: result.acknowledged
    };
  }

  /**
   * 更新文档
   */
  async updateOne<T = any>(
    collectionName: string,
    filter: any,
    update: any
  ) {
    const collection = this.getCollection<T>(collectionName);
    const result = await collection.updateOne(filter, update);

    return {
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
      acknowledged: result.acknowledged
    };
  }

  /**
   * 删除文档
   */
  async deleteOne(
    collectionName: string,
    filter: any
  ) {
    const collection = this.getCollection(collectionName);
    const result = await collection.deleteOne(filter);

    return {
      deletedCount: result.deletedCount,
      acknowledged: result.acknowledged
    };
  }

  /**
   * 列出所有集合
   */
  async listCollections() {
    if (!this.db) {
      throw new Error('Database not connected');
    }

    const collections = await this.db.listCollections().toArray();
    return collections.map(col => col.name);
  }

  /**
   * 获取集合统计
   */
  async getCollectionStats(collectionName: string) {
    if (!this.db) {
      throw new Error('Database not connected');
    }

    const stats = await this.db.command({ collStats: collectionName });

    return {
      count: stats.count,
      size: stats.size,
      avgObjSize: stats.avgObjSize,
      storageSize: stats.storageSize,
      indexes: stats.nindexes
    };
  }

  /**
   * 关闭连接
   */
  async close() {
    await this.client.close();
  }
}
```

### 5.3 查询工具安全封装

```typescript
// database-query-tool.ts
export class DatabaseQueryTool {
  private allowedOperations = ['SELECT', 'SHOW', 'DESCRIBE'];

  /**
   * 验证 SQL 安全性
   */
  validateSQL(sql: string): { valid: boolean; error?: string } {
    const upperSQL = sql.trim().toUpperCase();

    // 检查是否包含危险操作
    const dangerousKeywords = [
      'DROP', 'DELETE', 'UPDATE', 'INSERT',
      'TRUNCATE', 'ALTER', 'CREATE', 'GRANT', 'REVOKE'
    ];

    for (const keyword of dangerousKeywords) {
      if (upperSQL.includes(keyword)) {
        return {
          valid: false,
          error: `Dangerous operation detected: ${keyword}`
        };
      }
    }

    // 检查是否以允许的操作开头
    const isAllowed = this.allowedOperations.some(
      op => upperSQL.startsWith(op)
    );

    if (!isAllowed) {
      return {
        valid: false,
        error: 'Only SELECT, SHOW, and DESCRIBE queries are allowed'
      };
    }

    return { valid: true };
  }

  /**
   * 安全执行查询
   */
  async executeSafeQuery(
    service: MySQLService | PostgresService,
    sql: string,
    params?: any[]
  ) {
    // 验证 SQL
    const validation = this.validateSQL(sql);
    if (!validation.valid) {
      throw new Error(`Query validation failed: ${validation.error}`);
    }

    try {
      const results = await service.query(sql, params);

      // 限制返回结果数量
      const maxRows = 1000;
      if (results.length > maxRows) {
        return {
          rows: results.slice(0, maxRows),
          truncated: true,
          totalRows: results.length
        };
      }

      return {
        rows: results,
        truncated: false,
        totalRows: results.length
      };
    } catch (error) {
      throw new Error(`Query execution failed: ${error.message}`);
    }
  }
}
```

## 6. 云服务集成

云存储服务集成使 AI 能够管理文件和资源。

### 6.1 AWS S3 操作

```typescript
// s3-service.ts
import { S3Client, PutObjectCommand, GetObjectCommand,
         ListObjectsV2Command, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { Readable } from 'stream';

export class S3Service {
  private client: S3Client;

  constructor(
    region: string,
    accessKeyId: string,
    secretAccessKey: string
  ) {
    this.client = new S3Client({
      region,
      credentials: {
        accessKeyId,
        secretAccessKey
      }
    });
  }

  /**
   * 上传文件
   */
  async uploadFile(
    bucket: string,
    key: string,
    body: Buffer | Readable | string,
    options?: {
      contentType?: string;
      metadata?: Record<string, string>;
    }
  ) {
    try {
      const command = new PutObjectCommand({
        Bucket: bucket,
        Key: key,
        Body: body,
        ContentType: options?.contentType,
        Metadata: options?.metadata
      });

      await this.client.send(command);

      return {
        bucket,
        key,
        url: `https://${bucket}.s3.amazonaws.com/${key}`
      };
    } catch (error) {
      throw new Error(`S3 upload failed: ${error.message}`);
    }
  }

  /**
   * 下载文件
   */
  async downloadFile(bucket: string, key: string): Promise<Buffer> {
    try {
      const command = new GetObjectCommand({
        Bucket: bucket,
        Key: key
      });

      const response = await this.client.send(command);

      // 将 Stream 转换为 Buffer
      const chunks: Uint8Array[] = [];
      for await (const chunk of response.Body as Readable) {
        chunks.push(chunk);
      }

      return Buffer.concat(chunks);
    } catch (error) {
      throw new Error(`S3 download failed: ${error.message}`);
    }
  }

  /**
   * 列出对象
   */
  async listObjects(
    bucket: string,
    prefix?: string,
    maxKeys?: number
  ) {
    try {
      const command = new ListObjectsV2Command({
        Bucket: bucket,
        Prefix: prefix,
        MaxKeys: maxKeys || 1000
      });

      const response = await this.client.send(command);

      return {
        objects: response.Contents?.map(obj => ({
          key: obj.Key,
          size: obj.Size,
          lastModified: obj.LastModified,
          etag: obj.ETag
        })) || [],
        isTruncated: response.IsTruncated,
        nextContinuationToken: response.NextContinuationToken
      };
    } catch (error) {
      throw new Error(`S3 list failed: ${error.message}`);
    }
  }

  /**
   * 删除文件
   */
  async deleteFile(bucket: string, key: string) {
    try {
      const command = new DeleteObjectCommand({
        Bucket: bucket,
        Key: key
      });

      await this.client.send(command);

      return { success: true };
    } catch (error) {
      throw new Error(`S3 delete failed: ${error.message}`);
    }
  }

  /**
   * 生成预签名 URL
   */
  async getPresignedUrl(
    bucket: string,
    key: string,
    expiresIn: number = 3600
  ): Promise<string> {
    try {
      const command = new GetObjectCommand({
        Bucket: bucket,
        Key: key
      });

      const url = await getSignedUrl(this.client, command, { expiresIn });

      return url;
    } catch (error) {
      throw new Error(`Failed to generate presigned URL: ${error.message}`);
    }
  }
}
```

### 6.2 Azure Blob Storage

```typescript
// azure-blob-service.ts
import { BlobServiceClient, ContainerClient } from '@azure/storage-blob';

export class AzureBlobService {
  private blobServiceClient: BlobServiceClient;

  constructor(connectionString: string) {
    this.blobServiceClient = BlobServiceClient.fromConnectionString(
      connectionString
    );
  }

  /**
   * 获取容器客户端
   */
  private getContainerClient(containerName: string): ContainerClient {
    return this.blobServiceClient.getContainerClient(containerName);
  }

  /**
   * 上传 Blob
   */
  async uploadBlob(
    containerName: string,
    blobName: string,
    content: Buffer | Readable | string,
    options?: {
      contentType?: string;
      metadata?: Record<string, string>;
    }
  ) {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blockBlobClient = containerClient.getBlockBlobClient(blobName);

      const uploadOptions = {
        blobHTTPHeaders: {
          blobContentType: options?.contentType
        },
        metadata: options?.metadata
      };

      if (typeof content === 'string') {
        await blockBlobClient.upload(content, content.length, uploadOptions);
      } else if (Buffer.isBuffer(content)) {
        await blockBlobClient.upload(content, content.length, uploadOptions);
      } else {
        await blockBlobClient.uploadStream(content, undefined, undefined, uploadOptions);
      }

      return {
        container: containerName,
        blob: blobName,
        url: blockBlobClient.url
      };
    } catch (error) {
      throw new Error(`Azure Blob upload failed: ${error.message}`);
    }
  }

  /**
   * 下载 Blob
   */
  async downloadBlob(
    containerName: string,
    blobName: string
  ): Promise<Buffer> {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blobClient = containerClient.getBlobClient(blobName);

      const downloadResponse = await blobClient.download();

      if (!downloadResponse.readableStreamBody) {
        throw new Error('No readable stream in response');
      }

      const chunks: Uint8Array[] = [];
      for await (const chunk of downloadResponse.readableStreamBody) {
        chunks.push(chunk);
      }

      return Buffer.concat(chunks);
    } catch (error) {
      throw new Error(`Azure Blob download failed: ${error.message}`);
    }
  }

  /**
   * 列出 Blobs
   */
  async listBlobs(containerName: string, prefix?: string) {
    try {
      const containerClient = this.getContainerClient(containerName);

      const blobs = [];
      for await (const blob of containerClient.listBlobsFlat({ prefix })) {
        blobs.push({
          name: blob.name,
          size: blob.properties.contentLength,
          lastModified: blob.properties.lastModified,
          contentType: blob.properties.contentType
        });
      }

      return blobs;
    } catch (error) {
      throw new Error(`Azure Blob list failed: ${error.message}`);
    }
  }

  /**
   * 删除 Blob
   */
  async deleteBlob(containerName: string, blobName: string) {
    try {
      const containerClient = this.getContainerClient(containerName);
      const blobClient = containerClient.getBlobClient(blobName);

      await blobClient.delete();

      return { success: true };
    } catch (error) {
      throw new Error(`Azure Blob delete failed: ${error.message}`);
    }
  }
}
```

### 6.3 文件上传下载工具

```typescript
// file-upload-tool.ts
import * as fs from 'fs';
import * as path from 'path';
import { S3Service } from './s3-service';
import { AzureBlobService } from './azure-blob-service';

export class FileUploadTool {
  constructor(
    private s3Service?: S3Service,
    private azureService?: AzureBlobService
  ) {}

  /**
   * 上传本地文件到 S3
   */
  async uploadToS3(
    localPath: string,
    bucket: string,
    key?: string
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      // 读取文件
      const fileBuffer = await fs.promises.readFile(localPath);
      const fileName = key || path.basename(localPath);

      // 获取 MIME 类型
      const contentType = this.getContentType(localPath);

      // 上传到 S3
      const result = await this.s3Service.uploadFile(
        bucket,
        fileName,
        fileBuffer,
        { contentType }
      );

      console.log(`File uploaded to S3: ${result.url}`);

      return result;
    } catch (error) {
      throw new Error(`Failed to upload file to S3: ${error.message}`);
    }
  }

  /**
   * 从 S3 下载文件到本地
   */
  async downloadFromS3(
    bucket: string,
    key: string,
    localPath: string
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      // 从 S3 下载
      const fileBuffer = await this.s3Service.downloadFile(bucket, key);

      // 确保目录存在
      const dir = path.dirname(localPath);
      await fs.promises.mkdir(dir, { recursive: true });

      // 写入文件
      await fs.promises.writeFile(localPath, fileBuffer);

      console.log(`File downloaded from S3 to: ${localPath}`);

      return { localPath, size: fileBuffer.length };
    } catch (error) {
      throw new Error(`Failed to download file from S3: ${error.message}`);
    }
  }

  /**
   * 上传目录到 S3
   */
  async uploadDirectoryToS3(
    localDir: string,
    bucket: string,
    prefix: string = ''
  ) {
    if (!this.s3Service) {
      throw new Error('S3 service not configured');
    }

    try {
      const results = [];
      const files = await this.getAllFiles(localDir);

      for (const file of files) {
        const relativePath = path.relative(localDir, file);
        const s3Key = path.join(prefix, relativePath).replace(/\\/g, '/');

        const result = await this.uploadToS3(file, bucket, s3Key);
        results.push(result);
      }

      return {
        uploadedFiles: results.length,
        files: results
      };
    } catch (error) {
      throw new Error(`Failed to upload directory: ${error.message}`);
    }
  }

  /**
   * 递归获取所有文件
   */
  private async getAllFiles(dir: string): Promise<string[]> {
    const files: string[] = [];
    const entries = await fs.promises.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        const subFiles = await this.getAllFiles(fullPath);
        files.push(...subFiles);
      } else {
        files.push(fullPath);
      }
    }

    return files;
  }

  /**
   * 获取文件 MIME 类型
   */
  private getContentType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      '.html': 'text/html',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.json': 'application/json',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.svg': 'image/svg+xml',
      '.pdf': 'application/pdf',
      '.txt': 'text/plain'
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }
}
```

## 7. 最佳实践

### 7.1 认证和密钥管理

```typescript
// credential-manager.ts
import * as crypto from 'crypto';

export class CredentialManager {
  private encryptionKey: Buffer;

  constructor(masterPassword: string) {
    // 从主密码生成加密密钥
    this.encryptionKey = crypto.scryptSync(masterPassword, 'salt', 32);
  }

  /**
   * 加密凭证
   */
  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return iv.toString('hex') + ':' + encrypted;
  }

  /**
   * 解密凭证
   */
  decrypt(encrypted: string): string {
    const parts = encrypted.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encryptedText = parts[1];

    const decipher = crypto.createDecipheriv('aes-256-cbc', this.encryptionKey, iv);

    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  /**
   * 存储凭证
   */
  async storeCredential(
    service: string,
    credential: Record<string, any>
  ) {
    const encrypted = this.encrypt(JSON.stringify(credential));
    // 存储到安全存储（如系统密钥链）
    // 这里简化为环境变量示例
    process.env[`CREDENTIAL_${service.toUpperCase()}`] = encrypted;
  }

  /**
   * 获取凭证
   */
  async getCredential(service: string): Promise<Record<string, any> | null> {
    const encrypted = process.env[`CREDENTIAL_${service.toUpperCase()}`];

    if (!encrypted) {
      return null;
    }

    const decrypted = this.decrypt(encrypted);
    return JSON.parse(decrypted);
  }
}
```

### 7.2 错误处理和重试

```typescript
// retry-handler.ts
export class RetryHandler {
  /**
   * 带重试的请求执行
   */
  async executeWithRetry<T>(
    fn: () => Promise<T>,
    options: {
      maxRetries?: number;
      retryDelay?: number;
      backoff?: 'linear' | 'exponential';
      shouldRetry?: (error: any) => boolean;
    } = {}
  ): Promise<T> {
    const {
      maxRetries = 3,
      retryDelay = 1000,
      backoff = 'exponential',
      shouldRetry = () => true
    } = options;

    let lastError: any;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;

        // 检查是否应该重试
        if (attempt === maxRetries || !shouldRetry(error)) {
          throw error;
        }

        // 计算延迟时间
        const delay = backoff === 'exponential'
          ? retryDelay * Math.pow(2, attempt)
          : retryDelay * (attempt + 1);

        console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);

        // 等待后重试
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }
}
```

### 7.3 请求限流

```typescript
// rate-limiter.ts
export class RateLimiter {
  private tokens: number;
  private lastRefill: number;

  constructor(
    private maxTokens: number,
    private refillRate: number // tokens per second
  ) {
    this.tokens = maxTokens;
    this.lastRefill = Date.now();
  }

  /**
   * 补充令牌
   */
  private refill() {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;

    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  /**
   * 尝试获取令牌
   */
  async acquire(tokens: number = 1): Promise<void> {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return;
    }

    // 计算需要等待的时间
    const tokensNeeded = tokens - this.tokens;
    const waitTime = (tokensNeeded / this.refillRate) * 1000;

    await new Promise(resolve => setTimeout(resolve, waitTime));

    this.tokens = 0;
  }
}
```

## 8. FAQ

### Q1: 如何选择合适的第三方服务集成方式？

**A**: 选择集成方式时需要考虑以下因素：

- **官方 SDK vs REST API**: 优先使用官方 SDK，可以获得更好的类型安全和错误处理
- **认证方式**: 评估 OAuth、API Token、Service Account 等认证方式的安全性
- **性能需求**: 考虑请求频率、数据量，选择合适的客户端配置
- **维护成本**: SDK 通常有更好的向后兼容性，REST API 更灵活但需要手动处理版本变更

### Q2: 如何处理 API 限流问题？

**A**: 建议采用以下策略：

```typescript
// 实现令牌桶算法
const limiter = new RateLimiter(100, 10); // 100个令牌，每秒补充10个

// 在请求前获取令牌
await limiter.acquire(1);
await apiService.makeRequest();
```

同时建议：
- 监控 API 响应头中的限流信息
- 实现指数退避重试
- 使用队列管理并发请求

### Q3: 如何安全地存储第三方服务的密钥？

**A**: 推荐以下实践：

- **开发环境**: 使用 `.env` 文件，不提交到代码库
- **生产环境**: 使用云服务的密钥管理服务（AWS Secrets Manager、Azure Key Vault）
- **本地存储**: 使用系统密钥链（macOS Keychain、Windows Credential Manager）
- **加密存储**: 对密钥进行加密后再存储，使用主密码解密

### Q4: 如何处理跨服务的事务一致性？

**A**: 对于需要跨多个服务的操作，建议：

```typescript
// 实现补偿机制
async function createIssueWithPR(options: any) {
  let prCreated = false;
  let issueCreated = false;

  try {
    // 创建 PR
    const pr = await github.createPullRequest(options.pr);
    prCreated = true;

    // 创建 Jira Issue
    const issue = await jira.createIssue(options.issue);
    issueCreated = true;

    return { pr, issue };
  } catch (error) {
    // 回滚已完成的操作
    if (prCreated) {
      await github.closePullRequest(pr.number);
    }
    throw error;
  }
}
```

### Q5: 如何测试第三方服务集成？

**A**: 建议的测试策略：

- **单元测试**: 使用 Mock 对象模拟 API 响应
- **集成测试**: 使用测试账号和沙箱环境
- **契约测试**: 使用 Pact 等工具验证 API 契约
- **端到端测试**: 在 staging 环境进行完整流程测试

## 9. 总结

第三方服务集成是 Claude Code 提供智能化开发体验的重要基础。通过本文，我们深入了解了：

**核心集成能力**：GitHub API 提供了完整的代码托管服务集成，包括仓库管理、Issue/PR 操作、Actions 控制等功能；Jira 和 Linear 集成支持项目管理自动化；Slack 和 Discord 集成实现团队通知和协作。

**数据访问能力**：MySQL、PostgreSQL 和 MongoDB 集成使 AI 助手能够查询数据库、分析数据模式，为开发者提供基于实际数据的建议。安全查询封装确保了只读操作的安全性。

**云服务管理**：AWS S3 和 Azure Blob Storage 集成支持文件上传下载、批量操作，实现了云资源的智能化管理。

**安全和可靠性**：通过凭证加密存储、请求重试机制、限流控制等最佳实践，确保了第三方服务集成的安全性和稳定性。

掌握这些集成技术，能够让你在使用 Claude Code 时充分发挥其自动化和智能化优势，显著提升开发效率。下一篇文章将探讨《性能优化策略》，分析 Claude Code 如何在保证功能完整性的同时实现高性能。
