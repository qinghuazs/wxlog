---
title: Claude Code 测试与质量保证
date: 2025-01-13
permalink: /ai/claude-code/architecture/testing-quality-assurance.html
categories:
  - AI
  - Claude Code
---

# Claude Code 测试与质量保证

## 1. 引言

在 Claude Code 这样的复杂 AI 代码助手系统中，测试与质量保证是确保系统稳定性、可靠性和用户体验的关键环节。本文将深入探讨 Claude Code 的测试体系架构，包括单元测试、集成测试、E2E 测试、性能测试以及持续集成流程。

### 1.1 测试的重要性

```mermaid
graph TD
    A[测试重要性] --> B[代码质量保障]
    A --> C[快速问题发现]
    A --> D[重构信心]
    A --> E[文档化行为]

    B --> B1[减少Bug]
    B --> B2[提高可维护性]

    C --> C1[早期发现问题]
    C --> C2[降低修复成本]

    D --> D1[安全重构]
    D --> D2[功能扩展]

    E --> E1[测试即文档]
    E --> E2[行为规范]

    style A fill:#f9f,stroke:#333,stroke-width:4px
```

### 1.2 测试金字塔

```mermaid
graph TB
    subgraph 测试金字塔
    A[E2E测试 10%]
    B[集成测试 30%]
    C[单元测试 60%]
    end

    C --> C1[快速执行]
    C --> C2[精确定位]
    C --> C3[低成本维护]

    B --> B1[组件协作]
    B --> B2[接口验证]

    A --> A1[用户场景]
    A --> A2[端到端验证]

    style A fill:#ff9999
    style B fill:#ffcc99
    style C fill:#99ff99
```

## 2. 单元测试框架

### 2.1 TypeScript/Node.js 单元测试（Jest）

#### 2.1.1 Jest 配置

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  transform: {
    '^.+\\.ts$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@tests/(.*)$': '<rootDir>/tests/$1'
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 10000,
  verbose: true
};
```

#### 2.1.2 工具管理器单元测试

```typescript
// tests/unit/tool-manager.test.ts
import { ToolManager } from '@/tools/ToolManager';
import { BashTool } from '@/tools/BashTool';
import { ReadTool } from '@/tools/ReadTool';
import { ToolExecutionContext } from '@/tools/types';

describe('ToolManager', () => {
  let toolManager: ToolManager;
  let mockContext: ToolExecutionContext;

  beforeEach(() => {
    toolManager = new ToolManager();
    mockContext = {
      workingDirectory: '/test/dir',
      user: 'test-user',
      timestamp: Date.now()
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('工具注册', () => {
    it('应该成功注册工具', () => {
      const bashTool = new BashTool();

      toolManager.registerTool('bash', bashTool);

      expect(toolManager.getTool('bash')).toBe(bashTool);
      expect(toolManager.getToolNames()).toContain('bash');
    });

    it('应该拒绝重复注册同名工具', () => {
      const bashTool = new BashTool();

      toolManager.registerTool('bash', bashTool);

      expect(() => {
        toolManager.registerTool('bash', new BashTool());
      }).toThrow('Tool "bash" already registered');
    });

    it('应该支持批量注册工具', () => {
      const tools = {
        bash: new BashTool(),
        read: new ReadTool()
      };

      toolManager.registerTools(tools);

      expect(toolManager.getToolNames()).toEqual(['bash', 'read']);
    });
  });

  describe('工具执行', () => {
    it('应该成功执行已注册的工具', async () => {
      const mockTool = {
        name: 'mock',
        execute: jest.fn().mockResolvedValue({ success: true, data: 'result' })
      };

      toolManager.registerTool('mock', mockTool);

      const result = await toolManager.executeTool('mock', { arg: 'value' }, mockContext);

      expect(mockTool.execute).toHaveBeenCalledWith({ arg: 'value' }, mockContext);
      expect(result).toEqual({ success: true, data: 'result' });
    });

    it('应该处理工具执行错误', async () => {
      const mockTool = {
        name: 'mock',
        execute: jest.fn().mockRejectedValue(new Error('Execution failed'))
      };

      toolManager.registerTool('mock', mockTool);

      await expect(
        toolManager.executeTool('mock', {}, mockContext)
      ).rejects.toThrow('Execution failed');
    });

    it('应该拒绝执行未注册的工具', async () => {
      await expect(
        toolManager.executeTool('nonexistent', {}, mockContext)
      ).rejects.toThrow('Tool "nonexistent" not found');
    });
  });

  describe('工具验证', () => {
    it('应该验证工具参数', () => {
      const bashTool = new BashTool();
      toolManager.registerTool('bash', bashTool);

      const validParams = { command: 'ls -la' };
      const invalidParams = {};

      expect(toolManager.validateParams('bash', validParams)).toBe(true);
      expect(toolManager.validateParams('bash', invalidParams)).toBe(false);
    });

    it('应该检查工具权限', () => {
      const bashTool = new BashTool();
      toolManager.registerTool('bash', bashTool);

      const safeCommand = { command: 'ls' };
      const dangerousCommand = { command: 'rm -rf /' };

      expect(toolManager.checkPermissions('bash', safeCommand)).toBe(true);
      expect(toolManager.checkPermissions('bash', dangerousCommand)).toBe(false);
    });
  });
});
```

#### 2.1.3 文件操作工具测试

```typescript
// tests/unit/file-tools.test.ts
import { ReadTool } from '@/tools/ReadTool';
import { WriteTool } from '@/tools/WriteTool';
import { EditTool } from '@/tools/EditTool';
import * as fs from 'fs/promises';

jest.mock('fs/promises');

describe('文件操作工具', () => {
  const mockFs = fs as jest.Mocked<typeof fs>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('ReadTool', () => {
    let readTool: ReadTool;

    beforeEach(() => {
      readTool = new ReadTool();
    });

    it('应该读取文件内容', async () => {
      const mockContent = 'file content\nline 2\nline 3';
      mockFs.readFile.mockResolvedValue(mockContent);

      const result = await readTool.execute({
        file_path: '/test/file.txt'
      });

      expect(result.success).toBe(true);
      expect(result.data).toContain('file content');
      expect(mockFs.readFile).toHaveBeenCalledWith(
        '/test/file.txt',
        'utf-8'
      );
    });

    it('应该支持行范围读取', async () => {
      const mockContent = Array.from({ length: 100 }, (_, i) => `line ${i + 1}`).join('\n');
      mockFs.readFile.mockResolvedValue(mockContent);

      const result = await readTool.execute({
        file_path: '/test/file.txt',
        offset: 10,
        limit: 20
      });

      expect(result.success).toBe(true);
      const lines = result.data.split('\n');
      expect(lines.length).toBeLessThanOrEqual(20);
    });

    it('应该处理文件不存在错误', async () => {
      mockFs.readFile.mockRejectedValue(new Error('ENOENT: no such file'));

      const result = await readTool.execute({
        file_path: '/nonexistent/file.txt'
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('file not found');
    });

    it('应该处理权限错误', async () => {
      mockFs.readFile.mockRejectedValue(new Error('EACCES: permission denied'));

      const result = await readTool.execute({
        file_path: '/protected/file.txt'
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('permission denied');
    });
  });

  describe('WriteTool', () => {
    let writeTool: WriteTool;

    beforeEach(() => {
      writeTool = new WriteTool();
    });

    it('应该写入文件内容', async () => {
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await writeTool.execute({
        file_path: '/test/new-file.txt',
        content: 'new content'
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/new-file.txt',
        'new content',
        'utf-8'
      );
    });

    it('应该在写入前创建目录', async () => {
      mockFs.mkdir.mockResolvedValue(undefined);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await writeTool.execute({
        file_path: '/test/new/dir/file.txt',
        content: 'content'
      });

      expect(result.success).toBe(true);
      expect(mockFs.mkdir).toHaveBeenCalledWith(
        '/test/new/dir',
        { recursive: true }
      );
    });
  });

  describe('EditTool', () => {
    let editTool: EditTool;

    beforeEach(() => {
      editTool = new EditTool();
    });

    it('应该替换文件中的内容', async () => {
      const originalContent = 'Hello World\nThis is a test\nGoodbye';
      const expectedContent = 'Hello Universe\nThis is a test\nGoodbye';

      mockFs.readFile.mockResolvedValue(originalContent);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'World',
        new_string: 'Universe'
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/file.txt',
        expectedContent,
        'utf-8'
      );
    });

    it('应该支持全局替换', async () => {
      const originalContent = 'foo bar foo baz foo';
      const expectedContent = 'qux bar qux baz qux';

      mockFs.readFile.mockResolvedValue(originalContent);
      mockFs.writeFile.mockResolvedValue(undefined);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'foo',
        new_string: 'qux',
        replace_all: true
      });

      expect(result.success).toBe(true);
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/test/file.txt',
        expectedContent,
        'utf-8'
      );
    });

    it('应该拒绝非唯一匹配（非全局模式）', async () => {
      const originalContent = 'foo bar foo baz';

      mockFs.readFile.mockResolvedValue(originalContent);

      const result = await editTool.execute({
        file_path: '/test/file.txt',
        old_string: 'foo',
        new_string: 'qux',
        replace_all: false
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not unique');
    });
  });
});
```

### 2.2 Java 单元测试（JUnit 5）

#### 2.2.1 JUnit 配置

```xml
<!-- pom.xml -->
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>

    <!-- Mockito -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>5.5.0</version>
        <scope>test</scope>
    </dependency>

    <!-- AssertJ -->
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <version>3.24.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.1.2</version>
            <configuration>
                <includes>
                    <include>**/*Test.java</include>
                    <include>**/*Tests.java</include>
                </includes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 2.2.2 工具执行器测试

```java
package com.anthropic.claudecode.tools;

import org.junit.jupiter.api.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

@DisplayName("ToolExecutor 测试")
class ToolExecutorTest {

    private ToolExecutor toolExecutor;

    @Mock
    private ToolRegistry toolRegistry;

    @Mock
    private SecurityManager securityManager;

    private AutoCloseable mocks;

    @BeforeEach
    void setUp() {
        mocks = MockitoAnnotations.openMocks(this);
        toolExecutor = new ToolExecutor(toolRegistry, securityManager);
    }

    @AfterEach
    void tearDown() throws Exception {
        mocks.close();
    }

    @Nested
    @DisplayName("工具执行测试")
    class ExecutionTests {

        @Test
        @DisplayName("应该成功执行工具")
        void shouldExecuteToolSuccessfully() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "ls");
            ExecutionContext context = new ExecutionContext("/test");
            ToolResult expectedResult = ToolResult.success("output");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenReturn(expectedResult);

            // When
            ToolResult result = toolExecutor.execute("bash", params, context);

            // Then
            assertThat(result).isNotNull();
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getOutput()).isEqualTo("output");

            verify(toolRegistry).getTool("bash");
            verify(securityManager).checkPermission("bash", params);
            verify(mockTool).execute(params, context);
        }

        @Test
        @DisplayName("应该处理工具执行异常")
        void shouldHandleExecutionException() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "invalid");
            ExecutionContext context = new ExecutionContext("/test");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context))
                .thenThrow(new RuntimeException("Execution failed"));

            // When & Then
            assertThatThrownBy(() -> toolExecutor.execute("bash", params, context))
                .isInstanceOf(ToolExecutionException.class)
                .hasMessageContaining("Execution failed");
        }

        @Test
        @DisplayName("应该拒绝无权限的工具调用")
        void shouldRejectUnauthorizedExecution() {
            // Given
            Map<String, Object> params = Map.of("command", "rm -rf /");
            ExecutionContext context = new ExecutionContext("/test");

            when(securityManager.checkPermission("bash", params)).thenReturn(false);

            // When & Then
            assertThatThrownBy(() -> toolExecutor.execute("bash", params, context))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("Permission denied");

            verify(toolRegistry, never()).getTool(anyString());
        }
    }

    @Nested
    @DisplayName("异步执行测试")
    class AsyncExecutionTests {

        @Test
        @DisplayName("应该支持异步执行")
        void shouldSupportAsyncExecution() throws Exception {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "long-running");
            ExecutionContext context = new ExecutionContext("/test");
            ToolResult expectedResult = ToolResult.success("completed");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenReturn(expectedResult);

            // When
            CompletableFuture<ToolResult> future =
                toolExecutor.executeAsync("bash", params, context);
            ToolResult result = future.get();

            // Then
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getOutput()).isEqualTo("completed");
        }

        @Test
        @DisplayName("应该支持超时控制")
        void shouldSupportTimeout() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("command", "sleep 100");
            ExecutionContext context = new ExecutionContext("/test");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(securityManager.checkPermission("bash", params)).thenReturn(true);
            when(mockTool.execute(params, context)).thenAnswer(invocation -> {
                Thread.sleep(5000);
                return ToolResult.success("done");
            });

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.executeWithTimeout("bash", params, context, 1000)
            ).isInstanceOf(TimeoutException.class);
        }
    }

    @Nested
    @DisplayName("参数验证测试")
    class ValidationTests {

        @Test
        @DisplayName("应该验证必需参数")
        void shouldValidateRequiredParameters() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of(); // 缺少 command 参数

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(mockTool.getRequiredParams()).thenReturn(Set.of("command"));

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.validateAndExecute("bash", params, null)
            ).isInstanceOf(ValidationException.class)
              .hasMessageContaining("Missing required parameter: command");
        }

        @Test
        @DisplayName("应该验证参数类型")
        void shouldValidateParameterTypes() {
            // Given
            Tool mockTool = mock(Tool.class);
            Map<String, Object> params = Map.of("timeout", "not-a-number");

            when(toolRegistry.getTool("bash")).thenReturn(mockTool);
            when(mockTool.getParameterSchema()).thenReturn(
                Map.of("timeout", ParameterType.NUMBER)
            );

            // When & Then
            assertThatThrownBy(() ->
                toolExecutor.validateAndExecute("bash", params, null)
            ).isInstanceOf(ValidationException.class)
              .hasMessageContaining("Invalid type for parameter: timeout");
        }
    }
}
```

## 3. 集成测试策略

### 3.1 集成测试架构

```mermaid
graph TB
    subgraph 集成测试层次
    A[API集成测试] --> B[工具集成测试]
    B --> C[数据库集成测试]
    C --> D[外部服务集成测试]
    end

    A --> A1[HTTP接口测试]
    A --> A2[WebSocket测试]

    B --> B1[工具链协作]
    B --> B2[工具依赖测试]

    C --> C1[数据持久化]
    C --> C2[事务测试]

    D --> D1[Claude API Mock]
    D --> D2[文件系统Mock]

    style A fill:#e1f5ff
    style B fill:#fff9e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
```

### 3.2 API 集成测试

```typescript
// tests/integration/api.test.ts
import request from 'supertest';
import { app } from '@/app';
import { setupTestDatabase, cleanupTestDatabase } from '@tests/helpers/database';

describe('Claude Code API 集成测试', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/tools/execute', () => {
    it('应该执行工具并返回结果', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash',
          parameters: {
            command: 'echo "Hello World"',
            description: 'Test command'
          },
          context: {
            workingDirectory: '/tmp'
          }
        })
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        result: expect.objectContaining({
          stdout: expect.stringContaining('Hello World'),
          exitCode: 0
        })
      });
    });

    it('应该处理工具执行错误', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash',
          parameters: {
            command: 'nonexistent-command'
          }
        })
        .expect(500);

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('command not found')
      });
    });

    it('应该验证请求参数', async () => {
      const response = await request(app)
        .post('/api/tools/execute')
        .send({
          tool: 'bash'
          // 缺少 parameters
        })
        .expect(400);

      expect(response.body).toMatchObject({
        success: false,
        error: expect.stringContaining('parameters are required')
      });
    });

    it('应该实施速率限制', async () => {
      const promises = Array.from({ length: 100 }, () =>
        request(app)
          .post('/api/tools/execute')
          .send({
            tool: 'bash',
            parameters: { command: 'echo test' }
          })
      );

      const responses = await Promise.all(promises);
      const rateLimited = responses.filter(r => r.status === 429);

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  describe('GET /api/tools', () => {
    it('应该返回可用工具列表', async () => {
      const response = await request(app)
        .get('/api/tools')
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        tools: expect.arrayContaining([
          expect.objectContaining({
            name: 'bash',
            description: expect.any(String),
            parameters: expect.any(Object)
          })
        ])
      });
    });
  });

  describe('WebSocket /ws/execute', () => {
    it('应该支持实时工具执行', async () => {
      const ws = new WebSocket('ws://localhost:3000/ws/execute');
      const messages: any[] = [];

      ws.on('message', (data) => {
        messages.push(JSON.parse(data.toString()));
      });

      await new Promise((resolve) => {
        ws.on('open', () => {
          ws.send(JSON.stringify({
            tool: 'bash',
            parameters: {
              command: 'for i in 1 2 3; do echo $i; sleep 1; done',
              run_in_background: true
            }
          }));

          setTimeout(resolve, 4000);
        });
      });

      ws.close();

      expect(messages.length).toBeGreaterThan(1);
      expect(messages[0]).toMatchObject({
        type: 'started',
        shellId: expect.any(String)
      });
      expect(messages.some(m => m.type === 'output')).toBe(true);
    });
  });
});
```

### 3.3 数据库集成测试

```typescript
// tests/integration/database.test.ts
import { SessionRepository } from '@/repositories/SessionRepository';
import { ToolExecutionRepository } from '@/repositories/ToolExecutionRepository';
import { setupTestDatabase, cleanupTestDatabase } from '@tests/helpers/database';

describe('数据库集成测试', () => {
  let sessionRepo: SessionRepository;
  let executionRepo: ToolExecutionRepository;

  beforeAll(async () => {
    await setupTestDatabase();
    sessionRepo = new SessionRepository();
    executionRepo = new ToolExecutionRepository();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  beforeEach(async () => {
    await sessionRepo.clear();
    await executionRepo.clear();
  });

  describe('会话管理', () => {
    it('应该创建和检索会话', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/home/user/project',
        metadata: {
          platform: 'linux',
          nodeVersion: '18.0.0'
        }
      });

      expect(session.id).toBeDefined();
      expect(session.createdAt).toBeInstanceOf(Date);

      const retrieved = await sessionRepo.findById(session.id);
      expect(retrieved).toMatchObject({
        userId: 'user-123',
        workingDirectory: '/home/user/project'
      });
    });

    it('应该更新会话状态', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await sessionRepo.update(session.id, {
        status: 'active',
        lastActivityAt: new Date()
      });

      const updated = await sessionRepo.findById(session.id);
      expect(updated.status).toBe('active');
      expect(updated.lastActivityAt).toBeInstanceOf(Date);
    });

    it('应该查询用户的所有会话', async () => {
      await sessionRepo.create({ userId: 'user-1', workingDirectory: '/a' });
      await sessionRepo.create({ userId: 'user-1', workingDirectory: '/b' });
      await sessionRepo.create({ userId: 'user-2', workingDirectory: '/c' });

      const user1Sessions = await sessionRepo.findByUserId('user-1');
      expect(user1Sessions).toHaveLength(2);
    });
  });

  describe('工具执行记录', () => {
    it('应该记录工具执行历史', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      const execution = await executionRepo.create({
        sessionId: session.id,
        toolName: 'bash',
        parameters: { command: 'ls' },
        startedAt: new Date()
      });

      expect(execution.id).toBeDefined();

      await executionRepo.complete(execution.id, {
        success: true,
        result: { stdout: 'file1\nfile2', exitCode: 0 },
        completedAt: new Date()
      });

      const completed = await executionRepo.findById(execution.id);
      expect(completed.success).toBe(true);
      expect(completed.result.stdout).toContain('file1');
    });

    it('应该查询会话的执行历史', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await executionRepo.create({
        sessionId: session.id,
        toolName: 'bash',
        parameters: { command: 'ls' },
        startedAt: new Date()
      });

      await executionRepo.create({
        sessionId: session.id,
        toolName: 'read',
        parameters: { file_path: '/test/file.txt' },
        startedAt: new Date()
      });

      const history = await executionRepo.findBySessionId(session.id);
      expect(history).toHaveLength(2);
      expect(history.map(h => h.toolName)).toContain('bash');
      expect(history.map(h => h.toolName)).toContain('read');
    });

    it('应该支持事务回滚', async () => {
      const session = await sessionRepo.create({
        userId: 'user-123',
        workingDirectory: '/test'
      });

      await expect(async () => {
        await sessionRepo.transaction(async (trx) => {
          await executionRepo.create({
            sessionId: session.id,
            toolName: 'bash',
            parameters: { command: 'test' },
            startedAt: new Date()
          }, trx);

          throw new Error('Rollback test');
        });
      }).rejects.toThrow('Rollback test');

      const executions = await executionRepo.findBySessionId(session.id);
      expect(executions).toHaveLength(0);
    });
  });
});
```

## 4. E2E 测试实践

### 4.1 Playwright E2E 测试配置

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit.xml' }]
  ],
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    }
  ],
  webServer: {
    command: 'npm run start:test',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120000
  }
});
```

### 4.2 E2E 测试用例

```typescript
// tests/e2e/tool-execution.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Claude Code 工具执行 E2E 测试', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('应该执行 Bash 命令并显示输出', async ({ page }) => {
    // 输入命令
    await page.fill('[data-testid="command-input"]', 'ls -la');

    // 选择工具
    await page.selectOption('[data-testid="tool-selector"]', 'bash');

    // 执行
    await page.click('[data-testid="execute-button"]');

    // 等待结果
    await page.waitForSelector('[data-testid="output-container"]');

    // 验证输出
    const output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('total');
    expect(output).toMatch(/^[drwx-]{10}/m); // Unix file permissions

    // 验证状态
    const status = await page.textContent('[data-testid="execution-status"]');
    expect(status).toBe('Success');
  });

  test('应该处理多步骤工具链', async ({ page }) => {
    // 步骤 1: 读取文件
    await page.fill('[data-testid="command-input"]', '/test/sample.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    await page.waitForSelector('[data-testid="output-container"]');
    let output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('Sample content');

    // 步骤 2: 编辑文件
    await page.fill('[data-testid="old-string-input"]', 'old text');
    await page.fill('[data-testid="new-string-input"]', 'new text');
    await page.selectOption('[data-testid="tool-selector"]', 'edit');
    await page.click('[data-testid="execute-button"]');

    await page.waitForSelector('[data-testid="success-message"]');

    // 步骤 3: 验证编辑
    await page.fill('[data-testid="command-input"]', '/test/sample.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('new text');
    expect(output).not.toContain('old text');
  });

  test('应该显示实时命令输出', async ({ page }) => {
    // 执行长时间运行的命令
    await page.fill(
      '[data-testid="command-input"]',
      'for i in 1 2 3; do echo "Line $i"; sleep 1; done'
    );
    await page.selectOption('[data-testid="tool-selector"]', 'bash');
    await page.check('[data-testid="background-checkbox"]');
    await page.click('[data-testid="execute-button"]');

    // 验证实时输出
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 1")');
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 2")');
    await page.waitForSelector('[data-testid="output-line"]:has-text("Line 3")');

    // 验证完成状态
    await page.waitForSelector('[data-testid="execution-complete"]');
  });

  test('应该处理错误情况', async ({ page }) => {
    // 执行无效命令
    await page.fill('[data-testid="command-input"]', 'invalid-command-xyz');
    await page.selectOption('[data-testid="tool-selector"]', 'bash');
    await page.click('[data-testid="execute-button"]');

    // 验证错误消息
    await page.waitForSelector('[data-testid="error-container"]');
    const error = await page.textContent('[data-testid="error-container"]');
    expect(error).toContain('command not found');

    // 验证状态
    const status = await page.textContent('[data-testid="execution-status"]');
    expect(status).toBe('Failed');
  });

  test('应该支持文件上传', async ({ page }) => {
    // 准备测试文件
    const testFile = {
      name: 'test-upload.txt',
      mimeType: 'text/plain',
      buffer: Buffer.from('Test file content')
    };

    // 上传文件
    await page.setInputFiles('[data-testid="file-input"]', testFile);
    await page.click('[data-testid="upload-button"]');

    // 验证上传成功
    await page.waitForSelector('[data-testid="upload-success"]');

    // 验证文件可读
    await page.fill('[data-testid="command-input"]', '/uploads/test-upload.txt');
    await page.selectOption('[data-testid="tool-selector"]', 'read');
    await page.click('[data-testid="execute-button"]');

    const output = await page.textContent('[data-testid="output-container"]');
    expect(output).toContain('Test file content');
  });

  test('应该保存执行历史', async ({ page }) => {
    // 执行多个命令
    const commands = ['echo "cmd1"', 'echo "cmd2"', 'echo "cmd3"'];

    for (const cmd of commands) {
      await page.fill('[data-testid="command-input"]', cmd);
      await page.selectOption('[data-testid="tool-selector"]', 'bash');
      await page.click('[data-testid="execute-button"]');
      await page.waitForSelector('[data-testid="success-message"]');
    }

    // 打开历史面板
    await page.click('[data-testid="history-button"]');
    await page.waitForSelector('[data-testid="history-panel"]');

    // 验证历史记录
    const historyItems = await page.locator('[data-testid="history-item"]').count();
    expect(historyItems).toBe(3);

    // 验证可以重新执行历史命令
    await page.click('[data-testid="history-item"]:nth-child(1)');
    const commandInput = await page.inputValue('[data-testid="command-input"]');
    expect(commandInput).toBe('echo "cmd1"');
  });
});
```

### 4.3 Page Object 模式

```typescript
// tests/e2e/pages/ToolExecutionPage.ts
import { Page, Locator } from '@playwright/test';

export class ToolExecutionPage {
  readonly page: Page;
  readonly commandInput: Locator;
  readonly toolSelector: Locator;
  readonly executeButton: Locator;
  readonly outputContainer: Locator;
  readonly errorContainer: Locator;
  readonly statusLabel: Locator;

  constructor(page: Page) {
    this.page = page;
    this.commandInput = page.locator('[data-testid="command-input"]');
    this.toolSelector = page.locator('[data-testid="tool-selector"]');
    this.executeButton = page.locator('[data-testid="execute-button"]');
    this.outputContainer = page.locator('[data-testid="output-container"]');
    this.errorContainer = page.locator('[data-testid="error-container"]');
    this.statusLabel = page.locator('[data-testid="execution-status"]');
  }

  async goto() {
    await this.page.goto('/');
    await this.page.waitForLoadState('networkidle');
  }

  async executeTool(tool: string, command: string) {
    await this.commandInput.fill(command);
    await this.toolSelector.selectOption(tool);
    await this.executeButton.click();
  }

  async waitForSuccess() {
    await this.page.waitForSelector('[data-testid="success-message"]');
  }

  async waitForError() {
    await this.errorContainer.waitFor({ state: 'visible' });
  }

  async getOutput(): Promise<string> {
    return await this.outputContainer.textContent() || '';
  }

  async getError(): Promise<string> {
    return await this.errorContainer.textContent() || '';
  }

  async getStatus(): Promise<string> {
    return await this.statusLabel.textContent() || '';
  }
}

// 使用 Page Object
import { test, expect } from '@playwright/test';
import { ToolExecutionPage } from './pages/ToolExecutionPage';

test('使用 Page Object 执行工具', async ({ page }) => {
  const toolPage = new ToolExecutionPage(page);

  await toolPage.goto();
  await toolPage.executeTool('bash', 'echo "Hello"');
  await toolPage.waitForSuccess();

  const output = await toolPage.getOutput();
  expect(output).toContain('Hello');

  const status = await toolPage.getStatus();
  expect(status).toBe('Success');
});
```

## 5. Mock 和 Stub 技术

### 5.1 工具 Mock

```typescript
// tests/mocks/MockToolRegistry.ts
import { Tool, ToolResult } from '@/tools/types';

export class MockToolRegistry {
  private tools: Map<string, MockTool> = new Map();

  registerMockTool(name: string, behavior: Partial<MockTool>) {
    this.tools.set(name, new MockTool(name, behavior));
  }

  getTool(name: string): MockTool {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool "${name}" not found`);
    }
    return tool;
  }

  reset() {
    this.tools.forEach(tool => tool.reset());
  }
}

export class MockTool implements Tool {
  name: string;
  executionCount: number = 0;
  lastParams: any = null;
  lastContext: any = null;

  private mockResult: ToolResult;
  private mockError: Error | null = null;
  private executionDelay: number = 0;

  constructor(name: string, behavior: Partial<MockTool> = {}) {
    this.name = name;
    this.mockResult = behavior.mockResult || ToolResult.success('mock result');
    this.mockError = behavior.mockError || null;
    this.executionDelay = behavior.executionDelay || 0;
  }

  async execute(params: any, context: any): Promise<ToolResult> {
    this.executionCount++;
    this.lastParams = params;
    this.lastContext = context;

    if (this.executionDelay > 0) {
      await new Promise(resolve => setTimeout(resolve, this.executionDelay));
    }

    if (this.mockError) {
      throw this.mockError;
    }

    return this.mockResult;
  }

  setResult(result: ToolResult) {
    this.mockResult = result;
  }

  setError(error: Error) {
    this.mockError = error;
  }

  setDelay(ms: number) {
    this.executionDelay = ms;
  }

  reset() {
    this.executionCount = 0;
    this.lastParams = null;
    this.lastContext = null;
  }

  wasCalledWith(params: any): boolean {
    return JSON.stringify(this.lastParams) === JSON.stringify(params);
  }
}
```

### 5.2 Claude API Mock

```typescript
// tests/mocks/MockClaudeAPI.ts
import { ClaudeAPIClient, Message, ToolUse } from '@/api/ClaudeAPIClient';

export class MockClaudeAPI implements ClaudeAPIClient {
  private responses: Message[] = [];
  private currentResponseIndex: number = 0;
  private requestHistory: any[] = [];

  constructor() {}

  // 配置预定义响应
  addResponse(content: string, toolUses: ToolUse[] = []) {
    this.responses.push({
      role: 'assistant',
      content: [
        { type: 'text', text: content },
        ...toolUses.map(tu => ({ type: 'tool_use', ...tu }))
      ]
    });
  }

  // 模拟 API 调用
  async sendMessage(messages: Message[]): Promise<Message> {
    this.requestHistory.push({
      timestamp: Date.now(),
      messages: JSON.parse(JSON.stringify(messages))
    });

    if (this.currentResponseIndex >= this.responses.length) {
      throw new Error('No more mock responses available');
    }

    const response = this.responses[this.currentResponseIndex++];

    // 模拟网络延迟
    await new Promise(resolve => setTimeout(resolve, 100));

    return response;
  }

  // 流式响应模拟
  async *streamMessage(messages: Message[]): AsyncGenerator<StreamEvent> {
    this.requestHistory.push({
      timestamp: Date.now(),
      messages: JSON.parse(JSON.stringify(messages)),
      streaming: true
    });

    const response = this.responses[this.currentResponseIndex++];

    // 模拟流式输出
    for (const block of response.content) {
      if (block.type === 'text') {
        const words = block.text.split(' ');
        for (const word of words) {
          yield {
            type: 'content_block_delta',
            delta: { type: 'text_delta', text: word + ' ' }
          };
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } else if (block.type === 'tool_use') {
        yield {
          type: 'content_block_start',
          content_block: block
        };
      }
    }

    yield {
      type: 'message_stop'
    };
  }

  // 检查方法
  getRequestHistory() {
    return this.requestHistory;
  }

  getLastRequest() {
    return this.requestHistory[this.requestHistory.length - 1];
  }

  wasCalledWithTool(toolName: string): boolean {
    return this.requestHistory.some(req =>
      req.messages.some((msg: Message) =>
        msg.content.some((block: any) =>
          block.type === 'tool_result' && block.tool_use_id.includes(toolName)
        )
      )
    );
  }

  reset() {
    this.responses = [];
    this.currentResponseIndex = 0;
    this.requestHistory = [];
  }
}

// 使用示例
describe('Agent 与 Claude API 交互', () => {
  let mockAPI: MockClaudeAPI;
  let agent: Agent;

  beforeEach(() => {
    mockAPI = new MockClaudeAPI();
    agent = new Agent({ apiClient: mockAPI });
  });

  it('应该正确处理工具调用', async () => {
    // 配置 Claude 响应包含工具调用
    mockAPI.addResponse(
      'I will list the files for you.',
      [{
        id: 'tool_1',
        name: 'bash',
        input: { command: 'ls -la' }
      }]
    );

    // 配置第二个响应（工具结果后）
    mockAPI.addResponse('Here are the files in the directory.');

    await agent.processUserMessage('List files in the current directory');

    expect(mockAPI.wasCalledWithTool('bash')).toBe(true);
    expect(mockAPI.getRequestHistory()).toHaveLength(2);
  });
});
```

### 5.3 文件系统 Mock

```typescript
// tests/mocks/MockFileSystem.ts
import * as path from 'path';

export class MockFileSystem {
  private files: Map<string, string> = new Map();
  private directories: Set<string> = new Set(['/']);

  writeFile(filePath: string, content: string): void {
    const normalizedPath = path.normalize(filePath);
    const dir = path.dirname(normalizedPath);

    if (!this.directories.has(dir)) {
      throw new Error(`ENOENT: directory does not exist: ${dir}`);
    }

    this.files.set(normalizedPath, content);
  }

  readFile(filePath: string): string {
    const normalizedPath = path.normalize(filePath);

    if (!this.files.has(normalizedPath)) {
      throw new Error(`ENOENT: no such file: ${normalizedPath}`);
    }

    return this.files.get(normalizedPath)!;
  }

  mkdir(dirPath: string, options?: { recursive?: boolean }): void {
    const normalizedPath = path.normalize(dirPath);

    if (options?.recursive) {
      const parts = normalizedPath.split(path.sep).filter(p => p);
      let currentPath = '/';

      for (const part of parts) {
        currentPath = path.join(currentPath, part);
        this.directories.add(currentPath);
      }
    } else {
      const parent = path.dirname(normalizedPath);
      if (!this.directories.has(parent)) {
        throw new Error(`ENOENT: parent directory does not exist: ${parent}`);
      }
      this.directories.add(normalizedPath);
    }
  }

  exists(filePath: string): boolean {
    const normalizedPath = path.normalize(filePath);
    return this.files.has(normalizedPath) || this.directories.has(normalizedPath);
  }

  readdir(dirPath: string): string[] {
    const normalizedPath = path.normalize(dirPath);

    if (!this.directories.has(normalizedPath)) {
      throw new Error(`ENOENT: directory does not exist: ${normalizedPath}`);
    }

    const items: string[] = [];

    // 查找文件
    for (const [filePath] of this.files) {
      if (path.dirname(filePath) === normalizedPath) {
        items.push(path.basename(filePath));
      }
    }

    // 查找子目录
    for (const dir of this.directories) {
      if (path.dirname(dir) === normalizedPath && dir !== normalizedPath) {
        items.push(path.basename(dir));
      }
    }

    return items;
  }

  unlink(filePath: string): void {
    const normalizedPath = path.normalize(filePath);

    if (!this.files.has(normalizedPath)) {
      throw new Error(`ENOENT: no such file: ${normalizedPath}`);
    }

    this.files.delete(normalizedPath);
  }

  reset(): void {
    this.files.clear();
    this.directories.clear();
    this.directories.add('/');
  }

  // 辅助方法：创建测试文件结构
  createStructure(structure: any, basePath: string = '/'): void {
    for (const [name, content] of Object.entries(structure)) {
      const fullPath = path.join(basePath, name);

      if (typeof content === 'string') {
        // 文件
        this.mkdir(path.dirname(fullPath), { recursive: true });
        this.writeFile(fullPath, content);
      } else {
        // 目录
        this.mkdir(fullPath, { recursive: true });
        this.createStructure(content, fullPath);
      }
    }
  }
}

// 使用示例
describe('文件工具与 MockFileSystem', () => {
  let mockFs: MockFileSystem;
  let readTool: ReadTool;

  beforeEach(() => {
    mockFs = new MockFileSystem();
    readTool = new ReadTool({ fs: mockFs });

    // 创建测试文件结构
    mockFs.createStructure({
      'project': {
        'src': {
          'index.ts': 'console.log("Hello");',
          'utils.ts': 'export const add = (a, b) => a + b;'
        },
        'package.json': JSON.stringify({ name: 'test-project' })
      }
    });
  });

  it('应该读取文件', async () => {
    const result = await readTool.execute({
      file_path: '/project/src/index.ts'
    });

    expect(result.success).toBe(true);
    expect(result.data).toContain('console.log');
  });

  it('应该列出目录内容', async () => {
    const files = mockFs.readdir('/project/src');

    expect(files).toContain('index.ts');
    expect(files).toContain('utils.ts');
  });
});
```

## 6. 测试覆盖率分析

### 6.1 覆盖率配置

```javascript
// jest.config.js (覆盖率部分)
module.exports = {
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html', 'json-summary'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/**/*.types.ts',
    '!src/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/tools/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    },
    './src/security/': {
      branches: 95,
      functions: 95,
      lines: 95,
      statements: 95
    }
  },
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/dist/'
  ]
};
```

### 6.2 覆盖率报告分析

```mermaid
graph LR
    A[测试覆盖率] --> B[语句覆盖率]
    A --> C[分支覆盖率]
    A --> D[函数覆盖率]
    A --> E[行覆盖率]

    B --> B1[已执行语句/总语句]
    C --> C1[已测试分支/总分支]
    D --> D1[已调用函数/总函数]
    E --> E1[已覆盖行/总行数]

    style A fill:#e1f5ff
    style B fill:#d4edda
    style C fill:#fff3cd
    style D fill:#f8d7da
    style E fill:#d1ecf1
```

### 6.3 覆盖率监控脚本

```typescript
// scripts/check-coverage.ts
import * as fs from 'fs';
import * as path from 'path';

interface CoverageSummary {
  total: {
    lines: { pct: number };
    statements: { pct: number };
    functions: { pct: number };
    branches: { pct: number };
  };
  [key: string]: any;
}

const COVERAGE_FILE = path.join(__dirname, '../coverage/coverage-summary.json');
const THRESHOLD = {
  lines: 80,
  statements: 80,
  functions: 80,
  branches: 80
};

function checkCoverage() {
  if (!fs.existsSync(COVERAGE_FILE)) {
    console.error('Coverage file not found. Run tests with coverage first.');
    process.exit(1);
  }

  const coverage: CoverageSummary = JSON.parse(
    fs.readFileSync(COVERAGE_FILE, 'utf-8')
  );

  const { total } = coverage;
  const failures: string[] = [];

  console.log('\n📊 Coverage Report:\n');
  console.log(`Lines:      ${total.lines.pct.toFixed(2)}%`);
  console.log(`Statements: ${total.statements.pct.toFixed(2)}%`);
  console.log(`Functions:  ${total.functions.pct.toFixed(2)}%`);
  console.log(`Branches:   ${total.branches.pct.toFixed(2)}%\n`);

  if (total.lines.pct < THRESHOLD.lines) {
    failures.push(`Lines coverage ${total.lines.pct}% is below threshold ${THRESHOLD.lines}%`);
  }
  if (total.statements.pct < THRESHOLD.statements) {
    failures.push(`Statements coverage ${total.statements.pct}% is below threshold ${THRESHOLD.statements}%`);
  }
  if (total.functions.pct < THRESHOLD.functions) {
    failures.push(`Functions coverage ${total.functions.pct}% is below threshold ${THRESHOLD.functions}%`);
  }
  if (total.branches.pct < THRESHOLD.branches) {
    failures.push(`Branches coverage ${total.branches.pct}% is below threshold ${THRESHOLD.branches}%`);
  }

  if (failures.length > 0) {
    console.error('❌ Coverage check failed:\n');
    failures.forEach(f => console.error(`  - ${f}`));
    process.exit(1);
  }

  console.log('✅ All coverage thresholds met!');
}

checkCoverage();
```

## 7. 性能测试和压力测试

### 7.1 性能测试框架

```typescript
// tests/performance/tool-execution.perf.ts
import { performance } from 'perf_hooks';
import { ToolExecutor } from '@/tools/ToolExecutor';
import { BashTool } from '@/tools/BashTool';

interface PerformanceMetrics {
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
}

class PerformanceTest {
  private measurements: number[] = [];

  async measure(fn: () => Promise<void>): Promise<number> {
    const start = performance.now();
    await fn();
    const duration = performance.now() - start;
    this.measurements.push(duration);
    return duration;
  }

  async run(fn: () => Promise<void>, iterations: number): Promise<void> {
    console.log(`Running ${iterations} iterations...`);

    for (let i = 0; i < iterations; i++) {
      await this.measure(fn);

      if ((i + 1) % 100 === 0) {
        console.log(`  Completed ${i + 1}/${iterations}`);
      }
    }
  }

  getMetrics(): PerformanceMetrics {
    const sorted = [...this.measurements].sort((a, b) => a - b);
    const sum = sorted.reduce((a, b) => a + b, 0);

    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sum / sorted.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }

  printResults(testName: string): void {
    const metrics = this.getMetrics();

    console.log(`\n📈 Performance Results: ${testName}`);
    console.log(`  Iterations: ${this.measurements.length}`);
    console.log(`  Min:        ${metrics.min.toFixed(2)}ms`);
    console.log(`  Max:        ${metrics.max.toFixed(2)}ms`);
    console.log(`  Avg:        ${metrics.avg.toFixed(2)}ms`);
    console.log(`  P50:        ${metrics.p50.toFixed(2)}ms`);
    console.log(`  P95:        ${metrics.p95.toFixed(2)}ms`);
    console.log(`  P99:        ${metrics.p99.toFixed(2)}ms\n`);
  }

  reset(): void {
    this.measurements = [];
  }
}

describe('工具执行性能测试', () => {
  let perfTest: PerformanceTest;
  let toolExecutor: ToolExecutor;

  beforeEach(() => {
    perfTest = new PerformanceTest();
    toolExecutor = new ToolExecutor();
    toolExecutor.registerTool('bash', new BashTool());
  });

  it('应该快速执行简单命令', async () => {
    await perfTest.run(async () => {
      await toolExecutor.execute('bash', {
        command: 'echo "test"'
      });
    }, 1000);

    perfTest.printResults('Simple Command Execution');

    const metrics = perfTest.getMetrics();
    expect(metrics.p95).toBeLessThan(50); // P95 < 50ms
  });

  it('应该处理并发请求', async () => {
    const concurrency = 50;

    const start = performance.now();

    await Promise.all(
      Array.from({ length: concurrency }, () =>
        toolExecutor.execute('bash', {
          command: 'echo "concurrent"'
        })
      )
    );

    const duration = performance.now() - start;

    console.log(`\n⚡ Concurrent Execution (${concurrency} requests)`);
    console.log(`  Total time: ${duration.toFixed(2)}ms`);
    console.log(`  Avg per request: ${(duration / concurrency).toFixed(2)}ms\n`);

    expect(duration).toBeLessThan(5000); // 50 requests < 5s
  });
});
```

### 7.2 压力测试

```typescript
// tests/stress/api-stress.test.ts
import request from 'supertest';
import { app } from '@/app';
import * as os from 'os';

interface StressTestResult {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  duration: number;
  requestsPerSecond: number;
  avgResponseTime: number;
  errors: Map<string, number>;
}

class StressTest {
  private results: {
    status: number;
    duration: number;
    error?: string;
  }[] = [];

  async sendRequest(url: string, body: any): Promise<void> {
    const start = Date.now();

    try {
      const response = await request(app)
        .post(url)
        .send(body);

      this.results.push({
        status: response.status,
        duration: Date.now() - start
      });
    } catch (error) {
      this.results.push({
        status: 500,
        duration: Date.now() - start,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  async run(url: string, body: any, options: {
    duration: number;      // 测试持续时间（秒）
    rps: number;          // 每秒请求数
  }): Promise<void> {
    const { duration, rps } = options;
    const interval = 1000 / rps;
    const endTime = Date.now() + (duration * 1000);

    console.log(`\n🔥 Starting stress test:`);
    console.log(`  Duration: ${duration}s`);
    console.log(`  Target RPS: ${rps}`);
    console.log(`  Total requests: ~${duration * rps}\n`);

    while (Date.now() < endTime) {
      const requestStart = Date.now();

      this.sendRequest(url, body).catch(() => {
        // 错误已在 sendRequest 中处理
      });

      const elapsed = Date.now() - requestStart;
      const sleep = Math.max(0, interval - elapsed);

      if (sleep > 0) {
        await new Promise(resolve => setTimeout(resolve, sleep));
      }
    }

    // 等待所有请求完成
    await new Promise(resolve => setTimeout(resolve, 5000));
  }

  getResults(): StressTestResult {
    const successful = this.results.filter(r => r.status === 200);
    const failed = this.results.filter(r => r.status !== 200);

    const errors = new Map<string, number>();
    failed.forEach(r => {
      const key = r.error || `HTTP ${r.status}`;
      errors.set(key, (errors.get(key) || 0) + 1);
    });

    const totalDuration = this.results.reduce((sum, r) => sum + r.duration, 0);
    const testDuration = this.results.length > 0
      ? this.results[this.results.length - 1].duration
      : 0;

    return {
      totalRequests: this.results.length,
      successfulRequests: successful.length,
      failedRequests: failed.length,
      duration: testDuration,
      requestsPerSecond: this.results.length / (testDuration / 1000),
      avgResponseTime: totalDuration / this.results.length,
      errors
    };
  }

  printResults(): void {
    const results = this.getResults();

    console.log(`\n📊 Stress Test Results:`);
    console.log(`  Total requests:     ${results.totalRequests}`);
    console.log(`  Successful:         ${results.successfulRequests}`);
    console.log(`  Failed:             ${results.failedRequests}`);
    console.log(`  Success rate:       ${((results.successfulRequests / results.totalRequests) * 100).toFixed(2)}%`);
    console.log(`  Requests/sec:       ${results.requestsPerSecond.toFixed(2)}`);
    console.log(`  Avg response time:  ${results.avgResponseTime.toFixed(2)}ms`);

    if (results.errors.size > 0) {
      console.log(`\n  Errors:`);
      results.errors.forEach((count, error) => {
        console.log(`    ${error}: ${count}`);
      });
    }
    console.log();
  }

  reset(): void {
    this.results = [];
  }
}

describe('API 压力测试', () => {
  let stressTest: StressTest;

  beforeEach(() => {
    stressTest = new StressTest();
  });

  it('应该承受中等负载', async () => {
    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "stress test"' }
    }, {
      duration: 30,  // 30秒
      rps: 50        // 50 requests/sec
    });

    stressTest.printResults();

    const results = stressTest.getResults();
    expect(results.successfulRequests / results.totalRequests).toBeGreaterThan(0.95);
  }, 60000);

  it('应该承受高负载', async () => {
    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "high load"' }
    }, {
      duration: 60,   // 60秒
      rps: 200        // 200 requests/sec
    });

    stressTest.printResults();

    const results = stressTest.getResults();
    expect(results.successfulRequests / results.totalRequests).toBeGreaterThan(0.90);
  }, 120000);

  it('应该报告系统资源使用', async () => {
    const initialMemory = process.memoryUsage();
    const initialCPU = process.cpuUsage();

    await stressTest.run('/api/tools/execute', {
      tool: 'bash',
      parameters: { command: 'echo "resource test"' }
    }, {
      duration: 30,
      rps: 100
    });

    const finalMemory = process.memoryUsage();
    const finalCPU = process.cpuUsage(initialCPU);

    console.log(`\n💻 Resource Usage:`);
    console.log(`  Memory:`);
    console.log(`    Heap Used: ${((finalMemory.heapUsed - initialMemory.heapUsed) / 1024 / 1024).toFixed(2)} MB`);
    console.log(`    External: ${((finalMemory.external - initialMemory.external) / 1024 / 1024).toFixed(2)} MB`);
    console.log(`  CPU:`);
    console.log(`    User: ${(finalCPU.user / 1000000).toFixed(2)}s`);
    console.log(`    System: ${(finalCPU.system / 1000000).toFixed(2)}s`);
    console.log();
  }, 60000);
});
```

## 8. CI/CD 流程

### 8.1 GitHub Actions 配置

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  NODE_VERSION: '18.x'
  JAVA_VERSION: '17'

jobs:
  # 代码质量检查
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check formatting
        run: npm run format:check

      - name: Type check
        run: npm run type-check

  # 单元测试
  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-unit

      - name: Check coverage thresholds
        run: npm run test:coverage-check

  # 集成测试
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: claudecode_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run database migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/claudecode_test

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/claudecode_test
          REDIS_URL: redis://localhost:6379

  # E2E 测试
  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

  # 性能测试
  performance-test:
    name: Performance Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run performance tests
        run: npm run test:performance

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: performance-results/

  # 安全扫描
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Run npm audit
        run: npm audit --audit-level=moderate

      - name: Run Snyk scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

      - name: Run SAST scan
        uses: github/codeql-action/analyze@v2

  # 构建
  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, unit-test, integration-test]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/

  # 部署到测试环境
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, e2e-test]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.claudecode.example.com

    steps:
      - uses: actions/checkout@v3

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist
          path: dist/

      - name: Deploy to staging
        run: |
          # 部署逻辑
          echo "Deploying to staging..."

      - name: Run smoke tests
        run: npm run test:smoke -- --env=staging

  # 部署到生产环境
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, e2e-test, security-scan]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://claudecode.example.com

    steps:
      - uses: actions/checkout@v3

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist
          path: dist/

      - name: Deploy to production
        run: |
          # 部署逻辑
          echo "Deploying to production..."

      - name: Run smoke tests
        run: npm run test:smoke -- --env=production

      - name: Create release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          draft: false
          prerelease: false
```

### 8.2 CI/CD 流程图

```mermaid
graph TB
    A[代码提交] --> B[Lint检查]
    B --> C[单元测试]
    C --> D[集成测试]
    D --> E[E2E测试]
    E --> F[安全扫描]
    F --> G[构建]

    G --> H{分支判断}

    H -->|develop| I[部署到Staging]
    H -->|main| J[部署到Production]

    I --> K[Staging冒烟测试]
    J --> L[Production冒烟测试]

    K --> M[测试通过]
    L --> N[发布完成]

    B -.失败.-> O[停止流程]
    C -.失败.-> O
    D -.失败.-> O
    E -.失败.-> O
    F -.失败.-> O

    style A fill:#e1f5ff
    style G fill:#d4edda
    style N fill:#d4edda
    style O fill:#f8d7da
```

## 9. 代码质量工具

### 9.1 ESLint 配置

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint',
    'import',
    'jest',
    'security'
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
    'plugin:import/errors',
    'plugin:import/warnings',
    'plugin:import/typescript',
    'plugin:jest/recommended',
    'plugin:security/recommended',
    'prettier'
  ],
  rules: {
    // TypeScript 规则
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_'
    }],
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/await-thenable': 'error',

    // Import 规则
    'import/order': ['error', {
      'groups': [
        'builtin',
        'external',
        'internal',
        'parent',
        'sibling',
        'index'
      ],
      'newlines-between': 'always',
      'alphabetize': {
        'order': 'asc',
        'caseInsensitive': true
      }
    }],
    'import/no-unresolved': 'error',
    'import/no-cycle': 'error',

    // 安全规则
    'security/detect-object-injection': 'warn',
    'security/detect-non-literal-regexp': 'warn',
    'security/detect-unsafe-regex': 'error',

    // 通用规则
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'no-debugger': 'error',
    'prefer-const': 'error',
    'no-var': 'error'
  },
  overrides: [
    {
      files: ['*.test.ts', '*.spec.ts'],
      env: {
        jest: true
      },
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
        'security/detect-object-injection': 'off'
      }
    }
  ]
};
```

### 9.2 SonarQube 配置

```properties
# sonar-project.properties
sonar.projectKey=claude-code
sonar.projectName=Claude Code
sonar.projectVersion=1.0.0

sonar.sources=src
sonar.tests=tests
sonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**

# TypeScript 配置
sonar.typescript.lcov.reportPaths=coverage/lcov.info
sonar.typescript.tsconfigPath=tsconfig.json

# 测试覆盖率
sonar.coverage.exclusions=**/*.test.ts,**/*.spec.ts,**/tests/**

# 代码重复
sonar.cpd.exclusions=**/*.test.ts,**/*.spec.ts

# 质量门
sonar.qualitygate.wait=true

# 代码质量规则
sonar.javascript.coveragePlugin=lcov
sonar.testExecutionReportPaths=test-results/sonar-report.xml
```

### 9.3 代码质量监控

```typescript
// scripts/quality-check.ts
import { execSync } from 'child_process';
import * as fs from 'fs';

interface QualityMetrics {
  coverage: {
    lines: number;
    statements: number;
    functions: number;
    branches: number;
  };
  lintIssues: {
    errors: number;
    warnings: number;
  };
  complexity: {
    average: number;
    max: number;
  };
  duplications: number;
}

function runQualityChecks(): QualityMetrics {
  console.log('🔍 Running quality checks...\n');

  // 运行测试覆盖率
  console.log('1. Checking test coverage...');
  execSync('npm run test:coverage', { stdio: 'inherit' });
  const coverage = JSON.parse(
    fs.readFileSync('coverage/coverage-summary.json', 'utf-8')
  ).total;

  // 运行 ESLint
  console.log('\n2. Running ESLint...');
  const lintOutput = execSync('npm run lint -- --format json', {
    encoding: 'utf-8'
  });
  const lintResults = JSON.parse(lintOutput);
  const lintIssues = {
    errors: lintResults.reduce((sum: number, r: any) => sum + r.errorCount, 0),
    warnings: lintResults.reduce((sum: number, r: any) => sum + r.warningCount, 0)
  };

  // 计算复杂度
  console.log('\n3. Analyzing code complexity...');
  const complexityOutput = execSync('npm run complexity -- --format json', {
    encoding: 'utf-8'
  });
  const complexityResults = JSON.parse(complexityOutput);
  const complexity = {
    average: complexityResults.average,
    max: complexityResults.max
  };

  // 检查代码重复
  console.log('\n4. Checking for duplications...');
  const duplicationOutput = execSync('npm run duplications -- --format json', {
    encoding: 'utf-8'
  });
  const duplications = JSON.parse(duplicationOutput).percentage;

  return {
    coverage: {
      lines: coverage.lines.pct,
      statements: coverage.statements.pct,
      functions: coverage.functions.pct,
      branches: coverage.branches.pct
    },
    lintIssues,
    complexity,
    duplications
  };
}

function generateReport(metrics: QualityMetrics): void {
  console.log('\n📊 Quality Report:\n');

  console.log('Coverage:');
  console.log(`  Lines:      ${metrics.coverage.lines.toFixed(2)}%`);
  console.log(`  Statements: ${metrics.coverage.statements.toFixed(2)}%`);
  console.log(`  Functions:  ${metrics.coverage.functions.toFixed(2)}%`);
  console.log(`  Branches:   ${metrics.coverage.branches.toFixed(2)}%`);

  console.log('\nLint Issues:');
  console.log(`  Errors:   ${metrics.lintIssues.errors}`);
  console.log(`  Warnings: ${metrics.lintIssues.warnings}`);

  console.log('\nComplexity:');
  console.log(`  Average: ${metrics.complexity.average.toFixed(2)}`);
  console.log(`  Max:     ${metrics.complexity.max}`);

  console.log(`\nCode Duplication: ${metrics.duplications.toFixed(2)}%`);

  // 质量评分
  const score = calculateQualityScore(metrics);
  console.log(`\n🎯 Quality Score: ${score}/100`);

  if (score < 80) {
    console.error('\n❌ Quality score is below threshold (80)');
    process.exit(1);
  } else {
    console.log('\n✅ Quality checks passed!');
  }
}

function calculateQualityScore(metrics: QualityMetrics): number {
  const coverageScore = (
    metrics.coverage.lines +
    metrics.coverage.statements +
    metrics.coverage.functions +
    metrics.coverage.branches
  ) / 4;

  const lintScore = Math.max(0, 100 - (
    metrics.lintIssues.errors * 5 +
    metrics.lintIssues.warnings * 1
  ));

  const complexityScore = Math.max(0, 100 - (
    (metrics.complexity.average - 10) * 2 +
    (metrics.complexity.max - 20)
  ));

  const duplicationScore = Math.max(0, 100 - metrics.duplications * 10);

  return (coverageScore * 0.4 + lintScore * 0.3 + complexityScore * 0.2 + duplicationScore * 0.1);
}

// 运行质量检查
const metrics = runQualityChecks();
generateReport(metrics);
```

## 10. 实战案例和最佳实践

### 10.1 测试驱动开发（TDD）示例

```typescript
// 步骤 1: 编写失败的测试
describe('FileSearch Tool', () => {
  it('应该在目录中搜索文件', async () => {
    const searchTool = new FileSearchTool();

    const result = await searchTool.execute({
      pattern: '*.ts',
      directory: '/project/src'
    });

    expect(result.success).toBe(true);
    expect(result.files).toContain('/project/src/index.ts');
  });
});

// 步骤 2: 编写最小实现
class FileSearchTool implements Tool {
  async execute(params: { pattern: string; directory: string }): Promise<ToolResult> {
    // 最小实现让测试通过
    return {
      success: true,
      files: ['/project/src/index.ts']
    };
  }
}

// 步骤 3: 重构实现
class FileSearchTool implements Tool {
  async execute(params: { pattern: string; directory: string }): Promise<ToolResult> {
    const { pattern, directory } = params;

    try {
      const files = await this.searchFiles(directory, pattern);
      return {
        success: true,
        files
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  private async searchFiles(dir: string, pattern: string): Promise<string[]> {
    // 实际实现
    const glob = require('glob');
    return new Promise((resolve, reject) => {
      glob(pattern, { cwd: dir, absolute: true }, (err, files) => {
        if (err) reject(err);
        else resolve(files);
      });
    });
  }
}
```

### 10.2 测试最佳实践

```typescript
// ✅ 好的测试实践

describe('ToolExecutor', () => {
  // 1. 清晰的测试描述
  it('应该在工具执行失败时抛出 ToolExecutionException', async () => {
    // 2. AAA 模式: Arrange, Act, Assert

    // Arrange
    const executor = new ToolExecutor();
    const mockTool = createMockTool({ shouldFail: true });
    executor.registerTool('mock', mockTool);

    // Act & Assert
    await expect(
      executor.execute('mock', {})
    ).rejects.toThrow(ToolExecutionException);
  });

  // 3. 每个测试只验证一件事
  it('应该记录工具执行时间', async () => {
    const executor = new ToolExecutor();
    const logger = createMockLogger();
    executor.setLogger(logger);

    await executor.execute('bash', { command: 'echo test' });

    expect(logger.info).toHaveBeenCalledWith(
      expect.stringContaining('execution time')
    );
  });

  // 4. 使用测试数据构建器
  it('应该验证工具参数', async () => {
    const executor = new ToolExecutor();
    const params = new ToolParamsBuilder()
      .withCommand('ls')
      .withTimeout(5000)
      .build();

    const result = await executor.execute('bash', params);

    expect(result.success).toBe(true);
  });

  // 5. 正确清理测试资源
  afterEach(() => {
    executor.cleanup();
    jest.clearAllMocks();
  });
});

// ❌ 不好的测试实践

describe('Bad Tests', () => {
  // 1. 模糊的测试描述
  it('test1', () => {
    // ...
  });

  // 2. 测试过多的内容
  it('should do everything', async () => {
    // 验证多个不相关的功能
    expect(toolA.execute()).toBeTruthy();
    expect(toolB.execute()).toBeTruthy();
    expect(toolC.execute()).toBeTruthy();
  });

  // 3. 依赖测试执行顺序
  it('step 1', () => {
    globalState.value = 'test';
  });

  it('step 2', () => {
    expect(globalState.value).toBe('test'); // 依赖前一个测试
  });

  // 4. 硬编码的魔法值
  it('should work', () => {
    const result = tool.execute({ timeout: 12345 });
    expect(result.data.length).toBe(42);
  });
});
```

### 10.3 测试金字塔实践

```typescript
// 单元测试 (60%) - 快速、隔离、精确
describe('BashTool Unit Tests', () => {
  it('应该构建正确的命令参数', () => {
    const bashTool = new BashTool();
    const args = bashTool.buildCommandArgs({
      command: 'ls -la',
      timeout: 5000
    });

    expect(args).toEqual(['bash', '-c', 'ls -la']);
  });
});

// 集成测试 (30%) - 验证组件协作
describe('BashTool Integration Tests', () => {
  it('应该正确执行系统命令', async () => {
    const bashTool = new BashTool();

    const result = await bashTool.execute({
      command: 'echo "test"'
    });

    expect(result.stdout).toContain('test');
    expect(result.exitCode).toBe(0);
  });
});

// E2E 测试 (10%) - 验证完整用户流程
describe('Complete Tool Execution Flow E2E', () => {
  it('应该从用户请求到结果返回完整工作', async ({ page }) => {
    await page.goto('/');
    await page.fill('[data-testid="input"]', 'List files');
    await page.click('[data-testid="submit"]');

    await expect(page.locator('[data-testid="result"]'))
      .toContainText('Files in directory');
  });
});
```

## 11. FAQ

**Q: 单元测试和集成测试的区别是什么？**

A: 单元测试关注单个函数或类的行为，完全隔离外部依赖（使用 Mock）。集成测试验证多个组件协作时的行为，通常包含真实的依赖（如数据库、文件系统）。

**Q: 测试覆盖率达到多少合适？**

A: 一般建议：
- 核心业务逻辑：90%+
- 工具和安全模块：85%+
- 整体项目：80%+

但覆盖率不是唯一指标，测试质量更重要。

**Q: 如何测试异步代码？**

A: 使用 `async/await` 或返回 Promise，确保测试等待异步操作完成：

```typescript
it('should handle async operation', async () => {
  const result = await asyncFunction();
  expect(result).toBe(expected);
});
```

**Q: Mock 和 Stub 有什么区别？**

A: Mock 用于验证行为（是否被调用、如何被调用），Stub 用于提供预定义的响应。Mock 更关注交互，Stub 更关注状态。

**Q: 如何处理测试中的时间依赖？**

A: 使用 Jest 的定时器 Mock：

```typescript
jest.useFakeTimers();
functionThatUsesTimer();
jest.advanceTimersByTime(1000);
expect(callback).toHaveBeenCalled();
jest.useRealTimers();
```

**Q: E2E 测试执行缓慢怎么办？**

A:
1. 并行执行测试
2. 只在关键场景使用 E2E 测试
3. 使用测试数据快照
4. 优化测试环境配置

**Q: 如何测试错误场景？**

A: 使用 `expect().toThrow()` 或 `expect().rejects.toThrow()`：

```typescript
expect(() => {
  dangerousFunction();
}).toThrow('Expected error message');

await expect(asyncDangerousFunction())
  .rejects.toThrow(CustomError);
```

**Q: CI/CD 中测试失败如何调试？**

A:
1. 查看详细的测试日志
2. 下载测试截图/视频（E2E）
3. 在本地复现 CI 环境
4. 使用 `--verbose` 和 `--no-coverage` 获取更多信息

**Q: 如何组织大型项目的测试代码？**

A:
1. 按功能模块组织测试目录
2. 使用共享的测试工具和辅助函数
3. 创建测试数据工厂
4. 维护清晰的命名约定

**Q: 性能测试和压力测试的区别？**

A: 性能测试测量系统在正常负载下的响应时间、吞吐量等指标。压力测试在极端负载下测试系统的稳定性和恢复能力。

---

通过完善的测试与质量保证体系，Claude Code 确保了系统的稳定性、可靠性和高质量的用户体验。测试不仅是质量保证手段，更是开发过程中的重要文档和设计工具。
